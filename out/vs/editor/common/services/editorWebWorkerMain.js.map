{"version":3,"sources":["../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/errors.ts","../../../../../vs/base/common/errors.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/collections.ts","../../../../../vs/base/common/collections.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/arraysFind.ts","../../../../../vs/base/common/arraysFind.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/arrays.ts","../../../../../vs/base/common/arrays.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/map.ts","../../../../../vs/base/common/map.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/assert.ts","../../../../../vs/base/common/assert.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/types.ts","../../../../../vs/base/common/types.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/iterator.ts","../../../../../vs/base/common/iterator.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/lifecycle.ts","../../../../../vs/base/common/lifecycle.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/linkedList.ts","../../../../../vs/base/common/linkedList.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/stopwatch.ts","../../../../../vs/base/common/stopwatch.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/event.ts","../../../../../vs/base/common/event.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/nls.messages.ts","../../../../../vs/nls.messages.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/nls.ts","../../../../../vs/nls.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/platform.ts","../../../../../vs/base/common/platform.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/cancellation.ts","../../../../../vs/base/common/cancellation.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/cache.ts","../../../../../vs/base/common/cache.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/lazy.ts","../../../../../vs/base/common/lazy.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/strings.ts","../../../../../vs/base/common/strings.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/worker/webWorker.ts","../../../../../vs/base/common/worker/webWorker.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/worker/webWorkerBootstrap.ts","../../../../../vs/base/common/worker/webWorkerBootstrap.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/diff/diffChange.ts","../../../../../vs/base/common/diff/diffChange.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/buffer.ts","../../../../../vs/base/common/buffer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/hash.ts","../../../../../vs/base/common/hash.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/diff/diff.ts","../../../../../vs/base/common/diff/diff.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/position.ts","../../../../../vs/editor/common/core/position.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/range.ts","../../../../../vs/editor/common/core/range.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/uint.ts","../../../../../vs/base/common/uint.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/characterClassifier.ts","../../../../../vs/editor/common/core/characterClassifier.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/languages/linkComputer.ts","../../../../../vs/editor/common/languages/linkComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/languages/supports/inplaceReplaceSupport.ts","../../../../../vs/editor/common/languages/supports/inplaceReplaceSupport.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/keyCodes.ts","../../../../../vs/base/common/keyCodes.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/process.ts","../../../../../vs/base/common/process.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/path.ts","../../../../../vs/base/common/path.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/uri.ts","../../../../../vs/base/common/uri.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/selection.ts","../../../../../vs/editor/common/core/selection.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/codiconsUtil.ts","../../../../../vs/base/common/codiconsUtil.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/codiconsLibrary.ts","../../../../../vs/base/common/codiconsLibrary.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/codicons.ts","../../../../../vs/base/common/codicons.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/tokenizationRegistry.ts","../../../../../vs/editor/common/tokenizationRegistry.ts","../../../../../vs/editor/common/languages.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/standalone/standaloneEnums.ts","../../../../../vs/editor/common/standalone/standaloneEnums.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/editorBaseApi.ts","../../../../../vs/editor/common/services/editorBaseApi.ts","../../../../../vs/base/common/date.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/wordCharacterClassifier.ts","../../../../../vs/editor/common/core/wordCharacterClassifier.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/model.ts","../../../../../vs/editor/common/model.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/model/textModelSearch.ts","../../../../../vs/editor/common/model/textModelSearch.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/wordHelper.ts","../../../../../vs/editor/common/core/wordHelper.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/unicodeTextModelHighlighter.ts","../../../../../vs/editor/common/services/unicodeTextModelHighlighter.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/linesDiffComputer.ts","../../../../../vs/editor/common/diff/linesDiffComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/ranges/offsetRange.ts","../../../../../vs/editor/common/core/ranges/offsetRange.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/ranges/lineRange.ts","../../../../../vs/editor/common/core/ranges/lineRange.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/text/textLength.ts","../../../../../vs/editor/common/core/text/textLength.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/text/positionToOffsetImpl.ts","../../../../../vs/editor/common/core/text/positionToOffsetImpl.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/text/abstractText.ts","../../../../../vs/editor/common/core/text/abstractText.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/edits/textEdit.ts","../../../../../vs/editor/common/core/edits/textEdit.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/rangeMapping.ts","../../../../../vs/editor/common/diff/rangeMapping.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/legacyLinesDiffComputer.ts","../../../../../vs/editor/common/diff/legacyLinesDiffComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/utils.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/utils.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts","../../../../../vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/diff/linesDiffComputers.ts","../../../../../vs/editor/common/diff/linesDiffComputers.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/color.ts","../../../../../vs/base/common/color.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/languages/defaultDocumentColorsComputer.ts","../../../../../vs/editor/common/languages/defaultDocumentColorsComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/findSectionHeaders.ts","../../../../../vs/editor/common/services/findSectionHeaders.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/extpath.ts","../../../../../vs/base/common/extpath.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/network.ts","../../../../../vs/base/common/network.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/resources.ts","../../../../../vs/base/common/resources.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/symbols.ts","../../../../../vs/base/common/symbols.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/base/common/async.ts","../../../../../vs/base/common/async.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/model/prefixSumComputer.ts","../../../../../vs/editor/common/model/prefixSumComputer.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/model/mirrorTextModel.ts","../../../../../vs/editor/common/model/mirrorTextModel.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/textModelSync/textModelSync.impl.ts","../../../../../vs/editor/common/services/textModelSync/textModelSync.impl.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/edits/edit.ts","../../../../../vs/editor/common/core/edits/edit.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/edits/stringEdit.ts","../../../../../vs/editor/common/core/edits/stringEdit.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/core/text/positionToOffset.ts","../../../../../vs/editor/common/core/text/positionToOffset.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/editorWebWorker.ts","../../../../../vs/editor/common/services/editorWebWorker.ts","../../../../../file:/home/runner/work/code-oss/code-oss/vscode/src/vs/editor/common/services/editorWebWorkerMain.ts","../../../../../vs/editor/common/services/editorWebWorkerMain.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/** @skipMangle */\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nexport function isSigPipeError(e: unknown): e is Error {\n\tif (!e || typeof e !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst cast = e as Record<string, string | undefined>;\n\treturn cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n\treadonly code?: string;\n\treadonly cause?: SerializedError;\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport function transformErrorFromSerialization(data: SerializedError): Error {\n\tlet error: Error;\n\tif (data.noTelemetry) {\n\t\terror = new ErrorNoTelemetry();\n\t} else {\n\t\terror = new Error();\n\t\terror.name = data.name;\n\t}\n\terror.message = data.message;\n\terror.stack = data.stack;\n\tif (data.code) {\n\t\t(<ErrorWithCode>error).code = data.code;\n\t}\n\tif (data.cause) {\n\t\terror.cause = transformErrorFromSerialization(data.cause);\n\t}\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): unknown;\n\tgetTypeName(): string | null;\n\tgetFunction(): Function | undefined;\n\tgetFunctionName(): string | null;\n\tgetMethodName(): string | null;\n\tgetFileName(): string | null;\n\tgetLineNumber(): number | null;\n\tgetColumnNumber(): number | null;\n\tgetEvalOrigin(): string | undefined;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\nexport class PendingMigrationError extends Error {\n\n\tprivate static readonly _name = 'PendingMigrationError';\n\n\tstatic is(error: unknown): error is PendingMigrationError {\n\t\treturn error instanceof PendingMigrationError || (error instanceof Error && error.name === PendingMigrationError._name);\n\t}\n\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = PendingMigrationError._name;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class ReadonlyError extends TypeError {\n\tconstructor(name?: string) {\n\t\tsuper(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n\t}\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/** @skipMangle */\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nexport function isSigPipeError(e: unknown): e is Error {\n\tif (!e || typeof e !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst cast = e as Record<string, string | undefined>;\n\treturn cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\n\n/**\n * This function should only be called with errors that indicate a bug in the product.\n * E.g. buggy extensions/invalid user-input/network issues should not be able to trigger this code path.\n * If they are, this indicates there is also a bug in the product.\n*/\nexport function onBugIndicatingError(e: any): undefined {\n\terrorHandler.onUnexpectedError(e);\n\treturn undefined;\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n\treadonly code?: string;\n\treadonly cause?: SerializedError;\n}\n\ntype ErrorWithCode = Error & {\n\tcode: string | undefined;\n};\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message, cause } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error),\n\t\t\tcause: cause ? transformErrorForSerialization(cause) : undefined,\n\t\t\tcode: (<ErrorWithCode>error).code\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport function transformErrorFromSerialization(data: SerializedError): Error {\n\tlet error: Error;\n\tif (data.noTelemetry) {\n\t\terror = new ErrorNoTelemetry();\n\t} else {\n\t\terror = new Error();\n\t\terror.name = data.name;\n\t}\n\terror.message = data.message;\n\terror.stack = data.stack;\n\tif (data.code) {\n\t\t(<ErrorWithCode>error).code = data.code;\n\t}\n\tif (data.cause) {\n\t\terror.cause = transformErrorFromSerialization(data.cause);\n\t}\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): unknown;\n\tgetTypeName(): string | null;\n\tgetFunction(): Function | undefined;\n\tgetFunctionName(): string | null;\n\tgetMethodName(): string | null;\n\tgetFileName(): string | null;\n\tgetLineNumber(): number | null;\n\tgetColumnNumber(): number | null;\n\tgetEvalOrigin(): string | undefined;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nexport const canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\nexport class PendingMigrationError extends Error {\n\n\tprivate static readonly _name = 'PendingMigrationError';\n\n\tstatic is(error: unknown): error is PendingMigrationError {\n\t\treturn error instanceof PendingMigrationError || (error instanceof Error && error.name === PendingMigrationError._name);\n\t}\n\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = PendingMigrationError._name;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class ReadonlyError extends TypeError {\n\tconstructor(name?: string) {\n\t\tsuper(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n\t}\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// debugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport type IStringDictionary<V> = Record<string, V>;\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport type INumberDictionary<V> = Record<number, V>;\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<K extends string | number | symbol, V>(data: V[], groupFn: (element: V) => K): Record<K, V[]> {\n\tconst result: Record<K, V[]> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function groupByMap<K, V>(data: V[], groupFn: (element: V) => K): Map<K, V[]> {\n\tconst result = new Map<K, V[]>();\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result.get(key);\n\t\tif (!target) {\n\t\t\ttarget = [];\n\t\t\tresult.set(key, target);\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function diffSets<T>(before: ReadonlySet<T>, after: ReadonlySet<T>): { removed: T[]; added: T[] } {\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\tfor (const element of before) {\n\t\tif (!after.has(element)) {\n\t\t\tremoved.push(element);\n\t\t}\n\t}\n\tfor (const element of after) {\n\t\tif (!before.has(element)) {\n\t\t\tadded.push(element);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\nexport function diffMaps<K, V>(before: Map<K, V>, after: Map<K, V>): { removed: V[]; added: V[] } {\n\tconst removed: V[] = [];\n\tconst added: V[] = [];\n\tfor (const [index, value] of before) {\n\t\tif (!after.has(index)) {\n\t\t\tremoved.push(value);\n\t\t}\n\t}\n\tfor (const [index, value] of after) {\n\t\tif (!before.has(index)) {\n\t\t\tadded.push(value);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection<T>(setA: Set<T>, setB: Iterable<T>): Set<T> {\n\tconst result = new Set<T>();\n\tfor (const elem of setB) {\n\t\tif (setA.has(elem)) {\n\t\t\tresult.add(elem);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class SetWithKey<T> implements Set<T> {\n\tprivate _map = new Map<any, T>();\n\n\tconstructor(values: T[], private toKey: (t: T) => unknown) {\n\t\tfor (const value of values) {\n\t\t\tthis.add(value);\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: T): this {\n\t\tconst key = this.toKey(value);\n\t\tthis._map.set(key, value);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\treturn this._map.delete(this.toKey(value));\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this._map.has(this.toKey(value));\n\t}\n\n\t*entries(): IterableIterator<[T, T]> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield [entry, entry];\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield entry;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tforEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void {\n\t\tthis._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t[Symbol.toStringTag]: string = 'SetWithKey';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport type IStringDictionary<V> = Record<string, V>;\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport type INumberDictionary<V> = Record<number, V>;\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<K extends string | number | symbol, V>(data: V[], groupFn: (element: V) => K): Record<K, V[]> {\n\tconst result: Record<K, V[]> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function groupByMap<K, V>(data: V[], groupFn: (element: V) => K): Map<K, V[]> {\n\tconst result = new Map<K, V[]>();\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result.get(key);\n\t\tif (!target) {\n\t\t\ttarget = [];\n\t\t\tresult.set(key, target);\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function diffSets<T>(before: ReadonlySet<T>, after: ReadonlySet<T>): { removed: T[]; added: T[] } {\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\tfor (const element of before) {\n\t\tif (!after.has(element)) {\n\t\t\tremoved.push(element);\n\t\t}\n\t}\n\tfor (const element of after) {\n\t\tif (!before.has(element)) {\n\t\t\tadded.push(element);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\nexport function diffMaps<K, V>(before: Map<K, V>, after: Map<K, V>): { removed: V[]; added: V[] } {\n\tconst removed: V[] = [];\n\tconst added: V[] = [];\n\tfor (const [index, value] of before) {\n\t\tif (!after.has(index)) {\n\t\t\tremoved.push(value);\n\t\t}\n\t}\n\tfor (const [index, value] of after) {\n\t\tif (!before.has(index)) {\n\t\t\tadded.push(value);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection<T>(setA: Set<T>, setB: Iterable<T>): Set<T> {\n\tconst result = new Set<T>();\n\tfor (const elem of setB) {\n\t\tif (setA.has(elem)) {\n\t\t\tresult.add(elem);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class SetWithKey<T> implements Set<T> {\n\tprivate _map = new Map<any, T>();\n\n\tconstructor(values: T[], private toKey: (t: T) => unknown) {\n\t\tfor (const value of values) {\n\t\t\tthis.add(value);\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: T): this {\n\t\tconst key = this.toKey(value);\n\t\tthis._map.set(key, value);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\treturn this._map.delete(this.toKey(value));\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this._map.has(this.toKey(value));\n\t}\n\n\t*entries(): IterableIterator<[T, T]> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield [entry, entry];\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield entry;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tforEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void {\n\t\tthis._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t[Symbol.toStringTag]: string = 'SetWithKey';\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays.js';\n\nexport function findLast<T, R extends T>(array: readonly T[], predicate: (item: T) => item is R, fromIndex?: number): R | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex?: number): T | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex = array.length - 1): T | undefined {\n\tconst idx = findLastIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays.js';\n\nexport function findLast<T, R extends T>(array: readonly T[], predicate: (item: T) => item is R, fromIndex?: number): R | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex?: number): T | undefined;\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex = array.length - 1): T | undefined {\n\tconst idx = findLastIdx(array, predicate, fromIndex);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T) => unknown, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from './arraysFind.js';\nimport { CancellationToken } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { ISplice } from './sequence.js';\n\n/**\n * Returns the last entry and the initial N-1 entries of the array, as a tuple of [rest, last].\n *\n * The array must have at least one element.\n *\n * @param arr The input array\n * @returns A tuple of [rest, last] where rest is all but the last element and last is the last element\n * @throws Error if the array is empty\n */\nexport function tail<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy<T>(items: Iterable<T>, shouldBeGrouped: (item1: T, item2: T) => boolean): Iterable<T[]> {\n\tlet currentGroup: T[] | undefined;\n\tlet last: T | undefined;\n\tfor (const item of items) {\n\t\tif (last !== undefined && shouldBeGrouped(last, item)) {\n\t\t\tcurrentGroup!.push(item);\n\t\t} else {\n\t\t\tif (currentGroup) {\n\t\t\t\tyield currentGroup;\n\t\t\t}\n\t\t\tcurrentGroup = [item];\n\t\t}\n\t\tlast = item;\n\t}\n\tif (currentGroup) {\n\t\tyield currentGroup;\n\t}\n}\n\nexport function forEachAdjacent<T>(arr: T[], f: (item1: T | undefined, item2: T | undefined) => void): void {\n\tfor (let i = 0; i <= arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n\t}\n}\n\nexport function forEachWithNeighbors<T>(arr: T[], f: (before: T | undefined, element: T, after: T | undefined) => void): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n\t}\n}\n\nexport function concatArrays<TArr extends any[]>(...arrays: TArr): TArr[number][number][] {\n\treturn ([] as any[]).concat(...arrays);\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn array.filter((e): e is T => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): asserts array is Array<T> {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: unknown[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: unknown): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => unknown = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn!(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tlet result = array.splice(index, deleteCount);\n\tif (result === undefined) {\n\t\t// see https://bugs.webkit.org/show_bug.cgi?id=261140\n\t\tresult = [];\n\t}\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isLessThanOrEqual(result: CompareResult): boolean {\n\t\treturn result <= 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\nexport const booleanComparator: Comparator<boolean> = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\n\nexport function reverseOrder<TItem>(comparator: Comparator<TItem>): Comparator<TItem> {\n\treturn (a, b) => -comparator(a, b);\n}\n\n/**\n * Returns a new comparator that treats `undefined` as the smallest value.\n * All other values are compared using the given comparator.\n*/\nexport function compareUndefinedSmallest<T>(comparator: Comparator<T>): Comparator<T | undefined> {\n\treturn (a, b) => {\n\t\tif (a === undefined) {\n\t\t\treturn b === undefined ? CompareResult.neitherLessOrGreaterThan : CompareResult.lessThan;\n\t\t} else if (b === undefined) {\n\t\t\treturn CompareResult.greaterThan;\n\t\t}\n\n\t\treturn comparator(a, b);\n\t};\n}\n\nexport class ArrayQueue<T> {\n\tprivate readonly items: readonly T[];\n\tprivate firstIdx = 0;\n\tprivate lastIdx: number;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(items: readonly T[]) {\n\t\tthis.items = items;\n\t\tthis.lastIdx = this.items.length - 1;\n\t}\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable<T> {\n\tpublic static readonly empty = new CallbackIterable<never>(_callback => { });\n\n\tconstructor(\n\t\t/**\n\t\t * Calls the callback for every item.\n\t\t * Stops when the callback returns false.\n\t\t*/\n\t\tpublic readonly iterate: (callback: (item: T) => boolean) => void\n\t) {\n\t}\n\n\tforEach(handler: (item: T) => void) {\n\t\tthis.iterate(item => { handler(item); return true; });\n\t}\n\n\ttoArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tthis.iterate(item => { result.push(item); return true; });\n\t\treturn result;\n\t}\n\n\tfilter(predicate: (item: T) => boolean): CallbackIterable<T> {\n\t\treturn new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n\t}\n\n\tmap<TResult>(mapFn: (item: T) => TResult): CallbackIterable<TResult> {\n\t\treturn new CallbackIterable<TResult>(cb => this.iterate(item => cb(mapFn(item))));\n\t}\n\n\tsome(predicate: (item: T) => boolean): boolean {\n\t\tlet result = false;\n\t\tthis.iterate(item => { result = predicate(item); return !result; });\n\t\treturn result;\n\t}\n\n\tfindFirst(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLast(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLastMaxBy(comparator: Comparator<T>): T | undefined {\n\t\tlet result: T | undefined;\n\t\tlet first = true;\n\t\tthis.iterate(item => {\n\t\t\tif (first || CompareResult.isGreaterThan(comparator(item, result!))) {\n\t\t\t\tfirst = false;\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n}\n\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n\tconstructor(private readonly _indexMap: readonly number[]) { }\n\n\t/**\n\t * Returns a permutation that sorts the given array according to the given compare function.\n\t */\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\t/**\n\t * Returns a new array with the elements of the given array re-arranged according to this permutation.\n\t */\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\t/**\n\t * Returns a new permutation that undoes the re-arrangement of this permutation.\n\t*/\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n\n/**\n * Asynchronous variant of `Array.find()`, returning the first element in\n * the array for which the predicate returns true.\n *\n * This implementation does not bail early and waits for all promises to\n * resolve before returning.\n */\nexport async function findAsync<T>(array: readonly T[], predicate: (element: T, index: number) => Promise<boolean>): Promise<T | undefined> {\n\tconst results = await Promise.all(array.map(\n\t\tasync (element, index) => ({ element, ok: await predicate(element, index) })\n\t));\n\n\treturn results.find(r => r.ok)?.element;\n}\n\nexport function sum(array: readonly number[]): number {\n\treturn array.reduce((acc, value) => acc + value, 0);\n}\n\nexport function sumBy<T>(array: readonly T[], selector: (value: T) => number): number {\n\treturn array.reduce((acc, value) => acc + selector(value), 0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findFirstIdxMonotonousOrArrLen } from './arraysFind.js';\nimport { CancellationToken } from './cancellation.js';\nimport { CancellationError } from './errors.js';\nimport { ISplice } from './sequence.js';\n\n/**\n * Returns the last entry and the initial N-1 entries of the array, as a tuple of [rest, last].\n *\n * The array must have at least one element.\n *\n * @param arr The input array\n * @returns A tuple of [rest, last] where rest is all but the last element and last is the last element\n * @throws Error if the array is empty\n */\nexport function tail<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy<T>(items: Iterable<T>, shouldBeGrouped: (item1: T, item2: T) => boolean): Iterable<T[]> {\n\tlet currentGroup: T[] | undefined;\n\tlet last: T | undefined;\n\tfor (const item of items) {\n\t\tif (last !== undefined && shouldBeGrouped(last, item)) {\n\t\t\tcurrentGroup!.push(item);\n\t\t} else {\n\t\t\tif (currentGroup) {\n\t\t\t\tyield currentGroup;\n\t\t\t}\n\t\t\tcurrentGroup = [item];\n\t\t}\n\t\tlast = item;\n\t}\n\tif (currentGroup) {\n\t\tyield currentGroup;\n\t}\n}\n\nexport function forEachAdjacent<T>(arr: T[], f: (item1: T | undefined, item2: T | undefined) => void): void {\n\tfor (let i = 0; i <= arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n\t}\n}\n\nexport function forEachWithNeighbors<T>(arr: T[], f: (before: T | undefined, element: T, after: T | undefined) => void): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n\t}\n}\n\nexport function concatArrays<TArr extends any[]>(...arrays: TArr): TArr[number][number][] {\n\treturn ([] as any[]).concat(...arrays);\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn array.filter((e): e is T => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): asserts array is Array<T> {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: unknown[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: unknown): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => unknown = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn!(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tlet result = array.splice(index, deleteCount);\n\tif (result === undefined) {\n\t\t// see https://bugs.webkit.org/show_bug.cgi?id=261140\n\t\tresult = [];\n\t}\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isLessThanOrEqual(result: CompareResult): boolean {\n\t\treturn result <= 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\nexport const booleanComparator: Comparator<boolean> = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\n\nexport function reverseOrder<TItem>(comparator: Comparator<TItem>): Comparator<TItem> {\n\treturn (a, b) => -comparator(a, b);\n}\n\n/**\n * Returns a new comparator that treats `undefined` as the smallest value.\n * All other values are compared using the given comparator.\n*/\nexport function compareUndefinedSmallest<T>(comparator: Comparator<T>): Comparator<T | undefined> {\n\treturn (a, b) => {\n\t\tif (a === undefined) {\n\t\t\treturn b === undefined ? CompareResult.neitherLessOrGreaterThan : CompareResult.lessThan;\n\t\t} else if (b === undefined) {\n\t\t\treturn CompareResult.greaterThan;\n\t\t}\n\n\t\treturn comparator(a, b);\n\t};\n}\n\nexport class ArrayQueue<T> {\n\tprivate readonly items: readonly T[];\n\tprivate firstIdx = 0;\n\tprivate lastIdx: number;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(items: readonly T[]) {\n\t\tthis.items = items;\n\t\tthis.lastIdx = this.items.length - 1;\n\t}\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable<T> {\n\tpublic static readonly empty = new CallbackIterable<never>(_callback => { });\n\n\tconstructor(\n\t\t/**\n\t\t * Calls the callback for every item.\n\t\t * Stops when the callback returns false.\n\t\t*/\n\t\tpublic readonly iterate: (callback: (item: T) => boolean) => void\n\t) {\n\t}\n\n\tforEach(handler: (item: T) => void) {\n\t\tthis.iterate(item => { handler(item); return true; });\n\t}\n\n\ttoArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tthis.iterate(item => { result.push(item); return true; });\n\t\treturn result;\n\t}\n\n\tfilter(predicate: (item: T) => boolean): CallbackIterable<T> {\n\t\treturn new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n\t}\n\n\tmap<TResult>(mapFn: (item: T) => TResult): CallbackIterable<TResult> {\n\t\treturn new CallbackIterable<TResult>(cb => this.iterate(item => cb(mapFn(item))));\n\t}\n\n\tsome(predicate: (item: T) => boolean): boolean {\n\t\tlet result = false;\n\t\tthis.iterate(item => { result = predicate(item); return !result; });\n\t\treturn result;\n\t}\n\n\tfindFirst(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLast(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLastMaxBy(comparator: Comparator<T>): T | undefined {\n\t\tlet result: T | undefined;\n\t\tlet first = true;\n\t\tthis.iterate(item => {\n\t\t\tif (first || CompareResult.isGreaterThan(comparator(item, result!))) {\n\t\t\t\tfirst = false;\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n}\n\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n\tconstructor(private readonly _indexMap: readonly number[]) { }\n\n\t/**\n\t * Returns a permutation that sorts the given array according to the given compare function.\n\t */\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\t/**\n\t * Returns a new array with the elements of the given array re-arranged according to this permutation.\n\t */\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\t/**\n\t * Returns a new permutation that undoes the re-arrangement of this permutation.\n\t*/\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n\n/**\n * Asynchronous variant of `Array.find()`, returning the first element in\n * the array for which the predicate returns true.\n *\n * This implementation does not bail early and waits for all promises to\n * resolve before returning.\n */\nexport async function findAsync<T>(array: readonly T[], predicate: (element: T, index: number) => Promise<boolean>): Promise<T | undefined> {\n\tconst results = await Promise.all(array.map(\n\t\tasync (element, index) => ({ element, ok: await predicate(element, index) })\n\t));\n\n\treturn results.find(r => r.ok)?.element;\n}\n\nexport function sum(array: readonly number[]): number {\n\treturn array.reduce((acc, value) => acc + value, 0);\n}\n\nexport function sumBy<T>(array: readonly T[], selector: (value: T) => number): number {\n\treturn array.reduce((acc, value) => acc + selector(value), 0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from './uri.js';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nfunction isEntries<T>(arg: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[] | undefined): arg is readonly (readonly [URI, T])[] {\n\treturn Array.isArray(arg);\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(entries?: readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn);\n\n\tconstructor(arg?: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn) {\n\t\tif (arg instanceof ResourceMap) {\n\t\t\tthis.map = new Map(arg.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else if (isEntries(arg)) {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\n\t\t\tfor (const [resource, value] of arg) {\n\t\t\t\tthis.set(resource, value);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = arg ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprotected trimNew(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._tail;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.previous;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._tail = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.next = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nabstract class Cache<K, V> extends LinkedMap<K, V> {\n\n\tprotected _limit: number;\n\tprotected _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\treturn this;\n\t}\n\n\tprotected checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n\n\tprotected abstract trim(newSize: number): void;\n}\n\nexport class LRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimOld(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n}\n\nexport class MRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimNew(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tif (this._limit <= this.size && !this.has(key)) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio) - 1);\n\t\t}\n\n\t\tsuper.set(key, value);\n\t\treturn this;\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nexport class BidirectionalMap<K, V> {\n\n\tprivate readonly _m1 = new Map<K, V>();\n\tprivate readonly _m2 = new Map<V, K>();\n\n\tconstructor(entries?: readonly (readonly [K, V])[]) {\n\t\tif (entries) {\n\t\t\tfor (const [key, value] of entries) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._m1.clear();\n\t\tthis._m2.clear();\n\t}\n\n\tset(key: K, value: V): void {\n\t\tthis._m1.set(key, value);\n\t\tthis._m2.set(value, key);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._m1.get(key);\n\t}\n\n\tgetKey(value: V): K | undefined {\n\t\treturn this._m2.get(value);\n\t}\n\n\tdelete(key: K): boolean {\n\t\tconst value = this._m1.get(key);\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._m1.delete(key);\n\t\tthis._m2.delete(value);\n\t\treturn true;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: BidirectionalMap<K, V>) => void, thisArg?: any): void {\n\t\tthis._m1.forEach((value, key) => {\n\t\t\tcallbackfn.call(thisArg, value, key, this);\n\t\t});\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._m1.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._m1.values();\n\t}\n}\n\nexport class SetMap<K, V> {\n\n\tprivate map = new Map<K, Set<V>>();\n\n\tadd(key: K, value: V): void {\n\t\tlet values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\tvalues = new Set<V>();\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\tdelete(key: K, value: V): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.delete(value);\n\n\t\tif (values.size === 0) {\n\t\t\tthis.map.delete(key);\n\t\t}\n\t}\n\n\tforEach(key: K, fn: (value: V) => void): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.forEach(fn);\n\t}\n\n\tget(key: K): ReadonlySet<V> {\n\t\tconst values = this.map.get(key);\n\t\tif (!values) {\n\t\t\treturn new Set<V>();\n\t\t}\n\t\treturn values;\n\t}\n}\n\nexport function mapsStrictEqualIgnoreOrder(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.size !== b.size) {\n\t\treturn false;\n\t}\n\n\tfor (const [key, value] of a) {\n\t\tif (!b.has(key) || b.get(key) !== value) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const [key] of b) {\n\t\tif (!a.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * A map that is addressable with an arbitrary number of keys. This is useful in high performance\n * scenarios where creating a composite key whenever the data is accessed is too expensive. For\n * example for a very hot function, constructing a string like `first-second-third` for every call\n * will cause a significant hit to performance.\n */\nexport class NKeyMap<TValue, TKeys extends (string | boolean | number)[]> {\n\tprivate _data: Map<any, any> = new Map();\n\n\t/**\n\t * Sets a value on the map. Note that unlike a standard `Map`, the first argument is the value.\n\t * This is because the spread operator is used for the keys and must be last..\n\t * @param value The value to set.\n\t * @param keys The keys for the value.\n\t */\n\tpublic set(value: TValue, ...keys: [...TKeys]): void {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\tcurrentMap.set(keys[i], new Map());\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\tcurrentMap.set(keys[keys.length - 1], value);\n\t}\n\n\tpublic get(...keys: [...TKeys]): TValue | undefined {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\treturn currentMap.get(keys[keys.length - 1]);\n\t}\n\n\tpublic clear(): void {\n\t\tthis._data.clear();\n\t}\n\n\tpublic *values(): IterableIterator<TValue> {\n\t\tfunction* iterate(map: Map<any, any>): IterableIterator<TValue> {\n\t\t\tfor (const value of map.values()) {\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tyield* iterate(value);\n\t\t\t\t} else {\n\t\t\t\t\tyield value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyield* iterate(this._data);\n\t}\n\n\t/**\n\t * Get a textual representation of the map for debugging purposes.\n\t */\n\tpublic toString(): string {\n\t\tconst printMap = (map: Map<any, any>, depth: number): string => {\n\t\t\tlet result = '';\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tresult += `${'  '.repeat(depth)}${key}: `;\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tresult += '\\n' + printMap(value, depth + 1);\n\t\t\t\t} else {\n\t\t\t\t\tresult += `${value}\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\treturn printMap(this._data, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from './uri.js';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nfunction isEntries<T>(arg: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[] | undefined): arg is readonly (readonly [URI, T])[] {\n\treturn Array.isArray(arg);\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(entries?: readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn);\n\n\tconstructor(arg?: ResourceMap<T> | ResourceMapKeyFn | readonly (readonly [URI, T])[], toKey?: ResourceMapKeyFn) {\n\t\tif (arg instanceof ResourceMap) {\n\t\t\tthis.map = new Map(arg.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else if (isEntries(arg)) {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\n\t\t\tfor (const [resource, value] of arg) {\n\t\t\t\tthis.set(resource, value);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = arg ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprotected trimNew(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._tail;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.previous;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._tail = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.next = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nabstract class Cache<K, V> extends LinkedMap<K, V> {\n\n\tprotected _limit: number;\n\tprotected _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\treturn this;\n\t}\n\n\tprotected checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n\n\tprotected abstract trim(newSize: number): void;\n}\n\nexport class LRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimOld(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n}\n\nexport class MRUCache<K, V> extends Cache<K, V> {\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper(limit, ratio);\n\t}\n\n\tprotected override trim(newSize: number) {\n\t\tthis.trimNew(newSize);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tif (this._limit <= this.size && !this.has(key)) {\n\t\t\tthis.trim(Math.round(this._limit * this._ratio) - 1);\n\t\t}\n\n\t\tsuper.set(key, value);\n\t\treturn this;\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nexport class BidirectionalMap<K, V> {\n\n\tprivate readonly _m1 = new Map<K, V>();\n\tprivate readonly _m2 = new Map<V, K>();\n\n\tconstructor(entries?: readonly (readonly [K, V])[]) {\n\t\tif (entries) {\n\t\t\tfor (const [key, value] of entries) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._m1.clear();\n\t\tthis._m2.clear();\n\t}\n\n\tset(key: K, value: V): void {\n\t\tthis._m1.set(key, value);\n\t\tthis._m2.set(value, key);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._m1.get(key);\n\t}\n\n\tgetKey(value: V): K | undefined {\n\t\treturn this._m2.get(value);\n\t}\n\n\tdelete(key: K): boolean {\n\t\tconst value = this._m1.get(key);\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._m1.delete(key);\n\t\tthis._m2.delete(value);\n\t\treturn true;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: BidirectionalMap<K, V>) => void, thisArg?: any): void {\n\t\tthis._m1.forEach((value, key) => {\n\t\t\tcallbackfn.call(thisArg, value, key, this);\n\t\t});\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._m1.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._m1.values();\n\t}\n}\n\nexport class SetMap<K, V> {\n\n\tprivate map = new Map<K, Set<V>>();\n\n\tadd(key: K, value: V): void {\n\t\tlet values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\tvalues = new Set<V>();\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\tdelete(key: K, value: V): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.delete(value);\n\n\t\tif (values.size === 0) {\n\t\t\tthis.map.delete(key);\n\t\t}\n\t}\n\n\tforEach(key: K, fn: (value: V) => void): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.forEach(fn);\n\t}\n\n\tget(key: K): ReadonlySet<V> {\n\t\tconst values = this.map.get(key);\n\t\tif (!values) {\n\t\t\treturn new Set<V>();\n\t\t}\n\t\treturn values;\n\t}\n}\n\nexport function mapsStrictEqualIgnoreOrder(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.size !== b.size) {\n\t\treturn false;\n\t}\n\n\tfor (const [key, value] of a) {\n\t\tif (!b.has(key) || b.get(key) !== value) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const [key] of b) {\n\t\tif (!a.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * A map that is addressable with an arbitrary number of keys. This is useful in high performance\n * scenarios where creating a composite key whenever the data is accessed is too expensive. For\n * example for a very hot function, constructing a string like `first-second-third` for every call\n * will cause a significant hit to performance.\n */\nexport class NKeyMap<TValue, TKeys extends (string | boolean | number)[]> {\n\tprivate _data: Map<any, any> = new Map();\n\n\t/**\n\t * Sets a value on the map. Note that unlike a standard `Map`, the first argument is the value.\n\t * This is because the spread operator is used for the keys and must be last..\n\t * @param value The value to set.\n\t * @param keys The keys for the value.\n\t */\n\tpublic set(value: TValue, ...keys: [...TKeys]): void {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\tcurrentMap.set(keys[i], new Map());\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\tcurrentMap.set(keys[keys.length - 1], value);\n\t}\n\n\tpublic get(...keys: [...TKeys]): TValue | undefined {\n\t\tlet currentMap = this._data;\n\t\tfor (let i = 0; i < keys.length - 1; i++) {\n\t\t\tif (!currentMap.has(keys[i])) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tcurrentMap = currentMap.get(keys[i]);\n\t\t}\n\t\treturn currentMap.get(keys[keys.length - 1]);\n\t}\n\n\tpublic clear(): void {\n\t\tthis._data.clear();\n\t}\n\n\tpublic *values(): IterableIterator<TValue> {\n\t\tfunction* iterate(map: Map<any, any>): IterableIterator<TValue> {\n\t\t\tfor (const value of map.values()) {\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tyield* iterate(value);\n\t\t\t\t} else {\n\t\t\t\t\tyield value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tyield* iterate(this._data);\n\t}\n\n\t/**\n\t * Get a textual representation of the map for debugging purposes.\n\t */\n\tpublic toString(): string {\n\t\tconst printMap = (map: Map<any, any>, depth: number): string => {\n\t\t\tlet result = '';\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tresult += `${'  '.repeat(depth)}${key}: `;\n\t\t\t\tif (value instanceof Map) {\n\t\t\t\t\tresult += '\\n' + printMap(value, depth + 1);\n\t\t\t\t} else {\n\t\t\t\t\tresult += `${value}\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\treturn printMap(this._data, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value?: unknown, message?: string) {\n\tif (!value) {\n\t\tthrow new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n\t}\n}\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n\n/**\n * Asserts that a condition is `truthy`.\n *\n * @throws provided {@linkcode messageOrError} if the {@linkcode condition} is `falsy`.\n *\n * @param condition The condition to assert.\n * @param messageOrError An error message or error object to throw if condition is `falsy`.\n */\nexport function assert(\n\tcondition: boolean,\n\tmessageOrError: string | Error = 'unexpected state',\n): asserts condition {\n\tif (!condition) {\n\t\t// if error instance is provided, use it, otherwise create a new one\n\t\tconst errorToThrow = typeof messageOrError === 'string'\n\t\t\t? new BugIndicatingError(`Assertion Failed: ${messageOrError}`)\n\t\t\t: messageOrError;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition: boolean, message = 'Soft Assertion Failed'): void {\n\tif (!condition) {\n\t\tonUnexpectedError(new BugIndicatingError(message));\n\t}\n}\n\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition: () => boolean): void {\n\tif (!condition()) {\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t\t// Reevaluate `condition` again to make debugging easier\n\t\tcondition();\n\t\tonUnexpectedError(new BugIndicatingError('Assertion Failed'));\n\t}\n}\n\nexport function checkAdjacentItems<T>(items: readonly T[], predicate: (item1: T, item2: T) => boolean): boolean {\n\tlet i = 0;\n\twhile (i < items.length - 1) {\n\t\tconst a = items[i];\n\t\tconst b = items[i + 1];\n\t\tif (!predicate(a, b)) {\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t}\n\treturn true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn Array.isArray(value) && (<unknown[]>value).every(elem => isString(elem));\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from './assert.js';\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn Array.isArray(value) && (<unknown[]>value).every(elem => isString(elem));\n}\n\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isAsyncIterable<T>(obj: unknown): obj is AsyncIterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n *\n * @see {@link assertDefined} for a similar utility that leverages TS assertion functions to narrow down the type of `arg` to be non-nullable.\n */\nexport function assertReturnsDefined<T>(arg: T | null | undefined): NonNullable<T> {\n\tassert(\n\t\targ !== null && arg !== undefined,\n\t\t'Argument is `undefined` or `null`.',\n\t);\n\n\treturn arg;\n}\n\n/**\n * Asserts that a provided `value` is `defined` - not `null` or `undefined`,\n * throwing an error with the provided error or error message, while also\n * narrowing down the type of the `value` to be `NonNullable` using TS\n * assertion functions.\n *\n * @throws if the provided `value` is `null` or `undefined`.\n *\n * ## Examples\n *\n * ```typescript\n * // an assert with an error message\n * assertDefined('some value', 'String constant is not defined o_O.');\n *\n * // `throws!` the provided error\n * assertDefined(null, new Error('Should throw this error.'));\n *\n * // narrows down the type of `someValue` to be non-nullable\n * const someValue: string | undefined | null = blackbox();\n * assertDefined(someValue, 'Some value must be defined.');\n * console.log(someValue.length); // now type of `someValue` is `string`\n * ```\n *\n * @see {@link assertReturnsDefined} for a similar utility but without assertion.\n * @see {@link https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions typescript-3-7.html#assertion-functions}\n */\nexport function assertDefined<T>(value: T, error: string | NonNullable<Error>): asserts value is NonNullable<T> {\n\tif (value === null || value === undefined) {\n\t\tconst errorToThrow = typeof error === 'string' ? new Error(error) : error;\n\n\t\tthrow errorToThrow;\n\t}\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertReturnsAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertReturnsAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertReturnsAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertReturnsAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\n/**\n * Checks if the provided value is one of the vales in the provided list.\n *\n * ## Examples\n *\n * ```typescript\n * // note! item type is a `subset of string`\n * type TItem = ':' | '.' | '/';\n *\n * // note! item is type of `string` here\n * const item: string = ':';\n * // list of the items to check against\n * const list: TItem[] = [':', '.'];\n *\n * // ok\n * assert(\n *   isOneOf(item, list),\n *   'Must succeed.',\n * );\n *\n * // `item` is of `TItem` type now\n * ```\n */\nexport const isOneOf = <TType, TSubtype extends TType>(\n\tvalue: TType,\n\tvalidValues: readonly TSubtype[],\n): value is TSubtype => {\n\t// note! it is OK to type cast here, because we rely on the includes\n\t//       utility to check if the value is present in the provided list\n\treturn validValues.includes(<TSubtype>value);\n};\n\n/**\n * Compile-time type check of a variable.\n */\nexport function typeCheck<T = never>(_thing: NoInfer<T>): void { }\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Helper type assertion that safely upcasts a type to a supertype.\n *\n * This can be used to make sure the argument correctly conforms to the subtype while still being able to pass it\n * to contexts that expects the supertype.\n */\nexport function upcast<Base, Sub extends Base = Base>(x: Sub): Base {\n\treturn x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Given an object with all optional properties, requires at least one to be defined.\n * i.e. AtLeastOne<MyObject>;\n */\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U];\n\n/**\n * Only picks the non-optional properties of a type.\n */\nexport type OmitOptional<T> = { [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K] };\n\n/**\n * A type that removed readonly-less from all properties of `T`\n */\nexport type Mutable<T> = {\n\t-readonly [P in keyof T]: T[P]\n};\n\n/**\n * A single object or an array of the objects.\n */\nexport type SingleOrMany<T> = T | T[];\n\n\n/**\n * A type that recursively makes all properties of `T` required\n */\nexport type DeepRequiredNonNullable<T> = {\n\t[P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;\n};\n\n\n/**\n * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.\n */\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;\n};\n\n/**\n * Represents a type that is a partial version of a given type `T`, except a subset.\n */\nexport type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isIterable } from './types.js';\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: unknown): thing is Iterable<T> {\n\t\treturn !!thing && typeof thing === 'object' && typeof (thing as Iterable<T>)[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function wrap<T>(iterableOrElement: Iterable<T> | T): Iterable<T> {\n\t\tif (is(iterableOrElement)) {\n\t\t\treturn iterableOrElement;\n\t\t} else {\n\t\t\treturn single(iterableOrElement);\n\t\t}\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function* reverse<T>(array: ReadonlyArray<T>): Iterable<T> {\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tyield array[i];\n\t\t}\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element, i++)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function every<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (!predicate(element, i++)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): R | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* flatMap<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => Iterable<R>): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield* fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: (Iterable<T> | T)[]): Iterable<T> {\n\t\tfor (const item of iterables) {\n\t\t\tif (isIterable(item)) {\n\t\t\t\tyield* item;\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\texport function length<T>(iterable: Iterable<T>): number {\n\t\tlet count = 0;\n\t\tfor (const _ of iterable) {\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < -arr.length) {\n\t\t\tfrom = 0;\n\t\t}\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\texport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\texport async function asyncToArrayFlat<T>(iterable: AsyncIterable<T[]>): Promise<T[]> {\n\t\tlet result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult = result.concat(item);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isIterable } from './types.js';\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: unknown): thing is Iterable<T> {\n\t\treturn !!thing && typeof thing === 'object' && typeof (thing as Iterable<T>)[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function wrap<T>(iterableOrElement: Iterable<T> | T): Iterable<T> {\n\t\tif (is(iterableOrElement)) {\n\t\t\treturn iterableOrElement;\n\t\t} else {\n\t\t\treturn single(iterableOrElement);\n\t\t}\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function* reverse<T>(array: ReadonlyArray<T>): Iterable<T> {\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tyield array[i];\n\t\t}\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element, i++)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function every<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (!predicate(element, i++)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): R | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* flatMap<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => Iterable<R>): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield* fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: (Iterable<T> | T)[]): Iterable<T> {\n\t\tfor (const item of iterables) {\n\t\t\tif (isIterable(item)) {\n\t\t\t\tyield* item;\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\texport function length<T>(iterable: Iterable<T>): number {\n\t\tlet count = 0;\n\t\tfor (const _ of iterable) {\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < -arr.length) {\n\t\t\tfrom = 0;\n\t\t}\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\texport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\texport async function asyncToArrayFlat<T>(iterable: AsyncIterable<T[]>): Promise<T[]> {\n\t\tlet result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult = result.concat(item);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport class GCBasedDisposableTracker implements IDisposableTracker {\n\n\tprivate readonly _registry = new FinalizationRegistry<string>(heldValue => {\n\t\tconsole.warn(`[LEAKED DISPOSABLE] ${heldValue}`);\n\t});\n\n\ttrackDisposable(disposable: IDisposable): void {\n\t\tconst stack = new Error('CREATED via:').stack!;\n\t\tthis._registry.register(disposable, stack, disposable);\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tif (parent) {\n\t\t\tthis._registry.unregister(child);\n\t\t} else {\n\t\t\tthis.trackDisposable(child);\n\t\t}\n\t}\n\n\tmarkAsDisposed(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E extends any>(thing: E): thing is E & IDisposable {\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\nclass FunctionDisposable implements IDisposable {\n\tprivate _isDisposed: boolean;\n\tprivate readonly _fn: () => void;\n\n\tconstructor(fn: () => void) {\n\t\tthis._isDisposed = false;\n\t\tthis._fn = fn;\n\t\ttrackDisposable(this);\n\t}\n\n\tdispose() {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fn) {\n\t\t\tthrow new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);\n\t\t}\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._fn();\n\t}\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn new FunctionDisposable(fn);\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o || o === Disposable.None) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n\n\tpublic assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tonUnexpectedError(new BugIndicatingError('Object disposed'));\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t\tsetParentOfDisposable(value, this);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, null);\n\t\t}\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n\n/**\n * Call `then` on a Promise, unless the returned disposable is disposed.\n */\nexport function thenIfNotDisposed<T>(promise: Promise<T>, then: (result: T) => void): IDisposable {\n\tlet disposed = false;\n\tpromise.then(result => {\n\t\tif (disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthen(result);\n\t});\n\treturn toDisposable(() => {\n\t\tdisposed = true;\n\t});\n}\n\n/**\n * Call `then` on a promise that resolves to a {@link IDisposable}, then either register the\n * disposable or register it to the {@link DisposableStore}, depending on whether the store is\n * disposed or not.\n */\nexport function thenRegisterOrDispose<T extends IDisposable>(promise: Promise<T>, store: DisposableStore): Promise<T> {\n\treturn promise.then(disposable => {\n\t\tif (store.isDisposed) {\n\t\t\tdisposable.dispose();\n\t\t} else {\n\t\t\tstore.add(disposable);\n\t\t}\n\t\treturn disposable;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport class GCBasedDisposableTracker implements IDisposableTracker {\n\n\tprivate readonly _registry = new FinalizationRegistry<string>(heldValue => {\n\t\tconsole.warn(`[LEAKED DISPOSABLE] ${heldValue}`);\n\t});\n\n\ttrackDisposable(disposable: IDisposable): void {\n\t\tconst stack = new Error('CREATED via:').stack!;\n\t\tthis._registry.register(disposable, stack, disposable);\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tif (parent) {\n\t\t\tthis._registry.unregister(child);\n\t\t} else {\n\t\t\tthis.trackDisposable(child);\n\t\t}\n\t}\n\n\tmarkAsDisposed(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis._registry.unregister(disposable);\n\t}\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E extends any>(thing: E): thing is E & IDisposable {\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\nclass FunctionDisposable implements IDisposable {\n\tprivate _isDisposed: boolean;\n\tprivate readonly _fn: () => void;\n\n\tconstructor(fn: () => void) {\n\t\tthis._isDisposed = false;\n\t\tthis._fn = fn;\n\t\ttrackDisposable(this);\n\t}\n\n\tdispose() {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fn) {\n\t\t\tthrow new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`);\n\t\t}\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._fn();\n\t}\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\treturn new FunctionDisposable(fn);\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o || o === Disposable.None) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n\n\tpublic assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tonUnexpectedError(new BugIndicatingError('Object disposed'));\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t\tsetParentOfDisposable(value, this);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, null);\n\t\t}\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n\n/**\n * Call `then` on a Promise, unless the returned disposable is disposed.\n */\nexport function thenIfNotDisposed<T>(promise: Promise<T>, then: (result: T) => void): IDisposable {\n\tlet disposed = false;\n\tpromise.then(result => {\n\t\tif (disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthen(result);\n\t});\n\treturn toDisposable(() => {\n\t\tdisposed = true;\n\t});\n}\n\n/**\n * Call `then` on a promise that resolves to a {@link IDisposable}, then either register the\n * disposable or register it to the {@link DisposableStore}, depending on whether the store is\n * disposed or not.\n */\nexport function thenRegisterOrDispose<T extends IDisposable>(promise: Promise<T>, store: DisposableStore): Promise<T> {\n\treturn promise.then(disposable => {\n\t\tif (store.isDisposed) {\n\t\t\tdisposable.dispose();\n\t\t} else {\n\t\t\tstore.add(disposable);\n\t\t}\n\t\treturn disposable;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndeclare const globalThis: { performance: { now(): number } };\nconst performanceNow = globalThis.performance.now.bind(globalThis.performance);\n\nexport class StopWatch {\n\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tprivate readonly _now: () => number;\n\n\tpublic static create(highResolution?: boolean): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution?: boolean) {\n\t\tthis._now = highResolution === false ? Date.now : performanceNow;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndeclare const globalThis: { performance: { now(): number } };\nconst performanceNow = globalThis.performance.now.bind(globalThis.performance);\n\nexport class StopWatch {\n\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tprivate readonly _now: () => number;\n\n\tpublic static create(highResolution?: boolean): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution?: boolean) {\n\t\tthis._now = highResolution === false ? Date.now : performanceNow;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise } from './async.js';\nimport { CancellationToken } from './cancellation.js';\nimport { diffSets } from './collections.js';\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { IObservable, IObservableWithChange, IObserver } from './observable.js';\nimport { StopWatch } from './stopwatch.js';\nimport { MicrotaskDelay } from './symbols.js';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(event: Event<T>, condition: (e: T) => boolean): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: Timeout | undefined | null = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tif (handle) {\n\t\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = null;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number | typeof MicrotaskDelay = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => unknown)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>, disposables?: IDisposable[] | DisposableStore): CancelablePromise<T> {\n\t\tlet cancelRef: () => void;\n\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\tconst listener = once(event)(resolve, null, disposables);\n\t\t\t// not resolved, matching the behavior of a normal disposal\n\t\t\tcancelRef = () => listener.dispose();\n\t\t}) as CancelablePromise<T>;\n\t\tpromise.cancel = cancelRef!;\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => unknown, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservableWithChange<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<unknown>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(disposable);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(disposable);\n\t\t\t}\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack!);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\t\t\tthis._options?.onDidAddListener?.(this);\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue && n < this._deliveryQueue!.end) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: Timeout | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(getData: () => ReadonlySet<T>, onDidChangeData: Event<unknown>, handleItem: (d: T) => IDisposable): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(onDidChangeData(() => {\n\t\tconst newData = getData();\n\t\tconst diff = diffSets(oldData, newData);\n\t\tfor (const r of diff.removed) {\n\t\t\tmap.deleteAndDispose(r);\n\t\t}\n\t\tfor (const a of diff.added) {\n\t\t\tmap.set(a, handleItem(a));\n\t\t}\n\t\toldData = new Set(newData);\n\t}));\n\tstore.add(map);\n\treturn store;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancelablePromise } from './async.js';\nimport { CancellationToken } from './cancellation.js';\nimport { diffSets } from './collections.js';\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { IObservable, IObservableWithChange, IObserver } from './observable.js';\nimport { StopWatch } from './stopwatch.js';\nimport { MicrotaskDelay } from './symbols.js';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once, and only when the condition is met.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function onceIf<T>(event: Event<T>, condition: (e: T) => boolean): Event<T> {\n\t\treturn Event.once(Event.filter(event, condition));\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: Timeout | undefined | null = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tif (handle) {\n\t\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = null;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number | typeof MicrotaskDelay = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => unknown)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>, disposables?: IDisposable[] | DisposableStore): CancelablePromise<T> {\n\t\tlet cancelRef: () => void;\n\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\tconst listener = once(event)(resolve, null, disposables);\n\t\t\t// not resolved, matching the behavior of a normal disposal\n\t\t\tcancelRef = () => listener.dispose();\n\t\t}) as CancelablePromise<T>;\n\t\tpromise.cancel = cancelRef!;\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.\n\t *\n\t * This is similar to {@link Relay} but allows instantiating and forwarding\n\t * on a single line and also allows for multiple source events.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => unknown, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => unknown, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\n\t\t\t\t\t// Communicate to the observable that we received its current value and would like to be notified about future changes.\n\t\t\t\t\tthis._observable.reportChanges();\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservableWithChange<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<unknown>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(disposable);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(disposable);\n\t\t\t}\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack!);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => unknown, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\t\t\tthis._options?.onDidAddListener?.(this);\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue && n < this._deliveryQueue!.end) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: Timeout | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n\n/**\n * @param handleItem Is called for each item in the set (but only the first time the item is seen in the set).\n * \tThe returned disposable is disposed if the item is no longer in the set.\n */\nexport function trackSetChanges<T>(getData: () => ReadonlySet<T>, onDidChangeData: Event<unknown>, handleItem: (d: T) => IDisposable): IDisposable {\n\tconst map = new DisposableMap<T, IDisposable>();\n\tlet oldData = new Set(getData());\n\tfor (const d of oldData) {\n\t\tmap.set(d, handleItem(d));\n\t}\n\n\tconst store = new DisposableStore();\n\tstore.add(onDidChangeData(() => {\n\t\tconst newData = getData();\n\t\tconst diff = diffSets(oldData, newData);\n\t\tfor (const r of diff.removed) {\n\t\t\tmap.deleteAndDispose(r);\n\t\t}\n\t\tfor (const a of diff.added) {\n\t\t\tmap.set(a, handleItem(a));\n\t\t}\n\t\toldData = new Set(newData);\n\t}));\n\tstore.add(map);\n\treturn store;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * This module exists so that the AMD build of the monaco editor can replace this with an async loader plugin.\n * If you add new functions to this module make sure that they are also provided in the AMD build of the monaco editor.\n *\n * TODO@esm remove me once we no longer ship an AMD build.\n */\n\nexport function getNLSMessages(): string[] {\n\treturn globalThis._VSCODE_NLS_MESSAGES;\n}\n\nexport function getNLSLanguage(): string | undefined {\n\treturn globalThis._VSCODE_NLS_LANGUAGE;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * This module exists so that the AMD build of the monaco editor can replace this with an async loader plugin.\n * If you add new functions to this module make sure that they are also provided in the AMD build of the monaco editor.\n *\n * TODO@esm remove me once we no longer ship an AMD build.\n */\n\nexport function getNLSMessages(): string[] {\n\treturn globalThis._VSCODE_NLS_MESSAGES;\n}\n\nexport function getNLSLanguage(): string | undefined {\n\treturn globalThis._VSCODE_NLS_LANGUAGE;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// eslint-disable-next-line local/code-import-patterns\nimport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n// eslint-disable-next-line local/code-import-patterns\nexport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n\ndeclare const document: { location?: { hash?: string } } | undefined;\nconst isPseudo = getNLSLanguage() === 'pseudo' || (typeof document !== 'undefined' && document.location && typeof document.location.hash === 'string' && document.location.hash.indexOf('pseudo=true') >= 0);\n\nexport interface ILocalizeInfo {\n\tkey: string;\n\tcomment: string[];\n}\n\nexport interface ILocalizedString {\n\toriginal: string;\n\tvalue: string;\n}\n\nfunction _format(message: string, args: (string | number | boolean | undefined | null)[]): string {\n\tlet result: string;\n\n\tif (args.length === 0) {\n\t\tresult = message;\n\t} else {\n\t\tresult = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n\t\t\tconst index = rest[0];\n\t\t\tconst arg = args[index];\n\t\t\tlet result = match;\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tresult = arg;\n\t\t\t} else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n\t\t\t\tresult = String(arg);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tif (isPseudo) {\n\t\t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t\tresult = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t}\n\n\treturn result;\n}\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example For example, `localize('sayHello', 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * @skipMangle\n */\nexport function localize(data: ILocalizeInfo | string /* | number when built */, message: string /* | null when built */, ...args: (string | number | boolean | undefined | null)[]): string {\n\tif (typeof data === 'number') {\n\t\treturn _format(lookupMessage(data, message), args);\n\t}\n\treturn _format(message, args);\n}\n\n/**\n * Only used when built: Looks up the message in the global NLS table.\n * This table is being made available as a global through bootstrapping\n * depending on the target context.\n */\nfunction lookupMessage(index: number, fallback: string | null): string {\n\tconst message = getNLSMessages()?.[index];\n\tif (typeof message !== 'string') {\n\t\tif (typeof fallback === 'string') {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new Error(`!!! NLS MISSING: ${index} !!!`);\n\t}\n\treturn message;\n}\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize2({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize('sayHello', 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * @skipMangle\n */\nexport function localize2(data: ILocalizeInfo | string /* | number when built */, originalMessage: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString {\n\tlet message: string;\n\tif (typeof data === 'number') {\n\t\tmessage = lookupMessage(data, originalMessage);\n\t} else {\n\t\tmessage = originalMessage;\n\t}\n\n\tconst value = _format(message, args);\n\n\treturn {\n\t\tvalue,\n\t\toriginal: originalMessage === message ? value : _format(originalMessage, args)\n\t};\n}\n\nexport interface INLSLanguagePackConfiguration {\n\n\t/**\n\t * The path to the translations config file that contains pointers to\n\t * all message bundles for `main` and extensions.\n\t */\n\treadonly translationsConfigFile: string;\n\n\t/**\n\t * The path to the file containing the translations for this language\n\t * pack as flat string array.\n\t */\n\treadonly messagesFile: string;\n\n\t/**\n\t * The path to the file that can be used to signal a corrupt language\n\t * pack, for example when reading the `messagesFile` fails. This will\n\t * instruct the application to re-create the cache on next startup.\n\t */\n\treadonly corruptMarkerFile: string;\n}\n\nexport interface INLSConfiguration {\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n\n\t/**\n\t * The actual language of the UI that ends up being used considering `userLocale`\n\t * and `osLocale`.\n\t */\n\treadonly resolvedLanguage: string;\n\n\t/**\n\t * Defined if a language pack is used that is not the\n\t * default english language pack. This requires a language\n\t * pack to be installed as extension.\n\t */\n\treadonly languagePack?: INLSLanguagePackConfiguration;\n\n\t/**\n\t * The path to the file containing the default english messages\n\t * as flat string array. The file is only present in built\n\t * versions of the application.\n\t */\n\treadonly defaultMessagesFile: string;\n\n\t/**\n\t * Below properties are deprecated and only there to continue support\n\t * for `vscode-nls` module that depends on them.\n\t * Refs https://github.com/microsoft/vscode-nls/blob/main/src/node/main.ts#L36-L46\n\t */\n\t/** @deprecated */\n\treadonly locale: string;\n\t/** @deprecated */\n\treadonly availableLanguages: Record<string, string>;\n\t/** @deprecated */\n\treadonly _languagePackSupport?: boolean;\n\t/** @deprecated */\n\treadonly _languagePackId?: string;\n\t/** @deprecated */\n\treadonly _translationsConfigFile?: string;\n\t/** @deprecated */\n\treadonly _cacheRoot?: string;\n\t/** @deprecated */\n\treadonly _resolvedLanguagePackCoreLocation?: string;\n\t/** @deprecated */\n\treadonly _corruptedFile?: string;\n}\n\nexport interface ILanguagePack {\n\treadonly hash: string;\n\treadonly label: string | undefined;\n\treadonly extensions: {\n\t\treadonly extensionIdentifier: { readonly id: string; readonly uuid?: string };\n\t\treadonly version: string;\n\t}[];\n\treadonly translations: Record<string, string | undefined>;\n}\n\nexport type ILanguagePacks = Record<string, ILanguagePack | undefined>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// eslint-disable-next-line local/code-import-patterns\nimport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n// eslint-disable-next-line local/code-import-patterns\nexport { getNLSLanguage, getNLSMessages } from './nls.messages.js';\n\ndeclare const document: { location?: { hash?: string } } | undefined;\nconst isPseudo = getNLSLanguage() === 'pseudo' || (typeof document !== 'undefined' && document.location && typeof document.location.hash === 'string' && document.location.hash.indexOf('pseudo=true') >= 0);\n\nexport interface ILocalizeInfo {\n\tkey: string;\n\tcomment: string[];\n}\n\nexport interface ILocalizedString {\n\toriginal: string;\n\tvalue: string;\n}\n\nfunction _format(message: string, args: (string | number | boolean | undefined | null)[]): string {\n\tlet result: string;\n\n\tif (args.length === 0) {\n\t\tresult = message;\n\t} else {\n\t\tresult = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n\t\t\tconst index = rest[0];\n\t\t\tconst arg = args[index];\n\t\t\tlet result = match;\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tresult = arg;\n\t\t\t} else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n\t\t\t\tresult = String(arg);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tif (isPseudo) {\n\t\t// FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n\t\tresult = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n\t}\n\n\treturn result;\n}\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * Marks a string to be localized. Returns the localized string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example For example, `localize('sayHello', 'hello {0}', name)`\n *\n * @returns string The localized string.\n */\nexport function localize(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): string;\n\n/**\n * @skipMangle\n */\nexport function localize(data: ILocalizeInfo | string /* | number when built */, message: string /* | null when built */, ...args: (string | number | boolean | undefined | null)[]): string {\n\tif (typeof data === 'number') {\n\t\treturn _format(lookupMessage(data, message), args);\n\t}\n\treturn _format(message, args);\n}\n\n/**\n * Only used when built: Looks up the message in the global NLS table.\n * This table is being made available as a global through bootstrapping\n * depending on the target context.\n */\nfunction lookupMessage(index: number, fallback: string | null): string {\n\tconst message = getNLSMessages()?.[index];\n\tif (typeof message !== 'string') {\n\t\tif (typeof fallback === 'string') {\n\t\t\treturn fallback;\n\t\t}\n\t\tthrow new Error(`!!! NLS MISSING: ${index} !!!`);\n\t}\n\treturn message;\n}\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param info The {@linkcode ILocalizeInfo} which describes the id and comments associated with the localized string.\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize2({ key: 'sayHello', comment: ['Welcomes user'] }, 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(info: ILocalizeInfo, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * Marks a string to be localized. Returns an {@linkcode ILocalizedString}\n * which contains the localized string and the original string.\n *\n * @param key The key to use for localizing the string\n * @param message The string to localize\n * @param args The arguments to the string\n *\n * @note `message` can contain `{n}` notation where it is replaced by the nth value in `...args`\n * @example `localize('sayHello', 'hello {0}', name)`\n *\n * @returns ILocalizedString which contains the localized string and the original string.\n */\nexport function localize2(key: string, message: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString;\n\n/**\n * @skipMangle\n */\nexport function localize2(data: ILocalizeInfo | string /* | number when built */, originalMessage: string, ...args: (string | number | boolean | undefined | null)[]): ILocalizedString {\n\tlet message: string;\n\tif (typeof data === 'number') {\n\t\tmessage = lookupMessage(data, originalMessage);\n\t} else {\n\t\tmessage = originalMessage;\n\t}\n\n\tconst value = _format(message, args);\n\n\treturn {\n\t\tvalue,\n\t\toriginal: originalMessage === message ? value : _format(originalMessage, args)\n\t};\n}\n\nexport interface INLSLanguagePackConfiguration {\n\n\t/**\n\t * The path to the translations config file that contains pointers to\n\t * all message bundles for `main` and extensions.\n\t */\n\treadonly translationsConfigFile: string;\n\n\t/**\n\t * The path to the file containing the translations for this language\n\t * pack as flat string array.\n\t */\n\treadonly messagesFile: string;\n\n\t/**\n\t * The path to the file that can be used to signal a corrupt language\n\t * pack, for example when reading the `messagesFile` fails. This will\n\t * instruct the application to re-create the cache on next startup.\n\t */\n\treadonly corruptMarkerFile: string;\n}\n\nexport interface INLSConfiguration {\n\n\t/**\n\t * Locale as defined in `argv.json` or `app.getLocale()`.\n\t */\n\treadonly userLocale: string;\n\n\t/**\n\t * Locale as defined by the OS (e.g. `app.getPreferredSystemLanguages()`).\n\t */\n\treadonly osLocale: string;\n\n\t/**\n\t * The actual language of the UI that ends up being used considering `userLocale`\n\t * and `osLocale`.\n\t */\n\treadonly resolvedLanguage: string;\n\n\t/**\n\t * Defined if a language pack is used that is not the\n\t * default english language pack. This requires a language\n\t * pack to be installed as extension.\n\t */\n\treadonly languagePack?: INLSLanguagePackConfiguration;\n\n\t/**\n\t * The path to the file containing the default english messages\n\t * as flat string array. The file is only present in built\n\t * versions of the application.\n\t */\n\treadonly defaultMessagesFile: string;\n\n\t/**\n\t * Below properties are deprecated and only there to continue support\n\t * for `vscode-nls` module that depends on them.\n\t * Refs https://github.com/microsoft/vscode-nls/blob/main/src/node/main.ts#L36-L46\n\t */\n\t/** @deprecated */\n\treadonly locale: string;\n\t/** @deprecated */\n\treadonly availableLanguages: Record<string, string>;\n\t/** @deprecated */\n\treadonly _languagePackSupport?: boolean;\n\t/** @deprecated */\n\treadonly _languagePackId?: string;\n\t/** @deprecated */\n\treadonly _translationsConfigFile?: string;\n\t/** @deprecated */\n\treadonly _cacheRoot?: string;\n\t/** @deprecated */\n\treadonly _resolvedLanguagePackCoreLocation?: string;\n\t/** @deprecated */\n\treadonly _corruptedFile?: string;\n}\n\nexport interface ILanguagePack {\n\treadonly hash: string;\n\treadonly label: string | undefined;\n\treadonly extensions: {\n\t\treadonly extensionIdentifier: { readonly id: string; readonly uuid?: string };\n\t\treadonly version: string;\n\t}[];\n\treadonly translations: Record<string, string | undefined>;\n}\n\nexport type ILanguagePacks = Record<string, ILanguagePack | undefined>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../nls.js';\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _platformLocale: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\tnode?: string;\n\t\telectron?: string;\n\t\tchrome?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\n\nconst $globalThis: any = globalThis;\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = $globalThis.vscode.process;\n} else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\n\n// Native environment\nif (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'] || !!nodeProcess.env['GITHUB_WORKSPACE'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: nls.INLSConfiguration = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.userLocale;\n\t\t\t_platformLocale = nlsConfig.osLocale;\n\t\t\t_language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isMobile = _userAgent?.indexOf('Mobi') >= 0;\n\t_isWeb = true;\n\t_language = nls.getNLSLanguage() || LANGUAGE_DEFAULT;\n\t_locale = navigator.language.toLowerCase();\n\t_platformLocale = _locale;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';\n\nexport function PlatformToString(platform: Platform): PlatformName {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexport const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nexport const isIOS = _isIOS;\nexport const isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexport const platformLocale = _platformLocale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\n\t\t$globalThis.addEventListener('message', (e: any) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\t$globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\nexport function isBigSurOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 20;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../nls.js';\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _platformLocale: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\tnode?: string;\n\t\telectron?: string;\n\t\tchrome?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\n\nconst $globalThis: any = globalThis;\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = $globalThis.vscode.process;\n} else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\n\n// Native environment\nif (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'] || !!nodeProcess.env['GITHUB_WORKSPACE'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: nls.INLSConfiguration = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.userLocale;\n\t\t\t_platformLocale = nlsConfig.osLocale;\n\t\t\t_language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isMobile = _userAgent?.indexOf('Mobi') >= 0;\n\t_isWeb = true;\n\t_language = nls.getNLSLanguage() || LANGUAGE_DEFAULT;\n\t_locale = navigator.language.toLowerCase();\n\t_platformLocale = _locale;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';\n\nexport function PlatformToString(platform: Platform): PlatformName {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexport const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nexport const isIOS = _isIOS;\nexport const isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexport const platformLocale = _platformLocale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\n\t\t$globalThis.addEventListener('message', (e: any) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\t$globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\nexport function isBigSurOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 20;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable } from './lifecycle.js';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tthis._parentListener?.dispose();\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n\nexport function cancelOnDispose(store: DisposableStore): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tstore.add({ dispose() { source.cancel(); } });\n\treturn source.token;\n}\n\n/**\n * A pool that aggregates multiple cancellation tokens. The pool's own token\n * (accessible via `pool.token`) is cancelled only after every token added\n * to the pool has been cancelled. Adding tokens after the pool token has\n * been cancelled has no effect.\n */\nexport class CancellationTokenPool {\n\n\tprivate readonly _source = new CancellationTokenSource();\n\tprivate readonly _listeners = new DisposableStore();\n\n\tprivate _total: number = 0;\n\tprivate _cancelled: number = 0;\n\tprivate _isDone: boolean = false;\n\n\tget token(): CancellationToken {\n\t\treturn this._source.token;\n\t}\n\n\t/**\n\t * Add a token to the pool. If the token is already cancelled it is counted\n\t * immediately. Tokens added after the pool token has been cancelled are ignored.\n\t */\n\tadd(token: CancellationToken): void {\n\t\tif (this._isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._total++;\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t\treturn;\n\t\t}\n\n\t\tconst d = token.onCancellationRequested(() => {\n\t\t\td.dispose();\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t});\n\t\tthis._listeners.add(d);\n\t}\n\n\tprivate _check(): void {\n\t\tif (!this._isDone && this._total > 0 && this._total === this._cancelled) {\n\t\t\tthis._isDone = true;\n\t\t\tthis._listeners.dispose();\n\t\t\tthis._source.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._listeners.dispose();\n\t\tthis._source.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from './event.js';\nimport { DisposableStore, IDisposable } from './lifecycle.js';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tthis._parentListener?.dispose();\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n\nexport function cancelOnDispose(store: DisposableStore): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tstore.add({ dispose() { source.cancel(); } });\n\treturn source.token;\n}\n\n/**\n * A pool that aggregates multiple cancellation tokens. The pool's own token\n * (accessible via `pool.token`) is cancelled only after every token added\n * to the pool has been cancelled. Adding tokens after the pool token has\n * been cancelled has no effect.\n */\nexport class CancellationTokenPool {\n\n\tprivate readonly _source = new CancellationTokenSource();\n\tprivate readonly _listeners = new DisposableStore();\n\n\tprivate _total: number = 0;\n\tprivate _cancelled: number = 0;\n\tprivate _isDone: boolean = false;\n\n\tget token(): CancellationToken {\n\t\treturn this._source.token;\n\t}\n\n\t/**\n\t * Add a token to the pool. If the token is already cancelled it is counted\n\t * immediately. Tokens added after the pool token has been cancelled are ignored.\n\t */\n\tadd(token: CancellationToken): void {\n\t\tif (this._isDone) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._total++;\n\n\t\tif (token.isCancellationRequested) {\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t\treturn;\n\t\t}\n\n\t\tconst d = token.onCancellationRequested(() => {\n\t\t\td.dispose();\n\t\t\tthis._cancelled++;\n\t\t\tthis._check();\n\t\t});\n\t\tthis._listeners.add(d);\n\t}\n\n\tprivate _check(): void {\n\t\tif (!this._isDone && this._total > 0 && this._total === this._cancelled) {\n\t\t\tthis._isDone = true;\n\t\t\tthis._listeners.dispose();\n\t\t\tthis._source.cancel();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._listeners.dispose();\n\t\tthis._source.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { IDisposable } from './lifecycle.js';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\nexport function identity<T>(t: T): T {\n\treturn t;\n}\n\ninterface ICacheOptions<TArg> {\n\t/**\n\t * The cache key is used to identify the cache entry.\n\t * Strict equality is used to compare cache keys.\n\t*/\n\tgetCacheKey: (arg: TArg) => unknown;\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: unknown | undefined = undefined;\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this._fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new Map<TArg, TComputed>();\n\tprivate readonly _map2 = new Map<unknown, TComputed>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TComputed> {\n\t\treturn this._map;\n\t}\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this._map2.has(key)) {\n\t\t\treturn this._map2.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(arg, value);\n\t\tthis._map2.set(key, value);\n\t\treturn value;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { IDisposable } from './lifecycle.js';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\nexport function identity<T>(t: T): T {\n\treturn t;\n}\n\ninterface ICacheOptions<TArg> {\n\t/**\n\t * The cache key is used to identify the cache entry.\n\t * Strict equality is used to compare cache keys.\n\t*/\n\tgetCacheKey: (arg: TArg) => unknown;\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: unknown | undefined = undefined;\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this._fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TComputed> {\n\tprivate readonly _map = new Map<TArg, TComputed>();\n\tprivate readonly _map2 = new Map<unknown, TComputed>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TComputed> {\n\t\treturn this._map;\n\t}\n\n\tprivate readonly _fn: (arg: TArg) => TComputed;\n\tprivate readonly _computeKey: (arg: TArg) => unknown;\n\n\tconstructor(fn: (arg: TArg) => TComputed);\n\tconstructor(options: ICacheOptions<TArg>, fn: (arg: TArg) => TComputed);\n\tconstructor(arg1: ICacheOptions<TArg> | ((arg: TArg) => TComputed), arg2?: (arg: TArg) => TComputed) {\n\t\tif (typeof arg1 === 'function') {\n\t\t\tthis._fn = arg1;\n\t\t\tthis._computeKey = identity;\n\t\t} else {\n\t\t\tthis._fn = arg2!;\n\t\t\tthis._computeKey = arg1.getCacheKey;\n\t\t}\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = this._computeKey(arg);\n\t\tif (this._map2.has(key)) {\n\t\t\treturn this._map2.get(key)!;\n\t\t}\n\n\t\tconst value = this._fn(arg);\n\t\tthis._map.set(arg, value);\n\t\tthis._map2.set(key, value);\n\t\treturn value;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\tget hasValue(): boolean { return this._state === LazyValueState.Completed; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nenum LazyValueState {\n\tUninitialized,\n\tRunning,\n\tCompleted,\n}\n\nexport class Lazy<T> {\n\n\tprivate _state = LazyValueState.Uninitialized;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\tget hasValue(): boolean { return this._state === LazyValueState.Completed; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tget value(): T {\n\t\tif (this._state === LazyValueState.Uninitialized) {\n\t\t\tthis._state = LazyValueState.Running;\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._state = LazyValueState.Completed;\n\t\t\t}\n\t\t} else if (this._state === LazyValueState.Running) {\n\t\t\tthrow new Error('Cannot read the value of a lazy that is being initialized');\n\t\t}\n\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCachedFunction } from './cache.js';\nimport { CharCode } from './charCode.js';\nimport { Lazy } from './lazy.js';\nimport { Constants } from './uint.js';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\tif (Object.keys(values).length === 0) {\n\t\treturn template;\n\t}\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nexport function htmlAttributeEncodeValue(value: string): string {\n\treturn value.replace(/[<>\"'&]/g, ch => {\n\t\tswitch (ch) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '\"': return '&quot;';\n\t\t\tcase '\\'': return '&apos;';\n\t\t\tcase '&': return '&amp;';\n\t\t}\n\t\treturn ch;\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `substr` occurs inside `value`.\n */\nexport function count(value: string, substr: string): number {\n\tlet result = 0;\n\tlet index = value.indexOf(substr);\n\twhile (index !== -1) {\n\t\tresult++;\n\t\tindex = value.indexOf(substr, index + substr.length);\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\nexport function truncateMiddle(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\tconst prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;\n\tconst suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;\n\n\treturn `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function joinStrings(items: (string | undefined | null | false)[], separator: string): string {\n\treturn items.filter(item => item !== undefined && item !== null && item !== false).join(separator);\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\nexport function splitLinesIncludeSeparators(str: string): string[] {\n\tconst linesWithSeparators: string[] = [];\n\tconst splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n\tfor (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n\t\tlinesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));\n\t}\n\treturn linesWithSeparators;\n}\n\nexport function indexOfPattern(str: string, re: RegExp) {\n\tconst match = re.exec(str);\n\tif (match) {\n\t\treturn match.index;\n\t}\n\treturn -1;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function getIndentationLength(str: string): number {\n\tconst idx = firstNonWhitespaceIndex(str);\n\tif (idx === -1) { return str.length; }\n\treturn idx;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: any[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport class GraphemeIterator {\n\n\tprivate readonly _iterator: CodePointIterator;\n\n\tpublic get offset(): number {\n\t\treturn this._iterator.offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._iterator = new CodePointIterator(str, offset);\n\t}\n\n\tpublic nextGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\twhile (!iterator.eol()) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t\t}\n\t\treturn (iterator.offset - initialOffset);\n\t}\n\n\tpublic prevGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\twhile (iterator.offset > 0) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t\t}\n\t\treturn (initialOffset - iterator.offset);\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn this._iterator.eol();\n\t}\n}\n\nexport function nextCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.nextGraphemeLength();\n}\n\nexport function prevCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.prevGraphemeLength();\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\toffset--;\n\t}\n\tconst endOffset = offset + nextCharLength(str, offset);\n\tconst startOffset = endOffset - prevCharLength(str, endOffset);\n\treturn [startOffset, endOffset];\n}\n\nexport function charCount(str: string): number {\n\tconst iterator = new GraphemeIterator(str);\n\tlet length = 0;\n\twhile (!iterator.eol()) {\n\t\tlength++;\n\t\titerator.nextGraphemeLength();\n\t}\n\treturn length;\n}\n\nlet CONTAINS_RTL: RegExp | undefined = undefined;\n\nfunction makeContainsRtl() {\n\t// Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n\treturn /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n}\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\tif (!CONTAINS_RTL) {\n\t\tCONTAINS_RTL = makeContainsRtl();\n\t}\n\n\treturn CONTAINS_RTL.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 - 2EFF   CJK Radicals Supplement\n\t//          2F00 - 2FDF   Kangxi Radicals\n\t//          2FF0 - 2FFF   Ideographic Description Characters\n\t//          3000 - 303F   CJK Symbols and Punctuation\n\t//          3040 - 309F   Hiragana\n\t//          30A0 - 30FF   Katakana\n\t//          3100 - 312F   Bopomofo\n\t//          3130 - 318F   Hangul Compatibility Jamo\n\t//          3190 - 319F   Kanbun\n\t//          31A0 - 31BF   Bopomofo Extended\n\t//          31F0 - 31FF   Katakana Phonetic Extensions\n\t//          3200 - 32FF   Enclosed CJK Letters and Months\n\t//          3300 - 33FF   CJK Compatibility\n\t//          3400 - 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 - 4DFF   Yijing Hexagram Symbols\n\t//          4E00 - 9FFF   CJK Unified Ideographs\n\t//          A000 - A48F   Yi Syllables\n\t//          A490 - A4CF   Yi Radicals\n\t//          AC00 - D7AF   Hangul Syllables\n\t// [IGNORE] D800 - DB7F   High Surrogates\n\t// [IGNORE] DB80 - DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 - DFFF   Low Surrogates\n\t// [IGNORE] E000 - F8FF   Private Use Area\n\t//          F900 - FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 - FE0F   Variation Selectors\n\t// [IGNORE] FE20 - FE2F   Combining Half Marks\n\t// [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 - FE6F   Small Form Variants\n\t// [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n\t//          FF00 - FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 - FFFF   Specials\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n\t\t|| (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n\t\t|| (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n\t\t|| (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129782)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n * The return value can be longer than the given value of `n`. Leading whitespace is always trimmed.\n */\nexport function lcut(text: string, n: number, prefix = ''): string {\n\tconst trimmed = text.trimStart();\n\n\tif (trimmed.length < n) {\n\t\treturn trimmed;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(trimmed)) {\n\t\tif (trimmed.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\tif (i === 0) {\n\t\treturn trimmed;\n\t}\n\n\treturn prefix + trimmed.substring(i).trimStart();\n}\n\n// Defacto standard: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\nconst CSI_SEQUENCE = /(?:\\x1b\\[|\\x9b)[=?>!]?[\\d;:]*[\"$#'* ]?[a-zA-Z@^`{}|~]/;\nconst OSC_SEQUENCE = /(?:\\x1b\\]|\\x9d).*?(?:\\x1b\\\\|\\x07|\\x9c)/;\nconst ESC_SEQUENCE = /\\x1b(?:[ #%\\(\\)\\*\\+\\-\\.\\/]?[a-zA-Z0-9\\|}~@])/;\nconst CONTROL_SEQUENCES = new RegExp('(?:' + [\n\tCSI_SEQUENCE.source,\n\tOSC_SEQUENCE.source,\n\tESC_SEQUENCE.source,\n].join('|') + ')', 'g');\n\n/** Iterates over parts of a string with CSI sequences */\nexport function* forAnsiStringParts(str: string) {\n\tlet last = 0;\n\tfor (const match of str.matchAll(CONTROL_SEQUENCES)) {\n\t\tif (last !== match.index) {\n\t\t\tyield { isCode: false, str: str.substring(last, match.index) };\n\t\t}\n\n\t\tyield { isCode: true, str: match[0] };\n\t\tlast = match.index + match[0].length;\n\t}\n\n\tif (last !== str.length) {\n\t\tyield { isCode: false, str: str.substring(last) };\n\t}\n}\n\n/**\n * Strips ANSI escape sequences from a string.\n * @param str The dastringa stringo strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodes('\\u001b[31mHello, World!\\u001b[0m');\n * // 'Hello, World!'\n */\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(CONTROL_SEQUENCES, '');\n\t}\n\n\treturn str;\n}\n\nconst PROMPT_NON_PRINTABLE = /\\\\\\[.*?\\\\\\]/g;\n\n/**\n * Strips ANSI escape sequences from a UNIX-style prompt string (eg. `$PS1`).\n * @param str The string to strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodesFromPrompt('\\n\\\\[\\u001b[01;34m\\\\]\\\\w\\\\[\\u001b[00m\\\\]\\n\\\\[\\u001b[1;32m\\\\]> \\\\[\\u001b[0m\\\\]');\n * // '\\n\\\\w\\n> '\n */\nexport function removeAnsiEscapeCodesFromPrompt(str: string): string {\n\treturn removeAnsiEscapeCodes(str).replace(PROMPT_NON_PRINTABLE, '');\n}\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\tif (idx === -1) {\n\t\treturn str;\n\t}\n\n\tif (str[idx - 1] === '\\r') {\n\t\tidx--;\n\t}\n\n\treturn str.substr(0, idx);\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nfunction breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR × LF\n\t// GB4                       (Control | CR | LF) ÷\n\t// GB5                                           ÷ (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L × (L | V | LV | LVT)\n\t// GB7                                  (LV | V) × (V | T)\n\t// GB8                                 (LVT | T) × T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                           × (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                          × SpacingMark\n\t// GB9b                                  Prepend ×\n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI × RI\n\t// GB13                        [^RI] (RI RI)* RI × RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any ÷ Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n\treturn JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n\n//#endregion\n\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset: number, str: string): number {\n\tif (offset === 0) {\n\t\treturn 0;\n\t}\n\n\t// Try to delete emoji part.\n\tconst emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n\tif (emojiOffset !== undefined) {\n\t\treturn emojiOffset;\n\t}\n\n\t// Otherwise, just skip a single code point.\n\tconst iterator = new CodePointIterator(str, offset);\n\titerator.prevCodePoint();\n\treturn iterator.offset;\n}\n\nfunction getOffsetBeforeLastEmojiComponent(initialOffset: number, str: string): number | undefined {\n\t// See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n\t// structure of emojis.\n\tconst iterator = new CodePointIterator(str, initialOffset);\n\tlet codePoint = iterator.prevCodePoint();\n\n\t// Skip modifiers\n\twhile ((isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap)) {\n\t\tif (iterator.offset === 0) {\n\t\t\t// Cannot skip modifier, no preceding emoji base.\n\t\t\treturn undefined;\n\t\t}\n\t\tcodePoint = iterator.prevCodePoint();\n\t}\n\n\t// Expect base emoji\n\tif (!isEmojiImprecise(codePoint)) {\n\t\t// Unexpected code point, not a valid emoji.\n\t\treturn undefined;\n\t}\n\n\tlet resultOffset = iterator.offset;\n\n\tif (resultOffset > 0) {\n\t\t// Skip optional ZWJ code points that combine multiple emojis.\n\t\t// In theory, we should check if that ZWJ actually combines multiple emojis\n\t\t// to prevent deleting ZWJs in situations we didn't account for.\n\t\tconst optionalZwjCodePoint = iterator.prevCodePoint();\n\t\tif (optionalZwjCodePoint === CodePoint.zwj) {\n\t\t\tresultOffset = iterator.offset;\n\t\t}\n\t}\n\n\treturn resultOffset;\n}\n\nfunction isEmojiModifier(codePoint: number): boolean {\n\treturn 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\n\nconst enum CodePoint {\n\tzwj = 0x200D,\n\n\t/**\n\t * Variation Selector-16 (VS16)\n\t*/\n\temojiVariantSelector = 0xFE0F,\n\n\t/**\n\t * Combining Enclosing Keycap\n\t */\n\tenclosingKeyCap = 0x20E3,\n\n\tspace = 0x0020,\n}\n\nexport const noBreakWhitespace = '\\xa0';\n\nexport class AmbiguousCharacters {\n\tprivate static readonly ambiguousCharacterData = new Lazy<\n\t\tRecord<\n\t\t\tstring | '_common' | '_default',\n\t\t\t/* code point -> ascii code point */ number[]\n\t\t>\n\t>(() => {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\t// Stored as key1, value1, key2, value2, ...\n\t\treturn JSON.parse(\n\t\t\t'{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"cs\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"fr\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ja\\\":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],\\\"ko\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ru\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"zh-hans\\\":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],\\\"zh-hant\\\":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}'\n\t\t);\n\t});\n\n\tprivate static readonly cache = new LRUCachedFunction<\n\t\tstring[],\n\t\tAmbiguousCharacters\n\t>({ getCacheKey: JSON.stringify }, (locales) => {\n\t\tfunction arrayToMap(arr: number[]): Map<number, number> {\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (let i = 0; i < arr.length; i += 2) {\n\t\t\t\tresult.set(arr[i], arr[i + 1]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction mergeMaps(\n\t\t\tmap1: Map<number, number>,\n\t\t\tmap2: Map<number, number>\n\t\t): Map<number, number> {\n\t\t\tconst result = new Map<number, number>(map1);\n\t\t\tfor (const [key, value] of map2) {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction intersectMaps(\n\t\t\tmap1: Map<number, number> | undefined,\n\t\t\tmap2: Map<number, number>\n\t\t) {\n\t\t\tif (!map1) {\n\t\t\t\treturn map2;\n\t\t\t}\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (const [key, value] of map1) {\n\t\t\t\tif (map2.has(key)) {\n\t\t\t\t\tresult.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst data = this.ambiguousCharacterData.value;\n\n\t\tlet filteredLocales = locales.filter(\n\t\t\t(l) => !l.startsWith('_') && l in data\n\t\t);\n\t\tif (filteredLocales.length === 0) {\n\t\t\tfilteredLocales = ['_default'];\n\t\t}\n\n\t\tlet languageSpecificMap: Map<number, number> | undefined = undefined;\n\t\tfor (const locale of filteredLocales) {\n\t\t\tconst map = arrayToMap(data[locale]);\n\t\t\tlanguageSpecificMap = intersectMaps(languageSpecificMap, map);\n\t\t}\n\n\t\tconst commonMap = arrayToMap(data['_common']);\n\t\tconst map = mergeMaps(commonMap, languageSpecificMap!);\n\n\t\treturn new AmbiguousCharacters(map);\n\t});\n\n\tpublic static getInstance(locales: Set<string>): AmbiguousCharacters {\n\t\treturn AmbiguousCharacters.cache.get(Array.from(locales));\n\t}\n\n\tprivate static _locales = new Lazy<string[]>(() =>\n\t\tObject.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter(\n\t\t\t(k) => !k.startsWith('_')\n\t\t)\n\t);\n\tpublic static getLocales(): string[] {\n\t\treturn AmbiguousCharacters._locales.value;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly confusableDictionary: Map<number, number>\n\t) { }\n\n\tpublic isAmbiguous(codePoint: number): boolean {\n\t\treturn this.confusableDictionary.has(codePoint);\n\t}\n\n\tpublic containsAmbiguousCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && this.isAmbiguous(codePoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the non basic ASCII code point that the given code point can be confused,\n\t * or undefined if such code point does note exist.\n\t */\n\tpublic getPrimaryConfusable(codePoint: number): number | undefined {\n\t\treturn this.confusableDictionary.get(codePoint);\n\t}\n\n\tpublic getConfusableCodePoints(): ReadonlySet<number> {\n\t\treturn new Set(this.confusableDictionary.keys());\n\t}\n}\n\nexport class InvisibleCharacters {\n\tprivate static getRawData(): Record<string | '_common', number[]> {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\treturn JSON.parse('{\\\"_common\\\":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],\\\"cs\\\":[173,8203,12288],\\\"de\\\":[173,8203,12288],\\\"es\\\":[8203,12288],\\\"fr\\\":[173,8203,12288],\\\"it\\\":[160,173,12288],\\\"ja\\\":[173],\\\"ko\\\":[173,12288],\\\"pl\\\":[173,8203,12288],\\\"pt-BR\\\":[173,8203,12288],\\\"qps-ploc\\\":[160,173,8203,12288],\\\"ru\\\":[173,12288],\\\"tr\\\":[160,173,8203,12288],\\\"zh-hans\\\":[160,173,8203,12288],\\\"zh-hant\\\":[173,12288]}');\n\t}\n\n\tprivate static _data: Set<number> | undefined = undefined;\n\n\tprivate static getData() {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Set([...Object.values(InvisibleCharacters.getRawData())].flat());\n\t\t}\n\t\treturn this._data;\n\t}\n\n\tpublic static isInvisibleCharacter(codePoint: number): boolean {\n\t\treturn InvisibleCharacters.getData().has(codePoint);\n\t}\n\n\tpublic static containsInvisibleCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && (InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === CodePoint.space)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static get codePoints(): ReadonlySet<number> {\n\t\treturn InvisibleCharacters.getData();\n\t}\n}\n\nexport const Ellipsis = '\\u2026';\n\n/**\n * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte\n *\n * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa\n */\nfunction toBinary(str: string): string {\n\tconst codeUnits = new Uint16Array(str.length);\n\tfor (let i = 0; i < codeUnits.length; i++) {\n\t\tcodeUnits[i] = str.charCodeAt(i);\n\t}\n\tlet binary = '';\n\tconst uint8array = new Uint8Array(codeUnits.buffer);\n\tfor (let i = 0; i < uint8array.length; i++) {\n\t\tbinary += String.fromCharCode(uint8array[i]);\n\t}\n\treturn binary;\n}\n\n/**\n * Version of the global `btoa` function that handles multi-byte characters instead\n * of throwing an exception.\n */\n\nexport function multibyteAwareBtoa(str: string): string {\n\treturn btoa(toBinary(str));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCachedFunction } from './cache.js';\nimport { CharCode } from './charCode.js';\nimport { Lazy } from './lazy.js';\nimport { Constants } from './uint.js';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\tif (Object.keys(values).length === 0) {\n\t\treturn template;\n\t}\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nexport function htmlAttributeEncodeValue(value: string): string {\n\treturn value.replace(/[<>\"'&]/g, ch => {\n\t\tswitch (ch) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '\"': return '&quot;';\n\t\t\tcase '\\'': return '&apos;';\n\t\t\tcase '&': return '&amp;';\n\t\t}\n\t\treturn ch;\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `substr` occurs inside `value`.\n */\nexport function count(value: string, substr: string): number {\n\tlet result = 0;\n\tlet index = value.indexOf(substr);\n\twhile (index !== -1) {\n\t\tresult++;\n\t\tindex = value.indexOf(substr, index + substr.length);\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\nexport function truncateMiddle(value: string, maxLength: number, suffix = Ellipsis): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\tconst prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;\n\tconst suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;\n\n\treturn `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function joinStrings(items: (string | undefined | null | false)[], separator: string): string {\n\treturn items.filter(item => item !== undefined && item !== null && item !== false).join(separator);\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\nexport function splitLinesIncludeSeparators(str: string): string[] {\n\tconst linesWithSeparators: string[] = [];\n\tconst splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n\tfor (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n\t\tlinesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));\n\t}\n\treturn linesWithSeparators;\n}\n\nexport function indexOfPattern(str: string, re: RegExp) {\n\tconst match = re.exec(str);\n\tif (match) {\n\t\treturn match.index;\n\t}\n\treturn -1;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function getIndentationLength(str: string): number {\n\tconst idx = firstNonWhitespaceIndex(str);\n\tif (idx === -1) { return str.length; }\n\treturn idx;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: any[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport class GraphemeIterator {\n\n\tprivate readonly _iterator: CodePointIterator;\n\n\tpublic get offset(): number {\n\t\treturn this._iterator.offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._iterator = new CodePointIterator(str, offset);\n\t}\n\n\tpublic nextGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\twhile (!iterator.eol()) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t\t}\n\t\treturn (iterator.offset - initialOffset);\n\t}\n\n\tpublic prevGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\twhile (iterator.offset > 0) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t\t}\n\t\treturn (initialOffset - iterator.offset);\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn this._iterator.eol();\n\t}\n}\n\nexport function nextCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.nextGraphemeLength();\n}\n\nexport function prevCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.prevGraphemeLength();\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\toffset--;\n\t}\n\tconst endOffset = offset + nextCharLength(str, offset);\n\tconst startOffset = endOffset - prevCharLength(str, endOffset);\n\treturn [startOffset, endOffset];\n}\n\nexport function charCount(str: string): number {\n\tconst iterator = new GraphemeIterator(str);\n\tlet length = 0;\n\twhile (!iterator.eol()) {\n\t\tlength++;\n\t\titerator.nextGraphemeLength();\n\t}\n\treturn length;\n}\n\nlet CONTAINS_RTL: RegExp | undefined = undefined;\n\nfunction makeContainsRtl() {\n\t// Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n\treturn /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n}\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\tif (!CONTAINS_RTL) {\n\t\tCONTAINS_RTL = makeContainsRtl();\n\t}\n\n\treturn CONTAINS_RTL.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 - 2EFF   CJK Radicals Supplement\n\t//          2F00 - 2FDF   Kangxi Radicals\n\t//          2FF0 - 2FFF   Ideographic Description Characters\n\t//          3000 - 303F   CJK Symbols and Punctuation\n\t//          3040 - 309F   Hiragana\n\t//          30A0 - 30FF   Katakana\n\t//          3100 - 312F   Bopomofo\n\t//          3130 - 318F   Hangul Compatibility Jamo\n\t//          3190 - 319F   Kanbun\n\t//          31A0 - 31BF   Bopomofo Extended\n\t//          31F0 - 31FF   Katakana Phonetic Extensions\n\t//          3200 - 32FF   Enclosed CJK Letters and Months\n\t//          3300 - 33FF   CJK Compatibility\n\t//          3400 - 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 - 4DFF   Yijing Hexagram Symbols\n\t//          4E00 - 9FFF   CJK Unified Ideographs\n\t//          A000 - A48F   Yi Syllables\n\t//          A490 - A4CF   Yi Radicals\n\t//          AC00 - D7AF   Hangul Syllables\n\t// [IGNORE] D800 - DB7F   High Surrogates\n\t// [IGNORE] DB80 - DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 - DFFF   Low Surrogates\n\t// [IGNORE] E000 - F8FF   Private Use Area\n\t//          F900 - FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 - FE0F   Variation Selectors\n\t// [IGNORE] FE20 - FE2F   Combining Half Marks\n\t// [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 - FE6F   Small Form Variants\n\t// [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n\t//          FF00 - FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 - FFFF   Specials\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n\t\t|| (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n\t\t|| (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n\t\t|| (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129782)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n * The return value can be longer than the given value of `n`. Leading whitespace is always trimmed.\n */\nexport function lcut(text: string, n: number, prefix = ''): string {\n\tconst trimmed = text.trimStart();\n\n\tif (trimmed.length < n) {\n\t\treturn trimmed;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(trimmed)) {\n\t\tif (trimmed.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\tif (i === 0) {\n\t\treturn trimmed;\n\t}\n\n\treturn prefix + trimmed.substring(i).trimStart();\n}\n\n// Defacto standard: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html\nconst CSI_SEQUENCE = /(?:\\x1b\\[|\\x9b)[=?>!]?[\\d;:]*[\"$#'* ]?[a-zA-Z@^`{}|~]/;\nconst OSC_SEQUENCE = /(?:\\x1b\\]|\\x9d).*?(?:\\x1b\\\\|\\x07|\\x9c)/;\nconst ESC_SEQUENCE = /\\x1b(?:[ #%\\(\\)\\*\\+\\-\\.\\/]?[a-zA-Z0-9\\|}~@])/;\nconst CONTROL_SEQUENCES = new RegExp('(?:' + [\n\tCSI_SEQUENCE.source,\n\tOSC_SEQUENCE.source,\n\tESC_SEQUENCE.source,\n].join('|') + ')', 'g');\n\n/** Iterates over parts of a string with CSI sequences */\nexport function* forAnsiStringParts(str: string) {\n\tlet last = 0;\n\tfor (const match of str.matchAll(CONTROL_SEQUENCES)) {\n\t\tif (last !== match.index) {\n\t\t\tyield { isCode: false, str: str.substring(last, match.index) };\n\t\t}\n\n\t\tyield { isCode: true, str: match[0] };\n\t\tlast = match.index + match[0].length;\n\t}\n\n\tif (last !== str.length) {\n\t\tyield { isCode: false, str: str.substring(last) };\n\t}\n}\n\n/**\n * Strips ANSI escape sequences from a string.\n * @param str The dastringa stringo strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodes('\\u001b[31mHello, World!\\u001b[0m');\n * // 'Hello, World!'\n */\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(CONTROL_SEQUENCES, '');\n\t}\n\n\treturn str;\n}\n\nconst PROMPT_NON_PRINTABLE = /\\\\\\[.*?\\\\\\]/g;\n\n/**\n * Strips ANSI escape sequences from a UNIX-style prompt string (eg. `$PS1`).\n * @param str The string to strip the ANSI escape sequences from.\n *\n * @example\n * removeAnsiEscapeCodesFromPrompt('\\n\\\\[\\u001b[01;34m\\\\]\\\\w\\\\[\\u001b[00m\\\\]\\n\\\\[\\u001b[1;32m\\\\]> \\\\[\\u001b[0m\\\\]');\n * // '\\n\\\\w\\n> '\n */\nexport function removeAnsiEscapeCodesFromPrompt(str: string): string {\n\treturn removeAnsiEscapeCodes(str).replace(PROMPT_NON_PRINTABLE, '');\n}\n\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\tif (idx === -1) {\n\t\treturn str;\n\t}\n\n\tif (str[idx - 1] === '\\r') {\n\t\tidx--;\n\t}\n\n\treturn str.substr(0, idx);\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nfunction breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR × LF\n\t// GB4                       (Control | CR | LF) ÷\n\t// GB5                                           ÷ (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L × (L | V | LV | LVT)\n\t// GB7                                  (LV | V) × (V | T)\n\t// GB8                                 (LVT | T) × T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                           × (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                          × SpacingMark\n\t// GB9b                                  Prepend ×\n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI × RI\n\t// GB13                        [^RI] (RI RI)* RI × RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any ÷ Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n\treturn JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n\n//#endregion\n\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset: number, str: string): number {\n\tif (offset === 0) {\n\t\treturn 0;\n\t}\n\n\t// Try to delete emoji part.\n\tconst emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n\tif (emojiOffset !== undefined) {\n\t\treturn emojiOffset;\n\t}\n\n\t// Otherwise, just skip a single code point.\n\tconst iterator = new CodePointIterator(str, offset);\n\titerator.prevCodePoint();\n\treturn iterator.offset;\n}\n\nfunction getOffsetBeforeLastEmojiComponent(initialOffset: number, str: string): number | undefined {\n\t// See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n\t// structure of emojis.\n\tconst iterator = new CodePointIterator(str, initialOffset);\n\tlet codePoint = iterator.prevCodePoint();\n\n\t// Skip modifiers\n\twhile ((isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap)) {\n\t\tif (iterator.offset === 0) {\n\t\t\t// Cannot skip modifier, no preceding emoji base.\n\t\t\treturn undefined;\n\t\t}\n\t\tcodePoint = iterator.prevCodePoint();\n\t}\n\n\t// Expect base emoji\n\tif (!isEmojiImprecise(codePoint)) {\n\t\t// Unexpected code point, not a valid emoji.\n\t\treturn undefined;\n\t}\n\n\tlet resultOffset = iterator.offset;\n\n\tif (resultOffset > 0) {\n\t\t// Skip optional ZWJ code points that combine multiple emojis.\n\t\t// In theory, we should check if that ZWJ actually combines multiple emojis\n\t\t// to prevent deleting ZWJs in situations we didn't account for.\n\t\tconst optionalZwjCodePoint = iterator.prevCodePoint();\n\t\tif (optionalZwjCodePoint === CodePoint.zwj) {\n\t\t\tresultOffset = iterator.offset;\n\t\t}\n\t}\n\n\treturn resultOffset;\n}\n\nfunction isEmojiModifier(codePoint: number): boolean {\n\treturn 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\n\nconst enum CodePoint {\n\tzwj = 0x200D,\n\n\t/**\n\t * Variation Selector-16 (VS16)\n\t*/\n\temojiVariantSelector = 0xFE0F,\n\n\t/**\n\t * Combining Enclosing Keycap\n\t */\n\tenclosingKeyCap = 0x20E3,\n\n\tspace = 0x0020,\n}\n\nexport const noBreakWhitespace = '\\xa0';\n\nexport class AmbiguousCharacters {\n\tprivate static readonly ambiguousCharacterData = new Lazy<\n\t\tRecord<\n\t\t\tstring | '_common' | '_default',\n\t\t\t/* code point -> ascii code point */ number[]\n\t\t>\n\t>(() => {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\t// Stored as key1, value1, key2, value2, ...\n\t\treturn JSON.parse(\n\t\t\t'{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"cs\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"fr\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ja\\\":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],\\\"ko\\\":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"ru\\\":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],\\\"zh-hans\\\":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],\\\"zh-hant\\\":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}'\n\t\t);\n\t});\n\n\tprivate static readonly cache = new LRUCachedFunction<\n\t\tstring[],\n\t\tAmbiguousCharacters\n\t>({ getCacheKey: JSON.stringify }, (locales) => {\n\t\tfunction arrayToMap(arr: number[]): Map<number, number> {\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (let i = 0; i < arr.length; i += 2) {\n\t\t\t\tresult.set(arr[i], arr[i + 1]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction mergeMaps(\n\t\t\tmap1: Map<number, number>,\n\t\t\tmap2: Map<number, number>\n\t\t): Map<number, number> {\n\t\t\tconst result = new Map<number, number>(map1);\n\t\t\tfor (const [key, value] of map2) {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction intersectMaps(\n\t\t\tmap1: Map<number, number> | undefined,\n\t\t\tmap2: Map<number, number>\n\t\t) {\n\t\t\tif (!map1) {\n\t\t\t\treturn map2;\n\t\t\t}\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (const [key, value] of map1) {\n\t\t\t\tif (map2.has(key)) {\n\t\t\t\t\tresult.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst data = this.ambiguousCharacterData.value;\n\n\t\tlet filteredLocales = locales.filter(\n\t\t\t(l) => !l.startsWith('_') && l in data\n\t\t);\n\t\tif (filteredLocales.length === 0) {\n\t\t\tfilteredLocales = ['_default'];\n\t\t}\n\n\t\tlet languageSpecificMap: Map<number, number> | undefined = undefined;\n\t\tfor (const locale of filteredLocales) {\n\t\t\tconst map = arrayToMap(data[locale]);\n\t\t\tlanguageSpecificMap = intersectMaps(languageSpecificMap, map);\n\t\t}\n\n\t\tconst commonMap = arrayToMap(data['_common']);\n\t\tconst map = mergeMaps(commonMap, languageSpecificMap!);\n\n\t\treturn new AmbiguousCharacters(map);\n\t});\n\n\tpublic static getInstance(locales: Set<string>): AmbiguousCharacters {\n\t\treturn AmbiguousCharacters.cache.get(Array.from(locales));\n\t}\n\n\tprivate static _locales = new Lazy<string[]>(() =>\n\t\tObject.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter(\n\t\t\t(k) => !k.startsWith('_')\n\t\t)\n\t);\n\tpublic static getLocales(): string[] {\n\t\treturn AmbiguousCharacters._locales.value;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly confusableDictionary: Map<number, number>\n\t) { }\n\n\tpublic isAmbiguous(codePoint: number): boolean {\n\t\treturn this.confusableDictionary.has(codePoint);\n\t}\n\n\tpublic containsAmbiguousCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && this.isAmbiguous(codePoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the non basic ASCII code point that the given code point can be confused,\n\t * or undefined if such code point does note exist.\n\t */\n\tpublic getPrimaryConfusable(codePoint: number): number | undefined {\n\t\treturn this.confusableDictionary.get(codePoint);\n\t}\n\n\tpublic getConfusableCodePoints(): ReadonlySet<number> {\n\t\treturn new Set(this.confusableDictionary.keys());\n\t}\n}\n\nexport class InvisibleCharacters {\n\tprivate static getRawData(): Record<string | '_common', number[]> {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\treturn JSON.parse('{\\\"_common\\\":[11,12,13,127,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999],\\\"cs\\\":[173,8203,12288],\\\"de\\\":[173,8203,12288],\\\"es\\\":[8203,12288],\\\"fr\\\":[173,8203,12288],\\\"it\\\":[160,173,12288],\\\"ja\\\":[173],\\\"ko\\\":[173,12288],\\\"pl\\\":[173,8203,12288],\\\"pt-BR\\\":[173,8203,12288],\\\"qps-ploc\\\":[160,173,8203,12288],\\\"ru\\\":[173,12288],\\\"tr\\\":[160,173,8203,12288],\\\"zh-hans\\\":[160,173,8203,12288],\\\"zh-hant\\\":[173,12288]}');\n\t}\n\n\tprivate static _data: Set<number> | undefined = undefined;\n\n\tprivate static getData() {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Set([...Object.values(InvisibleCharacters.getRawData())].flat());\n\t\t}\n\t\treturn this._data;\n\t}\n\n\tpublic static isInvisibleCharacter(codePoint: number): boolean {\n\t\treturn InvisibleCharacters.getData().has(codePoint);\n\t}\n\n\tpublic static containsInvisibleCharacter(str: string): boolean {\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tconst codePoint = str.codePointAt(i);\n\t\t\tif (typeof codePoint === 'number' && (InvisibleCharacters.isInvisibleCharacter(codePoint) || codePoint === CodePoint.space)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static get codePoints(): ReadonlySet<number> {\n\t\treturn InvisibleCharacters.getData();\n\t}\n}\n\nexport const Ellipsis = '\\u2026';\n\n/**\n * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte\n *\n * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa\n */\nfunction toBinary(str: string): string {\n\tconst codeUnits = new Uint16Array(str.length);\n\tfor (let i = 0; i < codeUnits.length; i++) {\n\t\tcodeUnits[i] = str.charCodeAt(i);\n\t}\n\tlet binary = '';\n\tconst uint8array = new Uint8Array(codeUnits.buffer);\n\tfor (let i = 0; i < uint8array.length; i++) {\n\t\tbinary += String.fromCharCode(uint8array[i]);\n\t}\n\treturn binary;\n}\n\n/**\n * Version of the global `btoa` function that handles multi-byte characters instead\n * of throwing an exception.\n */\n\nexport function multibyteAwareBtoa(str: string): string {\n\treturn btoa(toBinary(str));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../charCode.js';\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\nimport { Emitter, Event } from '../event.js';\nimport { Disposable, IDisposable } from '../lifecycle.js';\nimport { isWeb } from '../platform.js';\nimport * as strings from '../strings.js';\n\nconst DEFAULT_CHANNEL = 'default';\nconst INITIALIZE = '$initialize';\n\nexport interface IWebWorker extends IDisposable {\n\tgetId(): number;\n\tonMessage: Event<Message>;\n\tonError: Event<any>;\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\n}\n\nlet webWorkerWarningLogged = false;\nexport function logOnceWebWorkerWarning(err: any): void {\n\tif (!isWeb) {\n\t\t// running tests\n\t\treturn;\n\t}\n\tif (!webWorkerWarningLogged) {\n\t\twebWorkerWarningLogged = true;\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n\t}\n\tconsole.warn(err.message);\n}\n\nconst enum MessageType {\n\tRequest,\n\tReply,\n\tSubscribeEvent,\n\tEvent,\n\tUnsubscribeEvent\n}\nclass RequestMessage {\n\tpublic readonly type = MessageType.Request;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly method: string,\n\t\tpublic readonly args: any[]\n\t) { }\n}\nclass ReplyMessage {\n\tpublic readonly type = MessageType.Reply;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly seq: string,\n\t\tpublic readonly res: any,\n\t\tpublic readonly err: any\n\t) { }\n}\nclass SubscribeEventMessage {\n\tpublic readonly type = MessageType.SubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly eventName: string,\n\t\tpublic readonly arg: any\n\t) { }\n}\nclass EventMessage {\n\tpublic readonly type = MessageType.Event;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly event: any\n\t) { }\n}\nclass UnsubscribeEventMessage {\n\tpublic readonly type = MessageType.UnsubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string\n\t) { }\n}\nexport type Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\n\ninterface IMessageReply {\n\tresolve: (value?: any) => void;\n\treject: (error?: any) => void;\n}\n\ninterface IMessageHandler {\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\n}\n\nclass WebWorkerProtocol {\n\n\tprivate _workerId: number;\n\tprivate _lastSentReq: number;\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\n\tprivate _pendingEvents: Map<string, IDisposable>;\n\tprivate _handler: IMessageHandler;\n\n\tconstructor(handler: IMessageHandler) {\n\t\tthis._workerId = -1;\n\t\tthis._handler = handler;\n\t\tthis._lastSentReq = 0;\n\t\tthis._pendingReplies = Object.create(null);\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\n\t}\n\n\tpublic setWorkerId(workerId: number): void {\n\t\tthis._workerId = workerId;\n\t}\n\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tconst req = String(++this._lastSentReq);\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\tthis._pendingReplies[req] = {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject\n\t\t\t};\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\n\t\t});\n\t}\n\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\n\t\tlet req: string | null = null;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\treq = String(++this._lastSentReq);\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._pendingEmitters.delete(req!);\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\n\t\t\t\treq = null;\n\t\t\t}\n\t\t});\n\t\treturn emitter.event;\n\t}\n\n\tpublic handleMessage(message: Message): void {\n\t\tif (!message || !message.vsWorker) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n\t\t\treturn;\n\t\t}\n\t\tthis._handleMessage(message);\n\t}\n\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\n\t\tconst handler = {\n\t\t\tget: (target: any, name: PropertyKey) => {\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target[name];\n\t\t\t}\n\t\t};\n\t\treturn new Proxy(Object.create(null), handler);\n\t}\n\n\tprivate _handleMessage(msg: Message): void {\n\t\tswitch (msg.type) {\n\t\t\tcase MessageType.Reply:\n\t\t\t\treturn this._handleReplyMessage(msg);\n\t\t\tcase MessageType.Request:\n\t\t\t\treturn this._handleRequestMessage(msg);\n\t\t\tcase MessageType.SubscribeEvent:\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\n\t\t\tcase MessageType.Event:\n\t\t\t\treturn this._handleEventMessage(msg);\n\t\t\tcase MessageType.UnsubscribeEvent:\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\n\t\t}\n\t}\n\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\n\t\t\tconsole.warn('Got reply to unknown seq');\n\t\t\treturn;\n\t\t}\n\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\n\t\tdelete this._pendingReplies[replyMessage.seq];\n\n\t\tif (replyMessage.err) {\n\t\t\tlet err = replyMessage.err;\n\t\t\tif (replyMessage.err.$isError) {\n\t\t\t\terr = new Error();\n\t\t\t\terr.name = replyMessage.err.name;\n\t\t\t\terr.message = replyMessage.err.message;\n\t\t\t\terr.stack = replyMessage.err.stack;\n\t\t\t}\n\t\t\treply.reject(err);\n\t\t\treturn;\n\t\t}\n\n\t\treply.resolve(replyMessage.res);\n\t}\n\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\n\t\tconst req = requestMessage.req;\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\n\t\tresult.then((r) => {\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\n\t\t}, (e) => {\n\t\t\tif (e.detail instanceof Error) {\n\t\t\t\t// Loading errors have a detail property that points to the actual error\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\n\t\t\t}\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\n\t\t});\n\t}\n\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\n\t\tconst req = msg.req;\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\n\t\t});\n\t\tthis._pendingEvents.set(req, disposable);\n\t}\n\n\tprivate _handleEventMessage(msg: EventMessage): void {\n\t\tif (!this._pendingEmitters.has(msg.req)) {\n\t\t\tconsole.warn('Got event for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\n\t}\n\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\n\t\tif (!this._pendingEvents.has(msg.req)) {\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\n\t\tthis._pendingEvents.delete(msg.req);\n\t}\n\n\tprivate _send(msg: Message): void {\n\t\tconst transfer: ArrayBuffer[] = [];\n\t\tif (msg.type === MessageType.Request) {\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\n\t\t\t\t\ttransfer.push(msg.args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === MessageType.Reply) {\n\t\t\tif (msg.res instanceof ArrayBuffer) {\n\t\t\t\ttransfer.push(msg.res);\n\t\t\t}\n\t\t}\n\t\tthis._handler.sendMessage(msg, transfer);\n\t}\n}\n\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\n\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\n\t? (\n\t\tK extends ProxiedMethodName\n\t\t? (...args: A) => Promise<Awaited<R>>\n\t\t: never\n\t)\n\t: never\n};\n\nexport interface IWebWorkerClient<TProxy> {\n\tproxy: Proxied<TProxy>;\n\tdispose(): void;\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\nexport interface IWebWorkerServer {\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\n/**\n * Main thread side\n */\nexport class WebWorkerClient<W extends object> extends Disposable implements IWebWorkerClient<W> {\n\n\tprivate readonly _worker: IWebWorker;\n\tprivate readonly _onModuleLoaded: Promise<void>;\n\tprivate readonly _protocol: WebWorkerProtocol;\n\tpublic readonly proxy: Proxied<W>;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(\n\t\tworker: IWebWorker\n\t) {\n\t\tsuper();\n\n\t\tthis._worker = this._register(worker);\n\t\tthis._register(this._worker.onMessage((msg) => {\n\t\t\tthis._protocol.handleMessage(msg);\n\t\t}));\n\t\tthis._register(this._worker.onError((err) => {\n\t\t\tlogOnceWebWorkerWarning(err);\n\t\t\tonUnexpectedError(err);\n\t\t}));\n\n\t\tthis._protocol = new WebWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tthis._worker.postMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\n\t\t\t\treturn this._handleMessage(channel, method, args);\n\t\t\t},\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\n\t\t\t}\n\t\t});\n\t\tthis._protocol.setWorkerId(this._worker.getId());\n\n\t\t// Send initialize message\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\n\t\t\tthis._worker.getId(),\n\t\t]);\n\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\n\t\tthis._onModuleLoaded.catch((e) => {\n\t\t\tthis._onError('Worker failed to load ', e);\n\t\t});\n\t}\n\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\n\t\t}\n\t\tif (typeof (channel as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel, async () => { await this._onModuleLoaded; });\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate _onError(message: string, error?: any): void {\n\t\tconsole.error(message);\n\t\tconsole.info(error);\n\t}\n}\n\nfunction propertyIsEvent(name: string): boolean {\n\t// Assume a property is an event if it has a form of \"onSomething\"\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n}\n\nfunction propertyIsDynamicEvent(name: string): boolean {\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n}\n\nexport interface IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: any;\n\t[prop: string]: any;\n}\n\nexport interface IWebWorkerServerRequestHandlerFactory<T extends IWebWorkerServerRequestHandler> {\n\t(workerServer: IWebWorkerServer): T;\n}\n\n/**\n * Worker side\n */\nexport class WebWorkerServer<T extends IWebWorkerServerRequestHandler> implements IWebWorkerServer {\n\n\tpublic readonly requestHandler: T;\n\tprivate _protocol: WebWorkerProtocol;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IWebWorkerServerRequestHandlerFactory<T>) {\n\t\tthis._protocol = new WebWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tpostMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\n\t\t});\n\t\tthis.requestHandler = requestHandlerFactory(this);\n\t}\n\n\tpublic onmessage(msg: any): void {\n\t\tthis._protocol.handleMessage(msg);\n\t}\n\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\n\t\t\treturn this.initialize(<number>args[0]);\n\t\t}\n\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this.requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\n\t\t}\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this.requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate async initialize(workerId: number): Promise<void> {\n\t\tthis._protocol.setWorkerId(workerId);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../charCode.js';\nimport { onUnexpectedError, transformErrorForSerialization } from '../errors.js';\nimport { Emitter, Event } from '../event.js';\nimport { Disposable, IDisposable } from '../lifecycle.js';\nimport { isWeb } from '../platform.js';\nimport * as strings from '../strings.js';\n\nconst DEFAULT_CHANNEL = 'default';\nconst INITIALIZE = '$initialize';\n\nexport interface IWebWorker extends IDisposable {\n\tgetId(): number;\n\tonMessage: Event<Message>;\n\tonError: Event<any>;\n\tpostMessage(message: Message, transfer: ArrayBuffer[]): void;\n}\n\nlet webWorkerWarningLogged = false;\nexport function logOnceWebWorkerWarning(err: any): void {\n\tif (!isWeb) {\n\t\t// running tests\n\t\treturn;\n\t}\n\tif (!webWorkerWarningLogged) {\n\t\twebWorkerWarningLogged = true;\n\t\tconsole.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n\t}\n\tconsole.warn(err.message);\n}\n\nconst enum MessageType {\n\tRequest,\n\tReply,\n\tSubscribeEvent,\n\tEvent,\n\tUnsubscribeEvent\n}\nclass RequestMessage {\n\tpublic readonly type = MessageType.Request;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly method: string,\n\t\tpublic readonly args: any[]\n\t) { }\n}\nclass ReplyMessage {\n\tpublic readonly type = MessageType.Reply;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly seq: string,\n\t\tpublic readonly res: any,\n\t\tpublic readonly err: any\n\t) { }\n}\nclass SubscribeEventMessage {\n\tpublic readonly type = MessageType.SubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly channel: string,\n\t\tpublic readonly eventName: string,\n\t\tpublic readonly arg: any\n\t) { }\n}\nclass EventMessage {\n\tpublic readonly type = MessageType.Event;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string,\n\t\tpublic readonly event: any\n\t) { }\n}\nclass UnsubscribeEventMessage {\n\tpublic readonly type = MessageType.UnsubscribeEvent;\n\tconstructor(\n\t\tpublic readonly vsWorker: number,\n\t\tpublic readonly req: string\n\t) { }\n}\nexport type Message = RequestMessage | ReplyMessage | SubscribeEventMessage | EventMessage | UnsubscribeEventMessage;\n\ninterface IMessageReply {\n\tresolve: (value?: any) => void;\n\treject: (error?: any) => void;\n}\n\ninterface IMessageHandler {\n\tsendMessage(msg: any, transfer?: ArrayBuffer[]): void;\n\thandleMessage(channel: string, method: string, args: any[]): Promise<any>;\n\thandleEvent(channel: string, eventName: string, arg: any): Event<any>;\n}\n\nclass WebWorkerProtocol {\n\n\tprivate _workerId: number;\n\tprivate _lastSentReq: number;\n\tprivate _pendingReplies: { [req: string]: IMessageReply };\n\tprivate _pendingEmitters: Map<string, Emitter<any>>;\n\tprivate _pendingEvents: Map<string, IDisposable>;\n\tprivate _handler: IMessageHandler;\n\n\tconstructor(handler: IMessageHandler) {\n\t\tthis._workerId = -1;\n\t\tthis._handler = handler;\n\t\tthis._lastSentReq = 0;\n\t\tthis._pendingReplies = Object.create(null);\n\t\tthis._pendingEmitters = new Map<string, Emitter<any>>();\n\t\tthis._pendingEvents = new Map<string, IDisposable>();\n\t}\n\n\tpublic setWorkerId(workerId: number): void {\n\t\tthis._workerId = workerId;\n\t}\n\n\tpublic sendMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tconst req = String(++this._lastSentReq);\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\tthis._pendingReplies[req] = {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject\n\t\t\t};\n\t\t\tthis._send(new RequestMessage(this._workerId, req, channel, method, args));\n\t\t});\n\t}\n\n\tpublic listen(channel: string, eventName: string, arg: any): Event<any> {\n\t\tlet req: string | null = null;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonWillAddFirstListener: () => {\n\t\t\t\treq = String(++this._lastSentReq);\n\t\t\t\tthis._pendingEmitters.set(req, emitter);\n\t\t\t\tthis._send(new SubscribeEventMessage(this._workerId, req, channel, eventName, arg));\n\t\t\t},\n\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\tthis._pendingEmitters.delete(req!);\n\t\t\t\tthis._send(new UnsubscribeEventMessage(this._workerId, req!));\n\t\t\t\treq = null;\n\t\t\t}\n\t\t});\n\t\treturn emitter.event;\n\t}\n\n\tpublic handleMessage(message: Message): void {\n\t\tif (!message || !message.vsWorker) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n\t\t\treturn;\n\t\t}\n\t\tthis._handleMessage(message);\n\t}\n\n\tpublic createProxyToRemoteChannel<T extends object>(channel: string, sendMessageBarrier?: () => Promise<void>): T {\n\t\tconst handler = {\n\t\t\tget: (target: any, name: PropertyKey) => {\n\t\t\t\tif (typeof name === 'string' && !target[name]) {\n\t\t\t\t\tif (propertyIsDynamicEvent(name)) { // onDynamic...\n\t\t\t\t\t\ttarget[name] = (arg: any): Event<any> => {\n\t\t\t\t\t\t\treturn this.listen(channel, name, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (propertyIsEvent(name)) { // on...\n\t\t\t\t\t\ttarget[name] = this.listen(channel, name, undefined);\n\t\t\t\t\t} else if (name.charCodeAt(0) === CharCode.DollarSign) { // $...\n\t\t\t\t\t\ttarget[name] = async (...myArgs: any[]) => {\n\t\t\t\t\t\t\tawait sendMessageBarrier?.();\n\t\t\t\t\t\t\treturn this.sendMessage(channel, name, myArgs);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target[name];\n\t\t\t}\n\t\t};\n\t\treturn new Proxy(Object.create(null), handler);\n\t}\n\n\tprivate _handleMessage(msg: Message): void {\n\t\tswitch (msg.type) {\n\t\t\tcase MessageType.Reply:\n\t\t\t\treturn this._handleReplyMessage(msg);\n\t\t\tcase MessageType.Request:\n\t\t\t\treturn this._handleRequestMessage(msg);\n\t\t\tcase MessageType.SubscribeEvent:\n\t\t\t\treturn this._handleSubscribeEventMessage(msg);\n\t\t\tcase MessageType.Event:\n\t\t\t\treturn this._handleEventMessage(msg);\n\t\t\tcase MessageType.UnsubscribeEvent:\n\t\t\t\treturn this._handleUnsubscribeEventMessage(msg);\n\t\t}\n\t}\n\n\tprivate _handleReplyMessage(replyMessage: ReplyMessage): void {\n\t\tif (!this._pendingReplies[replyMessage.seq]) {\n\t\t\tconsole.warn('Got reply to unknown seq');\n\t\t\treturn;\n\t\t}\n\n\t\tconst reply = this._pendingReplies[replyMessage.seq];\n\t\tdelete this._pendingReplies[replyMessage.seq];\n\n\t\tif (replyMessage.err) {\n\t\t\tlet err = replyMessage.err;\n\t\t\tif (replyMessage.err.$isError) {\n\t\t\t\terr = new Error();\n\t\t\t\terr.name = replyMessage.err.name;\n\t\t\t\terr.message = replyMessage.err.message;\n\t\t\t\terr.stack = replyMessage.err.stack;\n\t\t\t}\n\t\t\treply.reject(err);\n\t\t\treturn;\n\t\t}\n\n\t\treply.resolve(replyMessage.res);\n\t}\n\n\tprivate _handleRequestMessage(requestMessage: RequestMessage): void {\n\t\tconst req = requestMessage.req;\n\t\tconst result = this._handler.handleMessage(requestMessage.channel, requestMessage.method, requestMessage.args);\n\t\tresult.then((r) => {\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, r, undefined));\n\t\t}, (e) => {\n\t\t\tif (e.detail instanceof Error) {\n\t\t\t\t// Loading errors have a detail property that points to the actual error\n\t\t\t\te.detail = transformErrorForSerialization(e.detail);\n\t\t\t}\n\t\t\tthis._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\n\t\t});\n\t}\n\n\tprivate _handleSubscribeEventMessage(msg: SubscribeEventMessage): void {\n\t\tconst req = msg.req;\n\t\tconst disposable = this._handler.handleEvent(msg.channel, msg.eventName, msg.arg)((event) => {\n\t\t\tthis._send(new EventMessage(this._workerId, req, event));\n\t\t});\n\t\tthis._pendingEvents.set(req, disposable);\n\t}\n\n\tprivate _handleEventMessage(msg: EventMessage): void {\n\t\tif (!this._pendingEmitters.has(msg.req)) {\n\t\t\tconsole.warn('Got event for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEmitters.get(msg.req)!.fire(msg.event);\n\t}\n\n\tprivate _handleUnsubscribeEventMessage(msg: UnsubscribeEventMessage): void {\n\t\tif (!this._pendingEvents.has(msg.req)) {\n\t\t\tconsole.warn('Got unsubscribe for unknown req');\n\t\t\treturn;\n\t\t}\n\t\tthis._pendingEvents.get(msg.req)!.dispose();\n\t\tthis._pendingEvents.delete(msg.req);\n\t}\n\n\tprivate _send(msg: Message): void {\n\t\tconst transfer: ArrayBuffer[] = [];\n\t\tif (msg.type === MessageType.Request) {\n\t\t\tfor (let i = 0; i < msg.args.length; i++) {\n\t\t\t\tif (msg.args[i] instanceof ArrayBuffer) {\n\t\t\t\t\ttransfer.push(msg.args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === MessageType.Reply) {\n\t\t\tif (msg.res instanceof ArrayBuffer) {\n\t\t\t\ttransfer.push(msg.res);\n\t\t\t}\n\t\t}\n\t\tthis._handler.sendMessage(msg, transfer);\n\t}\n}\n\ntype ProxiedMethodName = (`$${string}` | `on${string}`);\n\nexport type Proxied<T> = { [K in keyof T]: T[K] extends (...args: infer A) => infer R\n\t? (\n\t\tK extends ProxiedMethodName\n\t\t? (...args: A) => Promise<Awaited<R>>\n\t\t: never\n\t)\n\t: never\n};\n\nexport interface IWebWorkerClient<TProxy> {\n\tproxy: Proxied<TProxy>;\n\tdispose(): void;\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\nexport interface IWebWorkerServer {\n\tsetChannel<T extends object>(channel: string, handler: T): void;\n\tgetChannel<T extends object>(channel: string): Proxied<T>;\n}\n\n/**\n * Main thread side\n */\nexport class WebWorkerClient<W extends object> extends Disposable implements IWebWorkerClient<W> {\n\n\tprivate readonly _worker: IWebWorker;\n\tprivate readonly _onModuleLoaded: Promise<void>;\n\tprivate readonly _protocol: WebWorkerProtocol;\n\tpublic readonly proxy: Proxied<W>;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(\n\t\tworker: IWebWorker\n\t) {\n\t\tsuper();\n\n\t\tthis._worker = this._register(worker);\n\t\tthis._register(this._worker.onMessage((msg) => {\n\t\t\tthis._protocol.handleMessage(msg);\n\t\t}));\n\t\tthis._register(this._worker.onError((err) => {\n\t\t\tlogOnceWebWorkerWarning(err);\n\t\t\tonUnexpectedError(err);\n\t\t}));\n\n\t\tthis._protocol = new WebWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tthis._worker.postMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => {\n\t\t\t\treturn this._handleMessage(channel, method, args);\n\t\t\t},\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => {\n\t\t\t\treturn this._handleEvent(channel, eventName, arg);\n\t\t\t}\n\t\t});\n\t\tthis._protocol.setWorkerId(this._worker.getId());\n\n\t\t// Send initialize message\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(DEFAULT_CHANNEL, INITIALIZE, [\n\t\t\tthis._worker.getId(),\n\t\t]);\n\n\t\tthis.proxy = this._protocol.createProxyToRemoteChannel(DEFAULT_CHANNEL, async () => { await this._onModuleLoaded; });\n\t\tthis._onModuleLoaded.catch((e) => {\n\t\t\tthis._onError('Worker failed to load ', e);\n\t\t});\n\t}\n\n\tprivate _handleMessage(channelName: string, method: string, args: any[]): Promise<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channelName} on main thread`));\n\t\t}\n\t\tif (typeof (channel as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on main thread channel ${channelName}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((channel as any)[method].apply(channel, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channelName: string, eventName: string, arg: any): Event<any> {\n\t\tconst channel: object | undefined = this._localChannels.get(channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error(`Missing channel ${channelName} on main thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName].call(channel, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (channel as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on main thread channel ${channelName}.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel, async () => { await this._onModuleLoaded; });\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate _onError(message: string, error?: any): void {\n\t\tconsole.error(message);\n\t\tconsole.info(error);\n\t}\n}\n\nfunction propertyIsEvent(name: string): boolean {\n\t// Assume a property is an event if it has a form of \"onSomething\"\n\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n}\n\nfunction propertyIsDynamicEvent(name: string): boolean {\n\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n}\n\nexport interface IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: any;\n\t[prop: string]: any;\n}\n\nexport interface IWebWorkerServerRequestHandlerFactory<T extends IWebWorkerServerRequestHandler> {\n\t(workerServer: IWebWorkerServer): T;\n}\n\n/**\n * Worker side\n */\nexport class WebWorkerServer<T extends IWebWorkerServerRequestHandler> implements IWebWorkerServer {\n\n\tpublic readonly requestHandler: T;\n\tprivate _protocol: WebWorkerProtocol;\n\tprivate readonly _localChannels: Map<string, object> = new Map();\n\tprivate readonly _remoteChannels: Map<string, object> = new Map();\n\n\tconstructor(postMessage: (msg: Message, transfer?: ArrayBuffer[]) => void, requestHandlerFactory: IWebWorkerServerRequestHandlerFactory<T>) {\n\t\tthis._protocol = new WebWorkerProtocol({\n\t\t\tsendMessage: (msg: any, transfer: ArrayBuffer[]): void => {\n\t\t\t\tpostMessage(msg, transfer);\n\t\t\t},\n\t\t\thandleMessage: (channel: string, method: string, args: any[]): Promise<any> => this._handleMessage(channel, method, args),\n\t\t\thandleEvent: (channel: string, eventName: string, arg: any): Event<any> => this._handleEvent(channel, eventName, arg)\n\t\t});\n\t\tthis.requestHandler = requestHandlerFactory(this);\n\t}\n\n\tpublic onmessage(msg: any): void {\n\t\tthis._protocol.handleMessage(msg);\n\t}\n\n\tprivate _handleMessage(channel: string, method: string, args: any[]): Promise<any> {\n\t\tif (channel === DEFAULT_CHANNEL && method === INITIALIZE) {\n\t\t\treturn this.initialize(<number>args[0]);\n\t\t}\n\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this.requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\treturn Promise.reject(new Error(`Missing channel ${channel} on worker thread`));\n\t\t}\n\t\tif (typeof (requestHandler as any)[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error(`Missing method ${method} on worker thread channel ${channel}`));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve((requestHandler as any)[method].apply(requestHandler, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\tprivate _handleEvent(channel: string, eventName: string, arg: any): Event<any> {\n\t\tconst requestHandler: object | null | undefined = (channel === DEFAULT_CHANNEL ? this.requestHandler : this._localChannels.get(channel));\n\t\tif (!requestHandler) {\n\t\t\tthrow new Error(`Missing channel ${channel} on worker thread`);\n\t\t}\n\t\tif (propertyIsDynamicEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName].call(requestHandler, arg);\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing dynamic event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tif (propertyIsEvent(eventName)) {\n\t\t\tconst event = (requestHandler as any)[eventName];\n\t\t\tif (typeof event !== 'function') {\n\t\t\t\tthrow new Error(`Missing event ${eventName} on request handler.`);\n\t\t\t}\n\t\t\treturn event;\n\t\t}\n\t\tthrow new Error(`Malformed event name ${eventName}`);\n\t}\n\n\tpublic setChannel<T extends object>(channel: string, handler: T): void {\n\t\tthis._localChannels.set(channel, handler);\n\t}\n\n\tpublic getChannel<T extends object>(channel: string): Proxied<T> {\n\t\tif (!this._remoteChannels.has(channel)) {\n\t\t\tconst inst = this._protocol.createProxyToRemoteChannel(channel);\n\t\t\tthis._remoteChannels.set(channel, inst);\n\t\t}\n\t\treturn this._remoteChannels.get(channel) as Proxied<T>;\n\t}\n\n\tprivate async initialize(workerId: number): Promise<void> {\n\t\tthis._protocol.setWorkerId(workerId);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWebWorkerServerRequestHandler, IWebWorkerServerRequestHandlerFactory, WebWorkerServer } from './webWorker.js';\n\ntype MessageEvent = {\n\tdata: unknown;\n};\n\ndeclare const globalThis: {\n\tpostMessage: (message: any) => void;\n\tonmessage: (event: MessageEvent) => void;\n};\n\nlet initialized = false;\n\nexport function initialize<T extends IWebWorkerServerRequestHandler>(factory: IWebWorkerServerRequestHandlerFactory<T>) {\n\tif (initialized) {\n\t\tthrow new Error('WebWorker already initialized!');\n\t}\n\tinitialized = true;\n\n\tconst webWorkerServer = new WebWorkerServer<T>(\n\t\tmsg => globalThis.postMessage(msg),\n\t\t(workerServer) => factory(workerServer)\n\t);\n\n\tglobalThis.onmessage = (e: MessageEvent) => {\n\t\twebWorkerServer.onmessage(e.data);\n\t};\n\n\treturn webWorkerServer;\n}\n\nexport function bootstrapWebWorker(factory: IWebWorkerServerRequestHandlerFactory<any>) {\n\tglobalThis.onmessage = (_e: MessageEvent) => {\n\t\t// Ignore first message in this case and initialize if not yet initialized\n\t\tif (!initialized) {\n\t\t\tinitialize(factory);\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IWebWorkerServerRequestHandler, IWebWorkerServerRequestHandlerFactory, WebWorkerServer } from './webWorker.js';\n\ntype MessageEvent = {\n\tdata: unknown;\n};\n\ndeclare const globalThis: {\n\tpostMessage: (message: any) => void;\n\tonmessage: (event: MessageEvent) => void;\n};\n\nlet initialized = false;\n\nexport function initialize<T extends IWebWorkerServerRequestHandler>(factory: IWebWorkerServerRequestHandlerFactory<T>) {\n\tif (initialized) {\n\t\tthrow new Error('WebWorker already initialized!');\n\t}\n\tinitialized = true;\n\n\tconst webWorkerServer = new WebWorkerServer<T>(\n\t\tmsg => globalThis.postMessage(msg),\n\t\t(workerServer) => factory(workerServer)\n\t);\n\n\tglobalThis.onmessage = (e: MessageEvent) => {\n\t\twebWorkerServer.onmessage(e.data);\n\t};\n\n\treturn webWorkerServer;\n}\n\nexport function bootstrapWebWorker(factory: IWebWorkerServerRequestHandlerFactory<any>) {\n\tglobalThis.onmessage = (_e: MessageEvent) => {\n\t\t// Ignore first message in this case and initialize if not yet initialized\n\t\tif (!initialized) {\n\t\t\tinitialize(factory);\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\tpublic originalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\tpublic originalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tpublic modifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tpublic modifiedLength: number;\n\n\t/**\n\t * Constructs a new DiffChange with the given sequence information\n\t * and content.\n\t */\n\tconstructor(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number) {\n\t\t//Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n\t\tthis.originalStart = originalStart;\n\t\tthis.originalLength = originalLength;\n\t\tthis.modifiedStart = modifiedStart;\n\t\tthis.modifiedLength = modifiedLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the original sequence.\n\t */\n\tpublic getOriginalEnd() {\n\t\treturn this.originalStart + this.originalLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the modified sequence.\n\t */\n\tpublic getModifiedEnd() {\n\t\treturn this.modifiedStart + this.modifiedLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\tpublic originalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\tpublic originalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tpublic modifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tpublic modifiedLength: number;\n\n\t/**\n\t * Constructs a new DiffChange with the given sequence information\n\t * and content.\n\t */\n\tconstructor(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number) {\n\t\t//Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n\t\tthis.originalStart = originalStart;\n\t\tthis.originalLength = originalLength;\n\t\tthis.modifiedStart = modifiedStart;\n\t\tthis.modifiedLength = modifiedLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the original sequence.\n\t */\n\tpublic getOriginalEnd() {\n\t\treturn this.originalStart + this.originalLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the modified sequence.\n\t */\n\tpublic getModifiedEnd() {\n\t\treturn this.modifiedStart + this.modifiedLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from './lazy.js';\nimport * as streams from './stream.js';\n\ninterface NodeBuffer {\n\tallocUnsafe(size: number): Uint8Array;\n\tisBuffer(obj: any): obj is NodeBuffer;\n\tfrom(arrayBuffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8Array;\n\tfrom(data: string): Uint8Array;\n}\n\ndeclare const Buffer: NodeBuffer;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: { encode: (input: string) => Uint8Array } | null;\nlet textDecoder: { decode: (input: Uint8Array) => string } | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic isNativeBuffer(buffer: unknown): boolean {\n\t\treturn hasBuffer && Buffer.isBuffer(buffer);\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array, offset = 0) {\n\t\treturn binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n\t}\n\n\tequals(other: VSBuffer): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.byteLength !== other.byteLength) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.buffer.every((value, index) => value === other.buffer[index]);\n\t}\n}\n\n/**\n * Like String.indexOf, but works on Uint8Arrays.\n * Uses the boyer-moore-horspool algorithm to be reasonably speedy.\n */\nexport function binaryIndexOf(haystack: Uint8Array, needle: Uint8Array, offset = 0): number {\n\tconst needleLen = needle.byteLength;\n\tconst haystackLen = haystack.byteLength;\n\n\tif (needleLen === 0) {\n\t\treturn 0;\n\t}\n\n\tif (needleLen === 1) {\n\t\treturn haystack.indexOf(needle[0]);\n\t}\n\n\tif (needleLen > haystackLen - offset) {\n\t\treturn -1;\n\t}\n\n\t// find index of the subarray using boyer-moore-horspool algorithm\n\tconst table = indexOfTable.value;\n\ttable.fill(needle.length);\n\tfor (let i = 0; i < needle.length; i++) {\n\t\ttable[needle[i]] = needle.length - i - 1;\n\t}\n\n\tlet i = offset + needle.length - 1;\n\tlet j = i;\n\tlet result = -1;\n\twhile (i < haystackLen) {\n\t\tif (haystack[i] === needle[j]) {\n\t\t\tif (j === 0) {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tj--;\n\t\t} else {\n\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\tj = needle.length - 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n\nconst hexChars = '0123456789abcdef';\nexport function encodeHex({ buffer }: VSBuffer): string {\n\tlet result = '';\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tconst byte = buffer[i];\n\t\tresult += hexChars[byte >>> 4];\n\t\tresult += hexChars[byte & 0x0f];\n\t}\n\treturn result;\n}\n\nexport function decodeHex(hex: string): VSBuffer {\n\tif (hex.length % 2 !== 0) {\n\t\tthrow new SyntaxError('Hex string must have an even length');\n\t}\n\tconst out = new Uint8Array(hex.length >> 1);\n\tfor (let i = 0; i < hex.length;) {\n\t\tout[i >> 1] = (decodeHexChar(hex, i++) << 4) | decodeHexChar(hex, i++);\n\t}\n\treturn VSBuffer.wrap(out);\n}\n\nfunction decodeHexChar(str: string, position: number) {\n\tconst s = str.charCodeAt(position);\n\tif (s >= 48 && s <= 57) { // '0'-'9'\n\t\treturn s - 48;\n\t} else if (s >= 97 && s <= 102) { // 'a'-'f'\n\t\treturn s - 87;\n\t} else if (s >= 65 && s <= 70) { // 'A'-'F'\n\t\treturn s - 55;\n\t} else {\n\t\tthrow new SyntaxError(`Invalid hex character at position ${position}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from './lazy.js';\nimport * as streams from './stream.js';\n\ninterface NodeBuffer {\n\tallocUnsafe(size: number): Uint8Array;\n\tisBuffer(obj: any): obj is NodeBuffer;\n\tfrom(arrayBuffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8Array;\n\tfrom(data: string): Uint8Array;\n}\n\ndeclare const Buffer: NodeBuffer;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: { encode: (input: string) => Uint8Array } | null;\nlet textDecoder: { decode: (input: Uint8Array) => string } | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic isNativeBuffer(buffer: unknown): boolean {\n\t\treturn hasBuffer && Buffer.isBuffer(buffer);\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array, offset = 0) {\n\t\treturn binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n\t}\n\n\tequals(other: VSBuffer): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.byteLength !== other.byteLength) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.buffer.every((value, index) => value === other.buffer[index]);\n\t}\n}\n\n/**\n * Like String.indexOf, but works on Uint8Arrays.\n * Uses the boyer-moore-horspool algorithm to be reasonably speedy.\n */\nexport function binaryIndexOf(haystack: Uint8Array, needle: Uint8Array, offset = 0): number {\n\tconst needleLen = needle.byteLength;\n\tconst haystackLen = haystack.byteLength;\n\n\tif (needleLen === 0) {\n\t\treturn 0;\n\t}\n\n\tif (needleLen === 1) {\n\t\treturn haystack.indexOf(needle[0]);\n\t}\n\n\tif (needleLen > haystackLen - offset) {\n\t\treturn -1;\n\t}\n\n\t// find index of the subarray using boyer-moore-horspool algorithm\n\tconst table = indexOfTable.value;\n\ttable.fill(needle.length);\n\tfor (let i = 0; i < needle.length; i++) {\n\t\ttable[needle[i]] = needle.length - i - 1;\n\t}\n\n\tlet i = offset + needle.length - 1;\n\tlet j = i;\n\tlet result = -1;\n\twhile (i < haystackLen) {\n\t\tif (haystack[i] === needle[j]) {\n\t\t\tif (j === 0) {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tj--;\n\t\t} else {\n\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\tj = needle.length - 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n\nconst hexChars = '0123456789abcdef';\nexport function encodeHex({ buffer }: VSBuffer): string {\n\tlet result = '';\n\tfor (let i = 0; i < buffer.length; i++) {\n\t\tconst byte = buffer[i];\n\t\tresult += hexChars[byte >>> 4];\n\t\tresult += hexChars[byte & 0x0f];\n\t}\n\treturn result;\n}\n\nexport function decodeHex(hex: string): VSBuffer {\n\tif (hex.length % 2 !== 0) {\n\t\tthrow new SyntaxError('Hex string must have an even length');\n\t}\n\tconst out = new Uint8Array(hex.length >> 1);\n\tfor (let i = 0; i < hex.length;) {\n\t\tout[i >> 1] = (decodeHexChar(hex, i++) << 4) | decodeHexChar(hex, i++);\n\t}\n\treturn VSBuffer.wrap(out);\n}\n\nfunction decodeHexChar(str: string, position: number) {\n\tconst s = str.charCodeAt(position);\n\tif (s >= 48 && s <= 57) { // '0'-'9'\n\t\treturn s - 48;\n\t} else if (s >= 97 && s <= 102) { // 'a'-'f'\n\t\treturn s - 87;\n\t} else if (s >= 65 && s <= 70) { // 'A'-'F'\n\t\treturn s - 55;\n\t} else {\n\t\tthrow new SyntaxError(`Invalid hex character at position ${position}`);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { encodeHex, VSBuffer } from './buffer.js';\nimport * as strings from './strings.js';\n\ntype NotSyncHashable = ArrayBufferLike | ArrayBufferView;\n\n/**\n * Return a hash value for an object.\n *\n * Note that this should not be used for binary data types. Instead,\n * prefer {@link hashAsync}.\n */\nexport function hash<T>(obj: T extends NotSyncHashable ? never : T): number {\n\treturn doHash(obj, 0);\n}\n\nexport function doHash(obj: unknown, hashVal: number): number {\n\tswitch (typeof obj) {\n\t\tcase 'object':\n\t\t\tif (obj === null) {\n\t\t\t\treturn numberHash(349, hashVal);\n\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\treturn arrayHash(obj, hashVal);\n\t\t\t}\n\t\t\treturn objectHash(obj, hashVal);\n\t\tcase 'string':\n\t\t\treturn stringHash(obj, hashVal);\n\t\tcase 'boolean':\n\t\t\treturn booleanHash(obj, hashVal);\n\t\tcase 'number':\n\t\t\treturn numberHash(obj, hashVal);\n\t\tcase 'undefined':\n\t\t\treturn numberHash(937, hashVal);\n\t\tdefault:\n\t\t\treturn numberHash(617, hashVal);\n\t}\n}\n\nexport function numberHash(val: number, initialHashVal: number): number {\n\treturn (((initialHashVal << 5) - initialHashVal) + val) | 0;  // hashVal * 31 + ch, keep as int32\n}\n\nfunction booleanHash(b: boolean, initialHashVal: number): number {\n\treturn numberHash(b ? 433 : 863, initialHashVal);\n}\n\nexport function stringHash(s: string, hashVal: number) {\n\thashVal = numberHash(149417, hashVal);\n\tfor (let i = 0, length = s.length; i < length; i++) {\n\t\thashVal = numberHash(s.charCodeAt(i), hashVal);\n\t}\n\treturn hashVal;\n}\n\nfunction arrayHash(arr: any[], initialHashVal: number): number {\n\tinitialHashVal = numberHash(104579, initialHashVal);\n\treturn arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\n\nfunction objectHash(obj: any, initialHashVal: number): number {\n\tinitialHashVal = numberHash(181387, initialHashVal);\n\treturn Object.keys(obj).sort().reduce((hashVal, key) => {\n\t\thashVal = stringHash(key, hashVal);\n\t\treturn doHash(obj[key], hashVal);\n\t}, initialHashVal);\n}\n\n\n\n/** Hashes the input as SHA-1, returning a hex-encoded string. */\nexport const hashAsync = (input: string | ArrayBufferView | VSBuffer) => {\n\t// Note: I would very much like to expose a streaming interface for hashing\n\t// generally, but this is not available in web crypto yet, see\n\t// https://github.com/w3c/webcrypto/issues/73\n\n\t// StringSHA1 is faster for small string input, use it since we have it:\n\tif (typeof input === 'string' && input.length < 250) {\n\t\tconst sha = new StringSHA1();\n\t\tsha.update(input);\n\t\treturn Promise.resolve(sha.digest());\n\t}\n\n\tlet buff: ArrayBufferView;\n\tif (typeof input === 'string') {\n\t\tbuff = new TextEncoder().encode(input);\n\t} else if (input instanceof VSBuffer) {\n\t\tbuff = input.buffer;\n\t} else {\n\t\tbuff = input;\n\t}\n\n\treturn crypto.subtle.digest('sha-1', buff as ArrayBufferView<ArrayBuffer>).then(toHexString); // CodeQL [SM04514] we use sha1 here for validating old stored client state, not for security\n};\n\nconst enum SHA1Constant {\n\tBLOCK_SIZE = 64, // 512 / 8\n\tUNICODE_REPLACEMENT = 0xFFFD,\n}\n\nfunction leftRotate(value: number, bits: number, totalBits: number = 32): number {\n\t// delta + bits = totalBits\n\tconst delta = totalBits - bits;\n\n\t// All ones, expect `delta` zeros aligned to the right\n\tconst mask = ~((1 << delta) - 1);\n\n\t// Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n\treturn ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\n\nfunction toHexString(buffer: ArrayBuffer): string;\nfunction toHexString(value: number, bitsize?: number): string;\nfunction toHexString(bufferOrValue: ArrayBuffer | number, bitsize: number = 32): string {\n\tif (bufferOrValue instanceof ArrayBuffer) {\n\t\treturn encodeHex(VSBuffer.wrap(new Uint8Array(bufferOrValue)));\n\t}\n\n\treturn (bufferOrValue >>> 0).toString(16).padStart(bitsize / 4, '0');\n}\n\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n *\n * Prefer to use {@link hashAsync} in async contexts\n */\nexport class StringSHA1 {\n\tprivate static _bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n\n\tprivate _h0 = 0x67452301;\n\tprivate _h1 = 0xEFCDAB89;\n\tprivate _h2 = 0x98BADCFE;\n\tprivate _h3 = 0x10325476;\n\tprivate _h4 = 0xC3D2E1F0;\n\n\tprivate readonly _buff: Uint8Array;\n\tprivate readonly _buffDV: DataView;\n\tprivate _buffLen: number;\n\tprivate _totalLen: number;\n\tprivate _leftoverHighSurrogate: number;\n\tprivate _finished: boolean;\n\n\tconstructor() {\n\t\tthis._buff = new Uint8Array(SHA1Constant.BLOCK_SIZE + 3 /* to fit any utf-8 */);\n\t\tthis._buffDV = new DataView(this._buff.buffer);\n\t\tthis._buffLen = 0;\n\t\tthis._totalLen = 0;\n\t\tthis._leftoverHighSurrogate = 0;\n\t\tthis._finished = false;\n\t}\n\n\tpublic update(str: string): void {\n\t\tconst strLen = str.length;\n\t\tif (strLen === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buff = this._buff;\n\t\tlet buffLen = this._buffLen;\n\t\tlet leftoverHighSurrogate = this._leftoverHighSurrogate;\n\t\tlet charCode: number;\n\t\tlet offset: number;\n\n\t\tif (leftoverHighSurrogate !== 0) {\n\t\t\tcharCode = leftoverHighSurrogate;\n\t\t\toffset = -1;\n\t\t\tleftoverHighSurrogate = 0;\n\t\t} else {\n\t\t\tcharCode = str.charCodeAt(0);\n\t\t\toffset = 0;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet codePoint = charCode;\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\tif (offset + 1 < strLen) {\n\t\t\t\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\t\t\t\tif (strings.isLowSurrogate(nextCharCode)) {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tcodePoint = strings.computeCodePoint(charCode, nextCharCode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// illegal => unicode replacement character\n\t\t\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// last character is a surrogate pair\n\t\t\t\t\tleftoverHighSurrogate = charCode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (strings.isLowSurrogate(charCode)) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t}\n\n\t\t\tbuffLen = this._push(buff, buffLen, codePoint);\n\t\t\toffset++;\n\t\t\tif (offset < strLen) {\n\t\t\t\tcharCode = str.charCodeAt(offset);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._buffLen = buffLen;\n\t\tthis._leftoverHighSurrogate = leftoverHighSurrogate;\n\t}\n\n\tprivate _push(buff: Uint8Array, buffLen: number, codePoint: number): number {\n\t\tif (codePoint < 0x0080) {\n\t\t\tbuff[buffLen++] = codePoint;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tbuff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tbuff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else {\n\t\t\tbuff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t}\n\n\t\tif (buffLen >= SHA1Constant.BLOCK_SIZE) {\n\t\t\tthis._step();\n\t\t\tbuffLen -= SHA1Constant.BLOCK_SIZE;\n\t\t\tthis._totalLen += SHA1Constant.BLOCK_SIZE;\n\t\t\t// take last 3 in case of UTF8 overflow\n\t\t\tbuff[0] = buff[SHA1Constant.BLOCK_SIZE + 0];\n\t\t\tbuff[1] = buff[SHA1Constant.BLOCK_SIZE + 1];\n\t\t\tbuff[2] = buff[SHA1Constant.BLOCK_SIZE + 2];\n\t\t}\n\n\t\treturn buffLen;\n\t}\n\n\tpublic digest(): string {\n\t\tif (!this._finished) {\n\t\t\tthis._finished = true;\n\t\t\tif (this._leftoverHighSurrogate) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tthis._leftoverHighSurrogate = 0;\n\t\t\t\tthis._buffLen = this._push(this._buff, this._buffLen, SHA1Constant.UNICODE_REPLACEMENT);\n\t\t\t}\n\t\t\tthis._totalLen += this._buffLen;\n\t\t\tthis._wrapUp();\n\t\t}\n\n\t\treturn toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n\t}\n\n\tprivate _wrapUp(): void {\n\t\tthis._buff[this._buffLen++] = 0x80;\n\t\tthis._buff.subarray(this._buffLen).fill(0);\n\n\t\tif (this._buffLen > 56) {\n\t\t\tthis._step();\n\t\t\tthis._buff.fill(0);\n\t\t}\n\n\t\t// this will fit because the mantissa can cover up to 52 bits\n\t\tconst ml = 8 * this._totalLen;\n\n\t\tthis._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n\t\tthis._buffDV.setUint32(60, ml % 4294967296, false);\n\n\t\tthis._step();\n\t}\n\n\tprivate _step(): void {\n\t\tconst bigBlock32 = StringSHA1._bigBlock32;\n\t\tconst data = this._buffDV;\n\n\t\tfor (let j = 0; j < 64 /* 16*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, data.getUint32(j, false), false);\n\t\t}\n\n\t\tfor (let j = 64; j < 320 /* 80*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n\t\t}\n\n\t\tlet a = this._h0;\n\t\tlet b = this._h1;\n\t\tlet c = this._h2;\n\t\tlet d = this._h3;\n\t\tlet e = this._h4;\n\n\t\tlet f: number, k: number;\n\t\tlet temp: number;\n\n\t\tfor (let j = 0; j < 80; j++) {\n\t\t\tif (j < 20) {\n\t\t\t\tf = (b & c) | ((~b) & d);\n\t\t\t\tk = 0x5A827999;\n\t\t\t} else if (j < 40) {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0x6ED9EBA1;\n\t\t\t} else if (j < 60) {\n\t\t\t\tf = (b & c) | (b & d) | (c & d);\n\t\t\t\tk = 0x8F1BBCDC;\n\t\t\t} else {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0xCA62C1D6;\n\t\t\t}\n\n\t\t\ttemp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = leftRotate(b, 30);\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tthis._h0 = (this._h0 + a) & 0xffffffff;\n\t\tthis._h1 = (this._h1 + b) & 0xffffffff;\n\t\tthis._h2 = (this._h2 + c) & 0xffffffff;\n\t\tthis._h3 = (this._h3 + d) & 0xffffffff;\n\t\tthis._h4 = (this._h4 + e) & 0xffffffff;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { encodeHex, VSBuffer } from './buffer.js';\nimport * as strings from './strings.js';\n\ntype NotSyncHashable = ArrayBufferLike | ArrayBufferView;\n\n/**\n * Return a hash value for an object.\n *\n * Note that this should not be used for binary data types. Instead,\n * prefer {@link hashAsync}.\n */\nexport function hash<T>(obj: T extends NotSyncHashable ? never : T): number {\n\treturn doHash(obj, 0);\n}\n\nexport function doHash(obj: unknown, hashVal: number): number {\n\tswitch (typeof obj) {\n\t\tcase 'object':\n\t\t\tif (obj === null) {\n\t\t\t\treturn numberHash(349, hashVal);\n\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\treturn arrayHash(obj, hashVal);\n\t\t\t}\n\t\t\treturn objectHash(obj, hashVal);\n\t\tcase 'string':\n\t\t\treturn stringHash(obj, hashVal);\n\t\tcase 'boolean':\n\t\t\treturn booleanHash(obj, hashVal);\n\t\tcase 'number':\n\t\t\treturn numberHash(obj, hashVal);\n\t\tcase 'undefined':\n\t\t\treturn numberHash(937, hashVal);\n\t\tdefault:\n\t\t\treturn numberHash(617, hashVal);\n\t}\n}\n\nexport function numberHash(val: number, initialHashVal: number): number {\n\treturn (((initialHashVal << 5) - initialHashVal) + val) | 0;  // hashVal * 31 + ch, keep as int32\n}\n\nfunction booleanHash(b: boolean, initialHashVal: number): number {\n\treturn numberHash(b ? 433 : 863, initialHashVal);\n}\n\nexport function stringHash(s: string, hashVal: number) {\n\thashVal = numberHash(149417, hashVal);\n\tfor (let i = 0, length = s.length; i < length; i++) {\n\t\thashVal = numberHash(s.charCodeAt(i), hashVal);\n\t}\n\treturn hashVal;\n}\n\nfunction arrayHash(arr: any[], initialHashVal: number): number {\n\tinitialHashVal = numberHash(104579, initialHashVal);\n\treturn arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\n\nfunction objectHash(obj: any, initialHashVal: number): number {\n\tinitialHashVal = numberHash(181387, initialHashVal);\n\treturn Object.keys(obj).sort().reduce((hashVal, key) => {\n\t\thashVal = stringHash(key, hashVal);\n\t\treturn doHash(obj[key], hashVal);\n\t}, initialHashVal);\n}\n\n\n\n/** Hashes the input as SHA-1, returning a hex-encoded string. */\nexport const hashAsync = (input: string | ArrayBufferView | VSBuffer) => {\n\t// Note: I would very much like to expose a streaming interface for hashing\n\t// generally, but this is not available in web crypto yet, see\n\t// https://github.com/w3c/webcrypto/issues/73\n\n\t// StringSHA1 is faster for small string input, use it since we have it:\n\tif (typeof input === 'string' && input.length < 250) {\n\t\tconst sha = new StringSHA1();\n\t\tsha.update(input);\n\t\treturn Promise.resolve(sha.digest());\n\t}\n\n\tlet buff: ArrayBufferView;\n\tif (typeof input === 'string') {\n\t\tbuff = new TextEncoder().encode(input);\n\t} else if (input instanceof VSBuffer) {\n\t\tbuff = input.buffer;\n\t} else {\n\t\tbuff = input;\n\t}\n\n\treturn crypto.subtle.digest('sha-1', buff as ArrayBufferView<ArrayBuffer>).then(toHexString); // CodeQL [SM04514] we use sha1 here for validating old stored client state, not for security\n};\n\nconst enum SHA1Constant {\n\tBLOCK_SIZE = 64, // 512 / 8\n\tUNICODE_REPLACEMENT = 0xFFFD,\n}\n\nfunction leftRotate(value: number, bits: number, totalBits: number = 32): number {\n\t// delta + bits = totalBits\n\tconst delta = totalBits - bits;\n\n\t// All ones, expect `delta` zeros aligned to the right\n\tconst mask = ~((1 << delta) - 1);\n\n\t// Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n\treturn ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\n\nfunction toHexString(buffer: ArrayBuffer): string;\nfunction toHexString(value: number, bitsize?: number): string;\nfunction toHexString(bufferOrValue: ArrayBuffer | number, bitsize: number = 32): string {\n\tif (bufferOrValue instanceof ArrayBuffer) {\n\t\treturn encodeHex(VSBuffer.wrap(new Uint8Array(bufferOrValue)));\n\t}\n\n\treturn (bufferOrValue >>> 0).toString(16).padStart(bitsize / 4, '0');\n}\n\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n *\n * Prefer to use {@link hashAsync} in async contexts\n */\nexport class StringSHA1 {\n\tprivate static _bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n\n\tprivate _h0 = 0x67452301;\n\tprivate _h1 = 0xEFCDAB89;\n\tprivate _h2 = 0x98BADCFE;\n\tprivate _h3 = 0x10325476;\n\tprivate _h4 = 0xC3D2E1F0;\n\n\tprivate readonly _buff: Uint8Array;\n\tprivate readonly _buffDV: DataView;\n\tprivate _buffLen: number;\n\tprivate _totalLen: number;\n\tprivate _leftoverHighSurrogate: number;\n\tprivate _finished: boolean;\n\n\tconstructor() {\n\t\tthis._buff = new Uint8Array(SHA1Constant.BLOCK_SIZE + 3 /* to fit any utf-8 */);\n\t\tthis._buffDV = new DataView(this._buff.buffer);\n\t\tthis._buffLen = 0;\n\t\tthis._totalLen = 0;\n\t\tthis._leftoverHighSurrogate = 0;\n\t\tthis._finished = false;\n\t}\n\n\tpublic update(str: string): void {\n\t\tconst strLen = str.length;\n\t\tif (strLen === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buff = this._buff;\n\t\tlet buffLen = this._buffLen;\n\t\tlet leftoverHighSurrogate = this._leftoverHighSurrogate;\n\t\tlet charCode: number;\n\t\tlet offset: number;\n\n\t\tif (leftoverHighSurrogate !== 0) {\n\t\t\tcharCode = leftoverHighSurrogate;\n\t\t\toffset = -1;\n\t\t\tleftoverHighSurrogate = 0;\n\t\t} else {\n\t\t\tcharCode = str.charCodeAt(0);\n\t\t\toffset = 0;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet codePoint = charCode;\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\tif (offset + 1 < strLen) {\n\t\t\t\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\t\t\t\tif (strings.isLowSurrogate(nextCharCode)) {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tcodePoint = strings.computeCodePoint(charCode, nextCharCode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// illegal => unicode replacement character\n\t\t\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// last character is a surrogate pair\n\t\t\t\t\tleftoverHighSurrogate = charCode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (strings.isLowSurrogate(charCode)) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t}\n\n\t\t\tbuffLen = this._push(buff, buffLen, codePoint);\n\t\t\toffset++;\n\t\t\tif (offset < strLen) {\n\t\t\t\tcharCode = str.charCodeAt(offset);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._buffLen = buffLen;\n\t\tthis._leftoverHighSurrogate = leftoverHighSurrogate;\n\t}\n\n\tprivate _push(buff: Uint8Array, buffLen: number, codePoint: number): number {\n\t\tif (codePoint < 0x0080) {\n\t\t\tbuff[buffLen++] = codePoint;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tbuff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tbuff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else {\n\t\t\tbuff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t}\n\n\t\tif (buffLen >= SHA1Constant.BLOCK_SIZE) {\n\t\t\tthis._step();\n\t\t\tbuffLen -= SHA1Constant.BLOCK_SIZE;\n\t\t\tthis._totalLen += SHA1Constant.BLOCK_SIZE;\n\t\t\t// take last 3 in case of UTF8 overflow\n\t\t\tbuff[0] = buff[SHA1Constant.BLOCK_SIZE + 0];\n\t\t\tbuff[1] = buff[SHA1Constant.BLOCK_SIZE + 1];\n\t\t\tbuff[2] = buff[SHA1Constant.BLOCK_SIZE + 2];\n\t\t}\n\n\t\treturn buffLen;\n\t}\n\n\tpublic digest(): string {\n\t\tif (!this._finished) {\n\t\t\tthis._finished = true;\n\t\t\tif (this._leftoverHighSurrogate) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tthis._leftoverHighSurrogate = 0;\n\t\t\t\tthis._buffLen = this._push(this._buff, this._buffLen, SHA1Constant.UNICODE_REPLACEMENT);\n\t\t\t}\n\t\t\tthis._totalLen += this._buffLen;\n\t\t\tthis._wrapUp();\n\t\t}\n\n\t\treturn toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n\t}\n\n\tprivate _wrapUp(): void {\n\t\tthis._buff[this._buffLen++] = 0x80;\n\t\tthis._buff.subarray(this._buffLen).fill(0);\n\n\t\tif (this._buffLen > 56) {\n\t\t\tthis._step();\n\t\t\tthis._buff.fill(0);\n\t\t}\n\n\t\t// this will fit because the mantissa can cover up to 52 bits\n\t\tconst ml = 8 * this._totalLen;\n\n\t\tthis._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n\t\tthis._buffDV.setUint32(60, ml % 4294967296, false);\n\n\t\tthis._step();\n\t}\n\n\tprivate _step(): void {\n\t\tconst bigBlock32 = StringSHA1._bigBlock32;\n\t\tconst data = this._buffDV;\n\n\t\tfor (let j = 0; j < 64 /* 16*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, data.getUint32(j, false), false);\n\t\t}\n\n\t\tfor (let j = 64; j < 320 /* 80*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n\t\t}\n\n\t\tlet a = this._h0;\n\t\tlet b = this._h1;\n\t\tlet c = this._h2;\n\t\tlet d = this._h3;\n\t\tlet e = this._h4;\n\n\t\tlet f: number, k: number;\n\t\tlet temp: number;\n\n\t\tfor (let j = 0; j < 80; j++) {\n\t\t\tif (j < 20) {\n\t\t\t\tf = (b & c) | ((~b) & d);\n\t\t\t\tk = 0x5A827999;\n\t\t\t} else if (j < 40) {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0x6ED9EBA1;\n\t\t\t} else if (j < 60) {\n\t\t\t\tf = (b & c) | (b & d) | (c & d);\n\t\t\t\tk = 0x8F1BBCDC;\n\t\t\t} else {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0xCA62C1D6;\n\t\t\t}\n\n\t\t\ttemp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = leftRotate(b, 30);\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tthis._h0 = (this._h0 + a) & 0xffffffff;\n\t\tthis._h1 = (this._h1 + b) & 0xffffffff;\n\t\tthis._h2 = (this._h2 + c) & 0xffffffff;\n\t\tthis._h3 = (this._h3 + d) & 0xffffffff;\n\t\tthis._h4 = (this._h4 + e) & 0xffffffff;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nimport { Constants } from '../uint.js';\n\nexport class StringDiffSequence implements ISequence {\n\n\tconstructor(private source: string) { }\n\n\tgetElements(): Int32Array | number[] | string[] {\n\t\tconst source = this.source;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t}\n\t\treturn characters;\n\t}\n}\n\nexport function stringDiff(original: string, modified: string, pretty: boolean): IDiffChange[] {\n\treturn new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n\nexport interface ISequence {\n\tgetElements(): Int32Array | number[] | string[];\n\tgetStrictElement?(index: number): string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength: number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex: number, matchLengthOfLongest: number): boolean;\n}\n\nexport interface IDiffResult {\n\tquitEarly: boolean;\n\tchanges: IDiffChange[];\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nclass Debug {\n\n\tpublic static Assert(condition: boolean, message: string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nclass MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray: unknown[], sourceIndex: number, destinationArray: unknown[], destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n\tpublic static Copy2(sourceArray: Int32Array, sourceIndex: number, destinationArray: Int32Array, destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nconst enum LocalConstants {\n\tMaxDifferencesHistory = 1447\n}\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes: DiffChange[];\n\tprivate m_originalStart: number;\n\tprivate m_modifiedStart: number;\n\tprivate m_originalCount: number;\n\tprivate m_modifiedCount: number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex: number, modifiedIndex: number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex: number, modifiedIndex: number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class in the reverse order\n\t */\n\tpublic getReverseChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate readonly ContinueProcessingPredicate: IContinueProcessingPredicate | null;\n\n\tprivate readonly _originalSequence: ISequence;\n\tprivate readonly _modifiedSequence: ISequence;\n\tprivate readonly _hasStrings: boolean;\n\tprivate readonly _originalStringElements: string[];\n\tprivate readonly _originalElementsOrHash: Int32Array;\n\tprivate readonly _modifiedStringElements: string[];\n\tprivate readonly _modifiedElementsOrHash: Int32Array;\n\n\tprivate m_forwardHistory: Int32Array[];\n\tprivate m_reverseHistory: Int32Array[];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: IContinueProcessingPredicate | null = null) {\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\n\t\tthis._originalSequence = originalSequence;\n\t\tthis._modifiedSequence = modifiedSequence;\n\n\t\tconst [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n\t\tconst [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n\n\t\tthis._hasStrings = (originalHasStrings && modifiedHasStrings);\n\t\tthis._originalStringElements = originalStringElements;\n\t\tthis._originalElementsOrHash = originalElementsOrHash;\n\t\tthis._modifiedStringElements = modifiedStringElements;\n\t\tthis._modifiedElementsOrHash = modifiedElementsOrHash;\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\t}\n\n\tprivate static _isStringArray(arr: Int32Array | number[] | string[]): arr is string[] {\n\t\treturn (arr.length > 0 && typeof arr[0] === 'string');\n\t}\n\n\tprivate static _getElements(sequence: ISequence): [string[], Int32Array, boolean] {\n\t\tconst elements = sequence.getElements();\n\n\t\tif (LcsDiff._isStringArray(elements)) {\n\t\t\tconst hashes = new Int32Array(elements.length);\n\t\t\tfor (let i = 0, len = elements.length; i < len; i++) {\n\t\t\t\thashes[i] = stringHash(elements[i], 0);\n\t\t\t}\n\t\t\treturn [elements, hashes, true];\n\t\t}\n\n\t\tif (elements instanceof Int32Array) {\n\t\t\treturn [[], elements, false];\n\t\t}\n\n\t\treturn [[], new Int32Array(elements), false];\n\t}\n\n\tprivate ElementsAreEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n\t}\n\n\tprivate ElementsAreStrictEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (!this.ElementsAreEqual(originalIndex, newIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n\t\tconst modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n\t\treturn (originalElement === modifiedElement);\n\t}\n\n\tprivate static _getStrictElement(sequence: ISequence, index: number): string | null {\n\t\tif (typeof sequence.getStrictElement === 'function') {\n\t\t\treturn sequence.getStrictElement(index);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate OriginalElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n\t}\n\n\tprivate ModifiedElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n\t}\n\n\tpublic ComputeDiff(pretty: boolean): IDiffResult {\n\t\treturn this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, pretty: boolean): IDiffResult {\n\t\tconst quitEarlyArr = [false];\n\t\tlet changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n\t\tif (pretty) {\n\t\t\t// We have to clean up the computed diff to be more intuitive\n\t\t\t// but it turns out this cannot be done correctly until the entire set\n\t\t\t// of diffs have been computed\n\t\t\tchanges = this.PrettifyChanges(changes);\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarlyArr[0],\n\t\t\tchanges: changes\n\t\t};\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, quitEarlyArr: boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes: DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tconst midOriginalArr = [0];\n\t\tconst midModifiedArr = [0];\n\t\tconst result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tconst midOriginal = midOriginalArr[0];\n\t\tconst midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tconst leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We didn't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase: number, diagonalForwardStart: number, diagonalForwardEnd: number, diagonalForwardOffset: number,\n\t\tdiagonalReverseBase: number, diagonalReverseStart: number, diagonalReverseEnd: number, diagonalReverseOffset: number,\n\t\tforwardPoints: Int32Array, reversePoints: Int32Array,\n\t\toriginalIndex: number, originalEnd: number, midOriginalArr: number[],\n\t\tmodifiedIndex: number, modifiedEnd: number, midModifiedArr: number[],\n\t\tdeltaIsEven: boolean, quitEarlyArr: boolean[]\n\t): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] | null = null;\n\t\tlet reverseChanges: DiffChange[] | null = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Constants.MIN_SAFE_SMALL_INTEGER;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tconst diagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tconst lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tconst diagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, midOriginalArr: number[], midModifiedArr: number[], quitEarlyArr: boolean[]) {\n\t\tlet originalIndex = 0, modifiedIndex = 0;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tconst maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tconst numDiagonals = maxDifferences + 1;\n\t\tconst forwardPoints = new Int32Array(numDiagonals);\n\t\tconst reversePoints = new Int32Array(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tconst diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tconst diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tconst diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tconst diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tconst delta = diagonalReverseBase - diagonalForwardBase;\n\t\tconst deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tfor (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tconst matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quitting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= LocalConstants.MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Shifts the given changes to provide a more intuitive diff.\n\t * While the first element in a diff matches the first element after the diff,\n\t * we shift the diff down.\n\t *\n\t * @param changes The list of changes to shift\n\t * @returns The shifted changes\n\t */\n\tprivate PrettifyChanges(changes: DiffChange[]): DiffChange[] {\n\n\t\t// Shift all the changes down first\n\t\tfor (let i = 0; i < changes.length; i++) {\n\t\t\tconst change = changes[i];\n\t\t\tconst originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n\t\t\tconst modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\twhile (\n\t\t\t\tchange.originalStart + change.originalLength < originalStop\n\t\t\t\t&& change.modifiedStart + change.modifiedLength < modifiedStop\n\t\t\t\t&& (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n\t\t\t\t&& (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))\n\t\t\t) {\n\t\t\t\tconst startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n\t\t\t\tconst endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n\t\t\t\tif (endStrictEqual && !startStrictEqual) {\n\t\t\t\t\t// moving the change down would create an equal change, but the elements are not strict equal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchange.originalStart++;\n\t\t\t\tchange.modifiedStart++;\n\t\t\t}\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n\t\t\t\tchanges[i] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i + 1, 1);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// Shift changes back up until we hit empty or whitespace-only lines\n\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\tconst change = changes[i];\n\n\t\t\tlet originalStop = 0;\n\t\t\tlet modifiedStop = 0;\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevChange = changes[i - 1];\n\t\t\t\toriginalStop = prevChange.originalStart + prevChange.originalLength;\n\t\t\t\tmodifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n\t\t\t}\n\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\tlet bestDelta = 0;\n\t\t\tlet bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n\t\t\tfor (let delta = 1; ; delta++) {\n\t\t\t\tconst originalStart = change.originalStart - delta;\n\t\t\t\tconst modifiedStart = change.modifiedStart - delta;\n\n\t\t\t\tif (originalStart < originalStop || modifiedStart < modifiedStop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n\t\t\t\tconst score = (\n\t\t\t\t\t(touchingPreviousChange ? 5 : 0)\n\t\t\t\t\t+ this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength)\n\t\t\t\t);\n\n\t\t\t\tif (score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchange.originalStart -= bestDelta;\n\t\t\tchange.modifiedStart -= bestDelta;\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n\t\t\t\tchanges[i - 1] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i, 1);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// There could be multiple longest common substrings.\n\t\t// Give preference to the ones containing longer lines\n\t\tif (this._hasStrings) {\n\t\t\tfor (let i = 1, len = changes.length; i < len; i++) {\n\t\t\t\tconst aChange = changes[i - 1];\n\t\t\t\tconst bChange = changes[i];\n\t\t\t\tconst matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n\t\t\t\tconst aOriginalStart = aChange.originalStart;\n\t\t\t\tconst bOriginalEnd = bChange.originalStart + bChange.originalLength;\n\t\t\t\tconst abOriginalLength = bOriginalEnd - aOriginalStart;\n\t\t\t\tconst aModifiedStart = aChange.modifiedStart;\n\t\t\t\tconst bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n\t\t\t\tconst abModifiedLength = bModifiedEnd - aModifiedStart;\n\t\t\t\t// Avoid wasting a lot of time with these searches\n\t\t\t\tif (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n\t\t\t\t\tconst t = this._findBetterContiguousSequence(\n\t\t\t\t\t\taOriginalStart, abOriginalLength,\n\t\t\t\t\t\taModifiedStart, abModifiedLength,\n\t\t\t\t\t\tmatchedLength\n\t\t\t\t\t);\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tconst [originalMatchStart, modifiedMatchStart] = t;\n\t\t\t\t\t\tif (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n\t\t\t\t\t\t\t// switch to another sequence that has a better score\n\t\t\t\t\t\t\taChange.originalLength = originalMatchStart - aChange.originalStart;\n\t\t\t\t\t\t\taChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n\t\t\t\t\t\t\tbChange.originalStart = originalMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.modifiedStart = modifiedMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.originalLength = bOriginalEnd - bChange.originalStart;\n\t\t\t\t\t\t\tbChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\tprivate _findBetterContiguousSequence(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number, desiredLength: number): [number, number] | null {\n\t\tif (originalLength < desiredLength || modifiedLength < desiredLength) {\n\t\t\treturn null;\n\t\t}\n\t\tconst originalMax = originalStart + originalLength - desiredLength + 1;\n\t\tconst modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n\t\tlet bestScore = 0;\n\t\tlet bestOriginalStart = 0;\n\t\tlet bestModifiedStart = 0;\n\t\tfor (let i = originalStart; i < originalMax; i++) {\n\t\t\tfor (let j = modifiedStart; j < modifiedMax; j++) {\n\t\t\t\tconst score = this._contiguousSequenceScore(i, j, desiredLength);\n\t\t\t\tif (score > 0 && score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOriginalStart = i;\n\t\t\t\t\tbestModifiedStart = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestScore > 0) {\n\t\t\treturn [bestOriginalStart, bestModifiedStart];\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _contiguousSequenceScore(originalStart: number, modifiedStart: number, length: number): number {\n\t\tlet score = 0;\n\t\tfor (let l = 0; l < length; l++) {\n\t\t\tif (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tscore += this._originalStringElements[originalStart + l].length;\n\t\t}\n\t\treturn score;\n\t}\n\n\tprivate _OriginalIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n\t}\n\n\tprivate _OriginalRegionIsBoundary(originalStart: number, originalLength: number): boolean {\n\t\tif (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (originalLength > 0) {\n\t\t\tconst originalEnd = originalStart + originalLength;\n\t\t\tif (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _ModifiedIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n\t}\n\n\tprivate _ModifiedRegionIsBoundary(modifiedStart: number, modifiedLength: number): boolean {\n\t\tif (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (modifiedLength > 0) {\n\t\t\tconst modifiedEnd = modifiedStart + modifiedLength;\n\t\t\tif (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _boundaryScore(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number): number {\n\t\tconst originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n\t\tconst modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n\t\treturn (originalScore + modifiedScore);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left: DiffChange[], right: DiffChange[]): DiffChange[] {\n\t\tconst mergedChangeArr: DiffChange[] = [];\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left: DiffChange, right: DiffChange, mergedChangeArr: Array<DiffChange | null>): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\tconst originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tconst modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\tprivate ClipDiagonalBound(diagonal: number, numDifferences: number, diagonalBaseIndex: number, numDiagonals: number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tconst diagonalsBelow = diagonalBaseIndex;\n\t\tconst diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tconst diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tconst lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tconst upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n}\n\n\n/**\n * Precomputed equality array for character codes.\n */\nconst precomputedEqualityArray = new Uint32Array(0x10000);\n\n/**\n * Computes the Levenshtein distance for strings of length <= 32.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nconst computeLevenshteinDistanceForShortStrings = (firstString: string, secondString: string): number => {\n\tconst firstStringLength = firstString.length;\n\tconst secondStringLength = secondString.length;\n\tconst lastBitMask = 1 << (firstStringLength - 1);\n\tlet positiveVector = -1;\n\tlet negativeVector = 0;\n\tlet distance = firstStringLength;\n\tlet index = firstStringLength;\n\n\t// Initialize precomputedEqualityArray for firstString\n\twhile (index--) {\n\t\tprecomputedEqualityArray[firstString.charCodeAt(index)] |= 1 << index;\n\t}\n\n\t// Process each character of secondString\n\tfor (index = 0; index < secondStringLength; index++) {\n\t\tlet equalityMask = precomputedEqualityArray[secondString.charCodeAt(index)];\n\t\tconst combinedVector = equalityMask | negativeVector;\n\t\tequalityMask |= ((equalityMask & positiveVector) + positiveVector) ^ positiveVector;\n\t\tnegativeVector |= ~(equalityMask | positiveVector);\n\t\tpositiveVector &= equalityMask;\n\t\tif (negativeVector & lastBitMask) {\n\t\t\tdistance++;\n\t\t}\n\t\tif (positiveVector & lastBitMask) {\n\t\t\tdistance--;\n\t\t}\n\t\tnegativeVector = (negativeVector << 1) | 1;\n\t\tpositiveVector = (positiveVector << 1) | ~(combinedVector | negativeVector);\n\t\tnegativeVector &= combinedVector;\n\t}\n\n\t// Reset precomputedEqualityArray\n\tindex = firstStringLength;\n\twhile (index--) {\n\t\tprecomputedEqualityArray[firstString.charCodeAt(index)] = 0;\n\t}\n\n\treturn distance;\n};\n\n/**\n * Computes the Levenshtein distance for strings of length > 32.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nfunction computeLevenshteinDistanceForLongStrings(firstString: string, secondString: string): number {\n\tconst firstStringLength = firstString.length;\n\tconst secondStringLength = secondString.length;\n\tconst horizontalBitArray = [];\n\tconst verticalBitArray = [];\n\tconst horizontalSize = Math.ceil(firstStringLength / 32);\n\tconst verticalSize = Math.ceil(secondStringLength / 32);\n\n\t// Initialize horizontal and vertical bit arrays\n\tfor (let i = 0; i < horizontalSize; i++) {\n\t\thorizontalBitArray[i] = -1;\n\t\tverticalBitArray[i] = 0;\n\t}\n\n\tlet verticalIndex = 0;\n\tfor (; verticalIndex < verticalSize - 1; verticalIndex++) {\n\t\tlet negativeVector = 0;\n\t\tlet positiveVector = -1;\n\t\tconst start = verticalIndex * 32;\n\t\tconst verticalLength = Math.min(32, secondStringLength) + start;\n\n\t\t// Initialize precomputedEqualityArray for secondString\n\t\tfor (let k = start; k < verticalLength; k++) {\n\t\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] |= 1 << k;\n\t\t}\n\n\t\t// Process each character of firstString\n\t\tfor (let i = 0; i < firstStringLength; i++) {\n\t\t\tconst equalityMask = precomputedEqualityArray[firstString.charCodeAt(i)];\n\t\t\tconst previousBit = (horizontalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\t\tconst matchBit = (verticalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\t\tconst combinedVector = equalityMask | negativeVector;\n\t\t\tconst combinedHorizontalVector = ((((equalityMask | matchBit) & positiveVector) + positiveVector) ^ positiveVector) | equalityMask | matchBit;\n\t\t\tlet positiveHorizontalVector = negativeVector | ~(combinedHorizontalVector | positiveVector);\n\t\t\tlet negativeHorizontalVector = positiveVector & combinedHorizontalVector;\n\t\t\tif ((positiveHorizontalVector >>> 31) ^ previousBit) {\n\t\t\t\thorizontalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t\t}\n\t\t\tif ((negativeHorizontalVector >>> 31) ^ matchBit) {\n\t\t\t\tverticalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t\t}\n\t\t\tpositiveHorizontalVector = (positiveHorizontalVector << 1) | previousBit;\n\t\t\tnegativeHorizontalVector = (negativeHorizontalVector << 1) | matchBit;\n\t\t\tpositiveVector = negativeHorizontalVector | ~(combinedVector | positiveHorizontalVector);\n\t\t\tnegativeVector = positiveHorizontalVector & combinedVector;\n\t\t}\n\n\t\t// Reset precomputedEqualityArray\n\t\tfor (let k = start; k < verticalLength; k++) {\n\t\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] = 0;\n\t\t}\n\t}\n\n\tlet negativeVector = 0;\n\tlet positiveVector = -1;\n\tconst start = verticalIndex * 32;\n\tconst verticalLength = Math.min(32, secondStringLength - start) + start;\n\n\t// Initialize precomputedEqualityArray for secondString\n\tfor (let k = start; k < verticalLength; k++) {\n\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] |= 1 << k;\n\t}\n\n\tlet distance = secondStringLength;\n\n\t// Process each character of firstString\n\tfor (let i = 0; i < firstStringLength; i++) {\n\t\tconst equalityMask = precomputedEqualityArray[firstString.charCodeAt(i)];\n\t\tconst previousBit = (horizontalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\tconst matchBit = (verticalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\tconst combinedVector = equalityMask | negativeVector;\n\t\tconst combinedHorizontalVector = ((((equalityMask | matchBit) & positiveVector) + positiveVector) ^ positiveVector) | equalityMask | matchBit;\n\t\tlet positiveHorizontalVector = negativeVector | ~(combinedHorizontalVector | positiveVector);\n\t\tlet negativeHorizontalVector = positiveVector & combinedHorizontalVector;\n\t\tdistance += (positiveHorizontalVector >>> (secondStringLength - 1)) & 1;\n\t\tdistance -= (negativeHorizontalVector >>> (secondStringLength - 1)) & 1;\n\t\tif ((positiveHorizontalVector >>> 31) ^ previousBit) {\n\t\t\thorizontalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t}\n\t\tif ((negativeHorizontalVector >>> 31) ^ matchBit) {\n\t\t\tverticalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t}\n\t\tpositiveHorizontalVector = (positiveHorizontalVector << 1) | previousBit;\n\t\tnegativeHorizontalVector = (negativeHorizontalVector << 1) | matchBit;\n\t\tpositiveVector = negativeHorizontalVector | ~(combinedVector | positiveHorizontalVector);\n\t\tnegativeVector = positiveHorizontalVector & combinedVector;\n\t}\n\n\t// Reset precomputedEqualityArray\n\tfor (let k = start; k < verticalLength; k++) {\n\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] = 0;\n\t}\n\n\treturn distance;\n}\n\n/**\n * Computes the Levenshtein distance between two strings.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nexport function computeLevenshteinDistance(firstString: string, secondString: string): number {\n\tif (firstString.length < secondString.length) {\n\t\tconst temp = secondString;\n\t\tsecondString = firstString;\n\t\tfirstString = temp;\n\t}\n\tif (secondString.length === 0) {\n\t\treturn firstString.length;\n\t}\n\tif (firstString.length <= 32) {\n\t\treturn computeLevenshteinDistanceForShortStrings(firstString, secondString);\n\t}\n\treturn computeLevenshteinDistanceForLongStrings(firstString, secondString);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nimport { Constants } from '../uint.js';\n\nexport class StringDiffSequence implements ISequence {\n\n\tconstructor(private source: string) { }\n\n\tgetElements(): Int32Array | number[] | string[] {\n\t\tconst source = this.source;\n\t\tconst characters = new Int32Array(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tcharacters[i] = source.charCodeAt(i);\n\t\t}\n\t\treturn characters;\n\t}\n}\n\nexport function stringDiff(original: string, modified: string, pretty: boolean): IDiffChange[] {\n\treturn new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n\nexport interface ISequence {\n\tgetElements(): Int32Array | number[] | string[];\n\tgetStrictElement?(index: number): string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart: number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength: number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart: number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength: number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex: number, matchLengthOfLongest: number): boolean;\n}\n\nexport interface IDiffResult {\n\tquitEarly: boolean;\n\tchanges: IDiffChange[];\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nclass Debug {\n\n\tpublic static Assert(condition: boolean, message: string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nclass MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray: unknown[], sourceIndex: number, destinationArray: unknown[], destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n\tpublic static Copy2(sourceArray: Int32Array, sourceIndex: number, destinationArray: Int32Array, destinationIndex: number, length: number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nconst enum LocalConstants {\n\tMaxDifferencesHistory = 1447\n}\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes: DiffChange[];\n\tprivate m_originalStart: number;\n\tprivate m_modifiedStart: number;\n\tprivate m_originalCount: number;\n\tprivate m_modifiedCount: number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\tthis.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex: number, modifiedIndex: number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex: number, modifiedIndex: number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class in the reverse order\n\t */\n\tpublic getReverseChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate readonly ContinueProcessingPredicate: IContinueProcessingPredicate | null;\n\n\tprivate readonly _originalSequence: ISequence;\n\tprivate readonly _modifiedSequence: ISequence;\n\tprivate readonly _hasStrings: boolean;\n\tprivate readonly _originalStringElements: string[];\n\tprivate readonly _originalElementsOrHash: Int32Array;\n\tprivate readonly _modifiedStringElements: string[];\n\tprivate readonly _modifiedElementsOrHash: Int32Array;\n\n\tprivate m_forwardHistory: Int32Array[];\n\tprivate m_reverseHistory: Int32Array[];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: IContinueProcessingPredicate | null = null) {\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\n\t\tthis._originalSequence = originalSequence;\n\t\tthis._modifiedSequence = modifiedSequence;\n\n\t\tconst [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n\t\tconst [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n\n\t\tthis._hasStrings = (originalHasStrings && modifiedHasStrings);\n\t\tthis._originalStringElements = originalStringElements;\n\t\tthis._originalElementsOrHash = originalElementsOrHash;\n\t\tthis._modifiedStringElements = modifiedStringElements;\n\t\tthis._modifiedElementsOrHash = modifiedElementsOrHash;\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\t}\n\n\tprivate static _isStringArray(arr: Int32Array | number[] | string[]): arr is string[] {\n\t\treturn (arr.length > 0 && typeof arr[0] === 'string');\n\t}\n\n\tprivate static _getElements(sequence: ISequence): [string[], Int32Array, boolean] {\n\t\tconst elements = sequence.getElements();\n\n\t\tif (LcsDiff._isStringArray(elements)) {\n\t\t\tconst hashes = new Int32Array(elements.length);\n\t\t\tfor (let i = 0, len = elements.length; i < len; i++) {\n\t\t\t\thashes[i] = stringHash(elements[i], 0);\n\t\t\t}\n\t\t\treturn [elements, hashes, true];\n\t\t}\n\n\t\tif (elements instanceof Int32Array) {\n\t\t\treturn [[], elements, false];\n\t\t}\n\n\t\treturn [[], new Int32Array(elements), false];\n\t}\n\n\tprivate ElementsAreEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n\t}\n\n\tprivate ElementsAreStrictEqual(originalIndex: number, newIndex: number): boolean {\n\t\tif (!this.ElementsAreEqual(originalIndex, newIndex)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n\t\tconst modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n\t\treturn (originalElement === modifiedElement);\n\t}\n\n\tprivate static _getStrictElement(sequence: ISequence, index: number): string | null {\n\t\tif (typeof sequence.getStrictElement === 'function') {\n\t\t\treturn sequence.getStrictElement(index);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate OriginalElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n\t}\n\n\tprivate ModifiedElementsAreEqual(index1: number, index2: number): boolean {\n\t\tif (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n\t}\n\n\tpublic ComputeDiff(pretty: boolean): IDiffResult {\n\t\treturn this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, pretty: boolean): IDiffResult {\n\t\tconst quitEarlyArr = [false];\n\t\tlet changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n\t\tif (pretty) {\n\t\t\t// We have to clean up the computed diff to be more intuitive\n\t\t\t// but it turns out this cannot be done correctly until the entire set\n\t\t\t// of diffs have been computed\n\t\t\tchanges = this.PrettifyChanges(changes);\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarlyArr[0],\n\t\t\tchanges: changes\n\t\t};\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, quitEarlyArr: boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes: DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tconst midOriginalArr = [0];\n\t\tconst midModifiedArr = [0];\n\t\tconst result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tconst midOriginal = midOriginalArr[0];\n\t\tconst midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tconst leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We didn't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase: number, diagonalForwardStart: number, diagonalForwardEnd: number, diagonalForwardOffset: number,\n\t\tdiagonalReverseBase: number, diagonalReverseStart: number, diagonalReverseEnd: number, diagonalReverseOffset: number,\n\t\tforwardPoints: Int32Array, reversePoints: Int32Array,\n\t\toriginalIndex: number, originalEnd: number, midOriginalArr: number[],\n\t\tmodifiedIndex: number, modifiedEnd: number, midModifiedArr: number[],\n\t\tdeltaIsEven: boolean, quitEarlyArr: boolean[]\n\t): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] | null = null;\n\t\tlet reverseChanges: DiffChange[] | null = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Constants.MIN_SAFE_SMALL_INTEGER;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tconst diagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tconst lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Constants.MAX_SAFE_SMALL_INTEGER;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tconst diagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart: number, originalEnd: number, modifiedStart: number, modifiedEnd: number, midOriginalArr: number[], midModifiedArr: number[], quitEarlyArr: boolean[]) {\n\t\tlet originalIndex = 0, modifiedIndex = 0;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tconst maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tconst numDiagonals = maxDifferences + 1;\n\t\tconst forwardPoints = new Int32Array(numDiagonals);\n\t\tconst reversePoints = new Int32Array(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tconst diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tconst diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tconst diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tconst diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tconst delta = diagonalReverseBase - diagonalForwardBase;\n\t\tconst deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tfor (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tconst matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quitting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\tconst tempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= LocalConstants.MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Shifts the given changes to provide a more intuitive diff.\n\t * While the first element in a diff matches the first element after the diff,\n\t * we shift the diff down.\n\t *\n\t * @param changes The list of changes to shift\n\t * @returns The shifted changes\n\t */\n\tprivate PrettifyChanges(changes: DiffChange[]): DiffChange[] {\n\n\t\t// Shift all the changes down first\n\t\tfor (let i = 0; i < changes.length; i++) {\n\t\t\tconst change = changes[i];\n\t\t\tconst originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n\t\t\tconst modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\twhile (\n\t\t\t\tchange.originalStart + change.originalLength < originalStop\n\t\t\t\t&& change.modifiedStart + change.modifiedLength < modifiedStop\n\t\t\t\t&& (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n\t\t\t\t&& (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))\n\t\t\t) {\n\t\t\t\tconst startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n\t\t\t\tconst endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n\t\t\t\tif (endStrictEqual && !startStrictEqual) {\n\t\t\t\t\t// moving the change down would create an equal change, but the elements are not strict equal\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchange.originalStart++;\n\t\t\t\tchange.modifiedStart++;\n\t\t\t}\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n\t\t\t\tchanges[i] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i + 1, 1);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// Shift changes back up until we hit empty or whitespace-only lines\n\t\tfor (let i = changes.length - 1; i >= 0; i--) {\n\t\t\tconst change = changes[i];\n\n\t\t\tlet originalStop = 0;\n\t\t\tlet modifiedStop = 0;\n\t\t\tif (i > 0) {\n\t\t\t\tconst prevChange = changes[i - 1];\n\t\t\t\toriginalStop = prevChange.originalStart + prevChange.originalLength;\n\t\t\t\tmodifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n\t\t\t}\n\n\t\t\tconst checkOriginal = change.originalLength > 0;\n\t\t\tconst checkModified = change.modifiedLength > 0;\n\n\t\t\tlet bestDelta = 0;\n\t\t\tlet bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n\n\t\t\tfor (let delta = 1; ; delta++) {\n\t\t\t\tconst originalStart = change.originalStart - delta;\n\t\t\t\tconst modifiedStart = change.modifiedStart - delta;\n\n\t\t\t\tif (originalStart < originalStop || modifiedStart < modifiedStop) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n\t\t\t\tconst score = (\n\t\t\t\t\t(touchingPreviousChange ? 5 : 0)\n\t\t\t\t\t+ this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength)\n\t\t\t\t);\n\n\t\t\t\tif (score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchange.originalStart -= bestDelta;\n\t\t\tchange.modifiedStart -= bestDelta;\n\n\t\t\tconst mergedChangeArr: Array<DiffChange | null> = [null];\n\t\t\tif (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n\t\t\t\tchanges[i - 1] = mergedChangeArr[0]!;\n\t\t\t\tchanges.splice(i, 1);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// There could be multiple longest common substrings.\n\t\t// Give preference to the ones containing longer lines\n\t\tif (this._hasStrings) {\n\t\t\tfor (let i = 1, len = changes.length; i < len; i++) {\n\t\t\t\tconst aChange = changes[i - 1];\n\t\t\t\tconst bChange = changes[i];\n\t\t\t\tconst matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n\t\t\t\tconst aOriginalStart = aChange.originalStart;\n\t\t\t\tconst bOriginalEnd = bChange.originalStart + bChange.originalLength;\n\t\t\t\tconst abOriginalLength = bOriginalEnd - aOriginalStart;\n\t\t\t\tconst aModifiedStart = aChange.modifiedStart;\n\t\t\t\tconst bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n\t\t\t\tconst abModifiedLength = bModifiedEnd - aModifiedStart;\n\t\t\t\t// Avoid wasting a lot of time with these searches\n\t\t\t\tif (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n\t\t\t\t\tconst t = this._findBetterContiguousSequence(\n\t\t\t\t\t\taOriginalStart, abOriginalLength,\n\t\t\t\t\t\taModifiedStart, abModifiedLength,\n\t\t\t\t\t\tmatchedLength\n\t\t\t\t\t);\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tconst [originalMatchStart, modifiedMatchStart] = t;\n\t\t\t\t\t\tif (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n\t\t\t\t\t\t\t// switch to another sequence that has a better score\n\t\t\t\t\t\t\taChange.originalLength = originalMatchStart - aChange.originalStart;\n\t\t\t\t\t\t\taChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n\t\t\t\t\t\t\tbChange.originalStart = originalMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.modifiedStart = modifiedMatchStart + matchedLength;\n\t\t\t\t\t\t\tbChange.originalLength = bOriginalEnd - bChange.originalStart;\n\t\t\t\t\t\t\tbChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\tprivate _findBetterContiguousSequence(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number, desiredLength: number): [number, number] | null {\n\t\tif (originalLength < desiredLength || modifiedLength < desiredLength) {\n\t\t\treturn null;\n\t\t}\n\t\tconst originalMax = originalStart + originalLength - desiredLength + 1;\n\t\tconst modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n\t\tlet bestScore = 0;\n\t\tlet bestOriginalStart = 0;\n\t\tlet bestModifiedStart = 0;\n\t\tfor (let i = originalStart; i < originalMax; i++) {\n\t\t\tfor (let j = modifiedStart; j < modifiedMax; j++) {\n\t\t\t\tconst score = this._contiguousSequenceScore(i, j, desiredLength);\n\t\t\t\tif (score > 0 && score > bestScore) {\n\t\t\t\t\tbestScore = score;\n\t\t\t\t\tbestOriginalStart = i;\n\t\t\t\t\tbestModifiedStart = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestScore > 0) {\n\t\t\treturn [bestOriginalStart, bestModifiedStart];\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _contiguousSequenceScore(originalStart: number, modifiedStart: number, length: number): number {\n\t\tlet score = 0;\n\t\tfor (let l = 0; l < length; l++) {\n\t\t\tif (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tscore += this._originalStringElements[originalStart + l].length;\n\t\t}\n\t\treturn score;\n\t}\n\n\tprivate _OriginalIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n\t}\n\n\tprivate _OriginalRegionIsBoundary(originalStart: number, originalLength: number): boolean {\n\t\tif (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (originalLength > 0) {\n\t\t\tconst originalEnd = originalStart + originalLength;\n\t\t\tif (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _ModifiedIsBoundary(index: number): boolean {\n\t\tif (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n\t}\n\n\tprivate _ModifiedRegionIsBoundary(modifiedStart: number, modifiedLength: number): boolean {\n\t\tif (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (modifiedLength > 0) {\n\t\t\tconst modifiedEnd = modifiedStart + modifiedLength;\n\t\t\tif (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _boundaryScore(originalStart: number, originalLength: number, modifiedStart: number, modifiedLength: number): number {\n\t\tconst originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n\t\tconst modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n\t\treturn (originalScore + modifiedScore);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left: DiffChange[], right: DiffChange[]): DiffChange[] {\n\t\tconst mergedChangeArr: DiffChange[] = [];\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tconst result = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left: DiffChange, right: DiffChange, mergedChangeArr: Array<DiffChange | null>): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\tconst originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tconst modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\tprivate ClipDiagonalBound(diagonal: number, numDifferences: number, diagonalBaseIndex: number, numDiagonals: number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tconst diagonalsBelow = diagonalBaseIndex;\n\t\tconst diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tconst diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tconst lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tconst upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n}\n\n\n/**\n * Precomputed equality array for character codes.\n */\nconst precomputedEqualityArray = new Uint32Array(0x10000);\n\n/**\n * Computes the Levenshtein distance for strings of length <= 32.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nconst computeLevenshteinDistanceForShortStrings = (firstString: string, secondString: string): number => {\n\tconst firstStringLength = firstString.length;\n\tconst secondStringLength = secondString.length;\n\tconst lastBitMask = 1 << (firstStringLength - 1);\n\tlet positiveVector = -1;\n\tlet negativeVector = 0;\n\tlet distance = firstStringLength;\n\tlet index = firstStringLength;\n\n\t// Initialize precomputedEqualityArray for firstString\n\twhile (index--) {\n\t\tprecomputedEqualityArray[firstString.charCodeAt(index)] |= 1 << index;\n\t}\n\n\t// Process each character of secondString\n\tfor (index = 0; index < secondStringLength; index++) {\n\t\tlet equalityMask = precomputedEqualityArray[secondString.charCodeAt(index)];\n\t\tconst combinedVector = equalityMask | negativeVector;\n\t\tequalityMask |= ((equalityMask & positiveVector) + positiveVector) ^ positiveVector;\n\t\tnegativeVector |= ~(equalityMask | positiveVector);\n\t\tpositiveVector &= equalityMask;\n\t\tif (negativeVector & lastBitMask) {\n\t\t\tdistance++;\n\t\t}\n\t\tif (positiveVector & lastBitMask) {\n\t\t\tdistance--;\n\t\t}\n\t\tnegativeVector = (negativeVector << 1) | 1;\n\t\tpositiveVector = (positiveVector << 1) | ~(combinedVector | negativeVector);\n\t\tnegativeVector &= combinedVector;\n\t}\n\n\t// Reset precomputedEqualityArray\n\tindex = firstStringLength;\n\twhile (index--) {\n\t\tprecomputedEqualityArray[firstString.charCodeAt(index)] = 0;\n\t}\n\n\treturn distance;\n};\n\n/**\n * Computes the Levenshtein distance for strings of length > 32.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nfunction computeLevenshteinDistanceForLongStrings(firstString: string, secondString: string): number {\n\tconst firstStringLength = firstString.length;\n\tconst secondStringLength = secondString.length;\n\tconst horizontalBitArray = [];\n\tconst verticalBitArray = [];\n\tconst horizontalSize = Math.ceil(firstStringLength / 32);\n\tconst verticalSize = Math.ceil(secondStringLength / 32);\n\n\t// Initialize horizontal and vertical bit arrays\n\tfor (let i = 0; i < horizontalSize; i++) {\n\t\thorizontalBitArray[i] = -1;\n\t\tverticalBitArray[i] = 0;\n\t}\n\n\tlet verticalIndex = 0;\n\tfor (; verticalIndex < verticalSize - 1; verticalIndex++) {\n\t\tlet negativeVector = 0;\n\t\tlet positiveVector = -1;\n\t\tconst start = verticalIndex * 32;\n\t\tconst verticalLength = Math.min(32, secondStringLength) + start;\n\n\t\t// Initialize precomputedEqualityArray for secondString\n\t\tfor (let k = start; k < verticalLength; k++) {\n\t\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] |= 1 << k;\n\t\t}\n\n\t\t// Process each character of firstString\n\t\tfor (let i = 0; i < firstStringLength; i++) {\n\t\t\tconst equalityMask = precomputedEqualityArray[firstString.charCodeAt(i)];\n\t\t\tconst previousBit = (horizontalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\t\tconst matchBit = (verticalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\t\tconst combinedVector = equalityMask | negativeVector;\n\t\t\tconst combinedHorizontalVector = ((((equalityMask | matchBit) & positiveVector) + positiveVector) ^ positiveVector) | equalityMask | matchBit;\n\t\t\tlet positiveHorizontalVector = negativeVector | ~(combinedHorizontalVector | positiveVector);\n\t\t\tlet negativeHorizontalVector = positiveVector & combinedHorizontalVector;\n\t\t\tif ((positiveHorizontalVector >>> 31) ^ previousBit) {\n\t\t\t\thorizontalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t\t}\n\t\t\tif ((negativeHorizontalVector >>> 31) ^ matchBit) {\n\t\t\t\tverticalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t\t}\n\t\t\tpositiveHorizontalVector = (positiveHorizontalVector << 1) | previousBit;\n\t\t\tnegativeHorizontalVector = (negativeHorizontalVector << 1) | matchBit;\n\t\t\tpositiveVector = negativeHorizontalVector | ~(combinedVector | positiveHorizontalVector);\n\t\t\tnegativeVector = positiveHorizontalVector & combinedVector;\n\t\t}\n\n\t\t// Reset precomputedEqualityArray\n\t\tfor (let k = start; k < verticalLength; k++) {\n\t\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] = 0;\n\t\t}\n\t}\n\n\tlet negativeVector = 0;\n\tlet positiveVector = -1;\n\tconst start = verticalIndex * 32;\n\tconst verticalLength = Math.min(32, secondStringLength - start) + start;\n\n\t// Initialize precomputedEqualityArray for secondString\n\tfor (let k = start; k < verticalLength; k++) {\n\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] |= 1 << k;\n\t}\n\n\tlet distance = secondStringLength;\n\n\t// Process each character of firstString\n\tfor (let i = 0; i < firstStringLength; i++) {\n\t\tconst equalityMask = precomputedEqualityArray[firstString.charCodeAt(i)];\n\t\tconst previousBit = (horizontalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\tconst matchBit = (verticalBitArray[(i / 32) | 0] >>> i) & 1;\n\t\tconst combinedVector = equalityMask | negativeVector;\n\t\tconst combinedHorizontalVector = ((((equalityMask | matchBit) & positiveVector) + positiveVector) ^ positiveVector) | equalityMask | matchBit;\n\t\tlet positiveHorizontalVector = negativeVector | ~(combinedHorizontalVector | positiveVector);\n\t\tlet negativeHorizontalVector = positiveVector & combinedHorizontalVector;\n\t\tdistance += (positiveHorizontalVector >>> (secondStringLength - 1)) & 1;\n\t\tdistance -= (negativeHorizontalVector >>> (secondStringLength - 1)) & 1;\n\t\tif ((positiveHorizontalVector >>> 31) ^ previousBit) {\n\t\t\thorizontalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t}\n\t\tif ((negativeHorizontalVector >>> 31) ^ matchBit) {\n\t\t\tverticalBitArray[(i / 32) | 0] ^= 1 << i;\n\t\t}\n\t\tpositiveHorizontalVector = (positiveHorizontalVector << 1) | previousBit;\n\t\tnegativeHorizontalVector = (negativeHorizontalVector << 1) | matchBit;\n\t\tpositiveVector = negativeHorizontalVector | ~(combinedVector | positiveHorizontalVector);\n\t\tnegativeVector = positiveHorizontalVector & combinedVector;\n\t}\n\n\t// Reset precomputedEqualityArray\n\tfor (let k = start; k < verticalLength; k++) {\n\t\tprecomputedEqualityArray[secondString.charCodeAt(k)] = 0;\n\t}\n\n\treturn distance;\n}\n\n/**\n * Computes the Levenshtein distance between two strings.\n * @param firstString - The first string.\n * @param secondString - The second string.\n * @returns The Levenshtein distance.\n */\nexport function computeLevenshteinDistance(firstString: string, secondString: string): number {\n\tif (firstString.length < secondString.length) {\n\t\tconst temp = secondString;\n\t\tsecondString = firstString;\n\t\tfirstString = temp;\n\t}\n\tif (secondString.length === 0) {\n\t\treturn firstString.length;\n\t}\n\tif (firstString.length <= 32) {\n\t\treturn computeLevenshteinDistanceForShortStrings(firstString, secondString);\n\t}\n\treturn computeLevenshteinDistanceForLongStrings(firstString, secondString);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A position in the editor. This interface is suitable for serialization.\n */\nexport interface IPosition {\n\t/**\n\t * line number (starts at 1)\n\t */\n\treadonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\treadonly column: number;\n}\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\t/**\n\t * line number (starts at 1)\n\t */\n\tpublic readonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\tpublic readonly column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Create a new position from this position.\n\t *\n\t * @param newLineNumber new line number\n\t * @param newColumn new column\n\t */\n\twith(newLineNumber: number = this.lineNumber, newColumn: number = this.column): Position {\n\t\tif (newLineNumber === this.lineNumber && newColumn === this.column) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Position(newLineNumber, newColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Derive a new position from this position.\n\t *\n\t * @param deltaLineNumber line number delta\n\t * @param deltaColumn column delta\n\t */\n\tdelta(deltaLineNumber: number = 0, deltaColumn: number = 0): Position {\n\t\treturn this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other: IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` equals position `b`\n\t */\n\tpublic static equals(a: IPosition | null, b: IPosition | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other: IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic static isBefore(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other: IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic static isBeforeOrEqual(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * A function that compares positions, useful for sorting\n\t */\n\tpublic static compare(a: IPosition, b: IPosition): number {\n\t\tconst aLineNumber = a.lineNumber | 0;\n\t\tconst bLineNumber = b.lineNumber | 0;\n\n\t\tif (aLineNumber === bLineNumber) {\n\t\t\tconst aColumn = a.column | 0;\n\t\t\tconst bColumn = b.column | 0;\n\t\t\treturn aColumn - bColumn;\n\t\t}\n\n\t\treturn aLineNumber - bLineNumber;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\t/**\n\t * Convert to a human-readable representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\t/**\n\t * Create a `Position` from an `IPosition`.\n\t */\n\tpublic static lift(pos: IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IPosition`.\n\t */\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic toJSON(): IPosition {\n\t\treturn {\n\t\t\tlineNumber: this.lineNumber,\n\t\t\tcolumn: this.column\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A position in the editor. This interface is suitable for serialization.\n */\nexport interface IPosition {\n\t/**\n\t * line number (starts at 1)\n\t */\n\treadonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\treadonly column: number;\n}\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\t/**\n\t * line number (starts at 1)\n\t */\n\tpublic readonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\tpublic readonly column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Create a new position from this position.\n\t *\n\t * @param newLineNumber new line number\n\t * @param newColumn new column\n\t */\n\twith(newLineNumber: number = this.lineNumber, newColumn: number = this.column): Position {\n\t\tif (newLineNumber === this.lineNumber && newColumn === this.column) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Position(newLineNumber, newColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Derive a new position from this position.\n\t *\n\t * @param deltaLineNumber line number delta\n\t * @param deltaColumn column delta\n\t */\n\tdelta(deltaLineNumber: number = 0, deltaColumn: number = 0): Position {\n\t\treturn this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other: IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` equals position `b`\n\t */\n\tpublic static equals(a: IPosition | null, b: IPosition | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other: IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic static isBefore(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other: IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic static isBeforeOrEqual(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * A function that compares positions, useful for sorting\n\t */\n\tpublic static compare(a: IPosition, b: IPosition): number {\n\t\tconst aLineNumber = a.lineNumber | 0;\n\t\tconst bLineNumber = b.lineNumber | 0;\n\n\t\tif (aLineNumber === bLineNumber) {\n\t\t\tconst aColumn = a.column | 0;\n\t\t\tconst bColumn = b.column | 0;\n\t\t\treturn aColumn - bColumn;\n\t\t}\n\n\t\treturn aLineNumber - bLineNumber;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\t/**\n\t * Convert to a human-readable representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\t/**\n\t * Create a `Position` from an `IPosition`.\n\t */\n\tpublic static lift(pos: IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IPosition`.\n\t */\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic toJSON(): IPosition {\n\t\treturn {\n\t\t\tlineNumber: this.lineNumber,\n\t\t\tcolumn: this.column\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n\t}\n\n\tpublic isSingleLine(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumber;\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(start: IPosition, end: IPosition = start): Range {\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting, but not touching at all.\n\t */\n\tpublic static areOnlyIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < (b.startLineNumber - 1) || (a.endLineNumber === b.startLineNumber && a.endColumn < (b.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < (a.startLineNumber - 1) || (b.endLineNumber === a.startLineNumber && b.endColumn < (a.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = (a ? 1 : 0);\n\t\tconst bExists = (b ? 1 : 0);\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n\t}\n\n\tpublic isSingleLine(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumber;\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(start: IPosition, end: IPosition = start): Range {\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting, but not touching at all.\n\t */\n\tpublic static areOnlyIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < (b.startLineNumber - 1) || (a.endLineNumber === b.startLineNumber && a.endColumn < (b.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < (a.startLineNumber - 1) || (b.endLineNumber === a.startLineNumber && b.endColumn < (a.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = (a ? 1 : 0);\n\t\tconst bExists = (b ? 1 : 0);\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum Constants {\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_SMALL_INTEGER = 1 << 30,\n\n\t/**\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_SMALL_INTEGER = -(1 << 30),\n\n\t/**\n\t * Max unsigned integer that fits on 8 bits.\n\t */\n\tMAX_UINT_8 = 255, // 2^8 - 1\n\n\t/**\n\t * Max unsigned integer that fits on 16 bits.\n\t */\n\tMAX_UINT_16 = 65535, // 2^16 - 1\n\n\t/**\n\t * Max unsigned integer that fits on 32 bits.\n\t */\n\tMAX_UINT_32 = 4294967295, // 2^32 - 1\n\n\tUNICODE_SUPPLEMENTARY_PLANE_BEGIN = 0x010000\n}\n\nexport function toUint8(v: number): number {\n\tif (v < 0) {\n\t\treturn 0;\n\t}\n\tif (v > Constants.MAX_UINT_8) {\n\t\treturn Constants.MAX_UINT_8;\n\t}\n\treturn v | 0;\n}\n\nexport function toUint32(v: number): number {\n\tif (v < 0) {\n\t\treturn 0;\n\t}\n\tif (v > Constants.MAX_UINT_32) {\n\t\treturn Constants.MAX_UINT_32;\n\t}\n\treturn v | 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum Constants {\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_SMALL_INTEGER = 1 << 30,\n\n\t/**\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_SMALL_INTEGER = -(1 << 30),\n\n\t/**\n\t * Max unsigned integer that fits on 8 bits.\n\t */\n\tMAX_UINT_8 = 255, // 2^8 - 1\n\n\t/**\n\t * Max unsigned integer that fits on 16 bits.\n\t */\n\tMAX_UINT_16 = 65535, // 2^16 - 1\n\n\t/**\n\t * Max unsigned integer that fits on 32 bits.\n\t */\n\tMAX_UINT_32 = 4294967295, // 2^32 - 1\n\n\tUNICODE_SUPPLEMENTARY_PLANE_BEGIN = 0x010000\n}\n\nexport function toUint8(v: number): number {\n\tif (v < 0) {\n\t\treturn 0;\n\t}\n\tif (v > Constants.MAX_UINT_8) {\n\t\treturn Constants.MAX_UINT_8;\n\t}\n\treturn v | 0;\n}\n\nexport function toUint32(v: number): number {\n\tif (v < 0) {\n\t\treturn 0;\n\t}\n\tif (v > Constants.MAX_UINT_32) {\n\t\treturn Constants.MAX_UINT_32;\n\t}\n\treturn v | 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toUint8 } from '../../../base/common/uint.js';\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier<T extends number> {\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprotected readonly _asciiMap: Uint8Array;\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprotected readonly _map: Map<number, number>;\n\n\tprotected readonly _defaultValue: number;\n\n\tconstructor(_defaultValue: T) {\n\t\tconst defaultValue = toUint8(_defaultValue);\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n\t\tthis._map = new Map<number, number>();\n\t}\n\n\tprivate static _createAsciiMap(defaultValue: number): Uint8Array {\n\t\tconst asciiMap = new Uint8Array(256);\n\t\tasciiMap.fill(defaultValue);\n\t\treturn asciiMap;\n\t}\n\n\tpublic set(charCode: number, _value: T): void {\n\t\tconst value = toUint8(_value);\n\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = value;\n\t\t} else {\n\t\t\tthis._map.set(charCode, value);\n\t\t}\n\t}\n\n\tpublic get(charCode: number): T {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <T>this._asciiMap[charCode];\n\t\t} else {\n\t\t\treturn <T>(this._map.get(charCode) || this._defaultValue);\n\t\t}\n\t}\n\n\tpublic clear() {\n\t\tthis._asciiMap.fill(this._defaultValue);\n\t\tthis._map.clear();\n\t}\n}\n\nconst enum Boolean {\n\tFalse = 0,\n\tTrue = 1\n}\n\nexport class CharacterSet {\n\n\tprivate readonly _actual: CharacterClassifier<Boolean>;\n\n\tconstructor() {\n\t\tthis._actual = new CharacterClassifier<Boolean>(Boolean.False);\n\t}\n\n\tpublic add(charCode: number): void {\n\t\tthis._actual.set(charCode, Boolean.True);\n\t}\n\n\tpublic has(charCode: number): boolean {\n\t\treturn (this._actual.get(charCode) === Boolean.True);\n\t}\n\n\tpublic clear(): void {\n\t\treturn this._actual.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toUint8 } from '../../../base/common/uint.js';\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier<T extends number> {\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprotected readonly _asciiMap: Uint8Array;\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprotected readonly _map: Map<number, number>;\n\n\tprotected readonly _defaultValue: number;\n\n\tconstructor(_defaultValue: T) {\n\t\tconst defaultValue = toUint8(_defaultValue);\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n\t\tthis._map = new Map<number, number>();\n\t}\n\n\tprivate static _createAsciiMap(defaultValue: number): Uint8Array {\n\t\tconst asciiMap = new Uint8Array(256);\n\t\tasciiMap.fill(defaultValue);\n\t\treturn asciiMap;\n\t}\n\n\tpublic set(charCode: number, _value: T): void {\n\t\tconst value = toUint8(_value);\n\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = value;\n\t\t} else {\n\t\t\tthis._map.set(charCode, value);\n\t\t}\n\t}\n\n\tpublic get(charCode: number): T {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <T>this._asciiMap[charCode];\n\t\t} else {\n\t\t\treturn <T>(this._map.get(charCode) || this._defaultValue);\n\t\t}\n\t}\n\n\tpublic clear() {\n\t\tthis._asciiMap.fill(this._defaultValue);\n\t\tthis._map.clear();\n\t}\n}\n\nconst enum Boolean {\n\tFalse = 0,\n\tTrue = 1\n}\n\nexport class CharacterSet {\n\n\tprivate readonly _actual: CharacterClassifier<Boolean>;\n\n\tconstructor() {\n\t\tthis._actual = new CharacterClassifier<Boolean>(Boolean.False);\n\t}\n\n\tpublic add(charCode: number): void {\n\t\tthis._actual.set(charCode, Boolean.True);\n\t}\n\n\tpublic has(charCode: number): boolean {\n\t\treturn (this._actual.get(charCode) === Boolean.True);\n\t}\n\n\tpublic clear(): void {\n\t\treturn this._actual.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { ILink } from '../languages.js';\n\nexport interface ILinkComputerTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum State {\n\tInvalid = 0,\n\tStart = 1,\n\tH = 2,\n\tHT = 3,\n\tHTT = 4,\n\tHTTP = 5,\n\tF = 6,\n\tFI = 7,\n\tFIL = 8,\n\tBeforeColon = 9,\n\tAfterColon = 10,\n\tAlmostThere = 11,\n\tEnd = 12,\n\tAccept = 13,\n\tLastKnownState = 14 // marker, custom states may follow\n}\n\nexport type Edge = [State, number, State];\n\nclass Uint8Matrix {\n\n\tprivate readonly _data: Uint8Array;\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\tconstructor(rows: number, cols: number, defaultValue: number) {\n\t\tconst data = new Uint8Array(rows * cols);\n\t\tfor (let i = 0, len = rows * cols; i < len; i++) {\n\t\t\tdata[i] = defaultValue;\n\t\t}\n\n\t\tthis._data = data;\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t}\n\n\tpublic get(row: number, col: number): number {\n\t\treturn this._data[row * this.cols + col];\n\t}\n\n\tpublic set(row: number, col: number, value: number): void {\n\t\tthis._data[row * this.cols + col] = value;\n\t}\n}\n\nexport class StateMachine {\n\n\tprivate readonly _states: Uint8Matrix;\n\tprivate readonly _maxCharCode: number;\n\n\tconstructor(edges: Edge[]) {\n\t\tlet maxCharCode = 0;\n\t\tlet maxState = State.Invalid;\n\t\tfor (let i = 0, len = edges.length; i < len; i++) {\n\t\t\tconst [from, chCode, to] = edges[i];\n\t\t\tif (chCode > maxCharCode) {\n\t\t\t\tmaxCharCode = chCode;\n\t\t\t}\n\t\t\tif (from > maxState) {\n\t\t\t\tmaxState = from;\n\t\t\t}\n\t\t\tif (to > maxState) {\n\t\t\t\tmaxState = to;\n\t\t\t}\n\t\t}\n\n\t\tmaxCharCode++;\n\t\tmaxState++;\n\n\t\tconst states = new Uint8Matrix(maxState, maxCharCode, State.Invalid);\n\t\tfor (let i = 0, len = edges.length; i < len; i++) {\n\t\t\tconst [from, chCode, to] = edges[i];\n\t\t\tstates.set(from, chCode, to);\n\t\t}\n\n\t\tthis._states = states;\n\t\tthis._maxCharCode = maxCharCode;\n\t}\n\n\tpublic nextState(currentState: State, chCode: number): State {\n\t\tif (chCode < 0 || chCode >= this._maxCharCode) {\n\t\t\treturn State.Invalid;\n\t\t}\n\t\treturn this._states.get(currentState, chCode);\n\t}\n}\n\n// State machine for http:// or https:// or file://\nlet _stateMachine: StateMachine | null = null;\nfunction getStateMachine(): StateMachine {\n\tif (_stateMachine === null) {\n\t\t_stateMachine = new StateMachine([\n\t\t\t[State.Start, CharCode.h, State.H],\n\t\t\t[State.Start, CharCode.H, State.H],\n\t\t\t[State.Start, CharCode.f, State.F],\n\t\t\t[State.Start, CharCode.F, State.F],\n\n\t\t\t[State.H, CharCode.t, State.HT],\n\t\t\t[State.H, CharCode.T, State.HT],\n\n\t\t\t[State.HT, CharCode.t, State.HTT],\n\t\t\t[State.HT, CharCode.T, State.HTT],\n\n\t\t\t[State.HTT, CharCode.p, State.HTTP],\n\t\t\t[State.HTT, CharCode.P, State.HTTP],\n\n\t\t\t[State.HTTP, CharCode.s, State.BeforeColon],\n\t\t\t[State.HTTP, CharCode.S, State.BeforeColon],\n\t\t\t[State.HTTP, CharCode.Colon, State.AfterColon],\n\n\t\t\t[State.F, CharCode.i, State.FI],\n\t\t\t[State.F, CharCode.I, State.FI],\n\n\t\t\t[State.FI, CharCode.l, State.FIL],\n\t\t\t[State.FI, CharCode.L, State.FIL],\n\n\t\t\t[State.FIL, CharCode.e, State.BeforeColon],\n\t\t\t[State.FIL, CharCode.E, State.BeforeColon],\n\n\t\t\t[State.BeforeColon, CharCode.Colon, State.AfterColon],\n\n\t\t\t[State.AfterColon, CharCode.Slash, State.AlmostThere],\n\n\t\t\t[State.AlmostThere, CharCode.Slash, State.End],\n\t\t]);\n\t}\n\treturn _stateMachine;\n}\n\n\nconst enum CharacterClass {\n\tNone = 0,\n\tForceTermination = 1,\n\tCannotEndIn = 2\n}\n\nlet _classifier: CharacterClassifier<CharacterClass> | null = null;\nfunction getClassifier(): CharacterClassifier<CharacterClass> {\n\tif (_classifier === null) {\n\t\t_classifier = new CharacterClassifier<CharacterClass>(CharacterClass.None);\n\n\t\t// allow-any-unicode-next-line\n\t\tconst FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…|';\n\t\tfor (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n\t\t\t_classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\n\t\t}\n\n\t\tconst CANNOT_END_WITH_CHARACTERS = '.,;:';\n\t\tfor (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n\t\t\t_classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\n\t\t}\n\t}\n\treturn _classifier;\n}\n\nexport class LinkComputer {\n\n\tprivate static _createLink(classifier: CharacterClassifier<CharacterClass>, line: string, lineNumber: number, linkBeginIndex: number, linkEndIndex: number): ILink {\n\t\t// Do not allow to end link in certain characters...\n\t\tlet lastIncludedCharIndex = linkEndIndex - 1;\n\t\tdo {\n\t\t\tconst chCode = line.charCodeAt(lastIncludedCharIndex);\n\t\t\tconst chClass = classifier.get(chCode);\n\t\t\tif (chClass !== CharacterClass.CannotEndIn) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastIncludedCharIndex--;\n\t\t} while (lastIncludedCharIndex > linkBeginIndex);\n\n\t\t// Handle links enclosed in parens, square brackets and curlys.\n\t\tif (linkBeginIndex > 0) {\n\t\t\tconst charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n\t\t\tconst lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n\n\t\t\tif (\n\t\t\t\t(charCodeBeforeLink === CharCode.OpenParen && lastCharCodeInLink === CharCode.CloseParen)\n\t\t\t\t|| (charCodeBeforeLink === CharCode.OpenSquareBracket && lastCharCodeInLink === CharCode.CloseSquareBracket)\n\t\t\t\t|| (charCodeBeforeLink === CharCode.OpenCurlyBrace && lastCharCodeInLink === CharCode.CloseCurlyBrace)\n\t\t\t) {\n\t\t\t\t// Do not end in ) if ( is before the link start\n\t\t\t\t// Do not end in ] if [ is before the link start\n\t\t\t\t// Do not end in } if { is before the link start\n\t\t\t\tlastIncludedCharIndex--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trange: {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn: linkBeginIndex + 1,\n\t\t\t\tendLineNumber: lineNumber,\n\t\t\t\tendColumn: lastIncludedCharIndex + 2\n\t\t\t},\n\t\t\turl: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n\t\t};\n\t}\n\n\tpublic static computeLinks(model: ILinkComputerTarget, stateMachine: StateMachine = getStateMachine()): ILink[] {\n\t\tconst classifier = getClassifier();\n\n\t\tconst result: ILink[] = [];\n\t\tfor (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n\t\t\tconst line = model.getLineContent(i);\n\t\t\tconst len = line.length;\n\n\t\t\tlet j = 0;\n\t\t\tlet linkBeginIndex = 0;\n\t\t\tlet linkBeginChCode = 0;\n\t\t\tlet state = State.Start;\n\t\t\tlet hasOpenParens = false;\n\t\t\tlet hasOpenSquareBracket = false;\n\t\t\tlet inSquareBrackets = false;\n\t\t\tlet hasOpenCurlyBracket = false;\n\n\t\t\twhile (j < len) {\n\n\t\t\t\tlet resetStateMachine = false;\n\t\t\t\tconst chCode = line.charCodeAt(j);\n\n\t\t\t\tif (state === State.Accept) {\n\t\t\t\t\tlet chClass: CharacterClass;\n\t\t\t\t\tswitch (chCode) {\n\t\t\t\t\t\tcase CharCode.OpenParen:\n\t\t\t\t\t\t\thasOpenParens = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseParen:\n\t\t\t\t\t\t\tchClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.OpenSquareBracket:\n\t\t\t\t\t\t\tinSquareBrackets = true;\n\t\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseSquareBracket:\n\t\t\t\t\t\t\tinSquareBrackets = false;\n\t\t\t\t\t\t\tchClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.OpenCurlyBrace:\n\t\t\t\t\t\t\thasOpenCurlyBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseCurlyBrace:\n\t\t\t\t\t\t\tchClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// The following three rules make it that ' or \" or ` are allowed inside links\n\t\t\t\t\t\t// only if the link is wrapped by some other quote character\n\t\t\t\t\t\tcase CharCode.SingleQuote:\n\t\t\t\t\t\tcase CharCode.DoubleQuote:\n\t\t\t\t\t\tcase CharCode.BackTick:\n\t\t\t\t\t\t\tif (linkBeginChCode === chCode) {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.ForceTermination;\n\t\t\t\t\t\t\t} else if (linkBeginChCode === CharCode.SingleQuote || linkBeginChCode === CharCode.DoubleQuote || linkBeginChCode === CharCode.BackTick) {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.ForceTermination;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.Asterisk:\n\t\t\t\t\t\t\t// `*` terminates a link if the link began with `*`\n\t\t\t\t\t\t\tchClass = (linkBeginChCode === CharCode.Asterisk) ? CharacterClass.ForceTermination : CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\t\t// ` ` allow space in between [ and ]\n\t\t\t\t\t\t\tchClass = (inSquareBrackets ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tchClass = classifier.get(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresult.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (state === State.End) {\n\n\t\t\t\t\tlet chClass: CharacterClass;\n\t\t\t\t\tif (chCode === CharCode.OpenSquareBracket) {\n\t\t\t\t\t\t// Allow for the authority part to contain ipv6 addresses which contain [ and ]\n\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchClass = classifier.get(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = State.Accept;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate = stateMachine.nextState(state, chCode);\n\t\t\t\t\tif (state === State.Invalid) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resetStateMachine) {\n\t\t\t\t\tstate = State.Start;\n\t\t\t\t\thasOpenParens = false;\n\t\t\t\t\thasOpenSquareBracket = false;\n\t\t\t\t\thasOpenCurlyBracket = false;\n\n\t\t\t\t\t// Record where the link started\n\t\t\t\t\tlinkBeginIndex = j + 1;\n\t\t\t\t\tlinkBeginChCode = chCode;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (state === State.Accept) {\n\t\t\t\tresult.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model: ILinkComputerTarget | null): ILink[] {\n\tif (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { ILink } from '../languages.js';\n\nexport interface ILinkComputerTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport const enum State {\n\tInvalid = 0,\n\tStart = 1,\n\tH = 2,\n\tHT = 3,\n\tHTT = 4,\n\tHTTP = 5,\n\tF = 6,\n\tFI = 7,\n\tFIL = 8,\n\tBeforeColon = 9,\n\tAfterColon = 10,\n\tAlmostThere = 11,\n\tEnd = 12,\n\tAccept = 13,\n\tLastKnownState = 14 // marker, custom states may follow\n}\n\nexport type Edge = [State, number, State];\n\nclass Uint8Matrix {\n\n\tprivate readonly _data: Uint8Array;\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\tconstructor(rows: number, cols: number, defaultValue: number) {\n\t\tconst data = new Uint8Array(rows * cols);\n\t\tfor (let i = 0, len = rows * cols; i < len; i++) {\n\t\t\tdata[i] = defaultValue;\n\t\t}\n\n\t\tthis._data = data;\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t}\n\n\tpublic get(row: number, col: number): number {\n\t\treturn this._data[row * this.cols + col];\n\t}\n\n\tpublic set(row: number, col: number, value: number): void {\n\t\tthis._data[row * this.cols + col] = value;\n\t}\n}\n\nexport class StateMachine {\n\n\tprivate readonly _states: Uint8Matrix;\n\tprivate readonly _maxCharCode: number;\n\n\tconstructor(edges: Edge[]) {\n\t\tlet maxCharCode = 0;\n\t\tlet maxState = State.Invalid;\n\t\tfor (let i = 0, len = edges.length; i < len; i++) {\n\t\t\tconst [from, chCode, to] = edges[i];\n\t\t\tif (chCode > maxCharCode) {\n\t\t\t\tmaxCharCode = chCode;\n\t\t\t}\n\t\t\tif (from > maxState) {\n\t\t\t\tmaxState = from;\n\t\t\t}\n\t\t\tif (to > maxState) {\n\t\t\t\tmaxState = to;\n\t\t\t}\n\t\t}\n\n\t\tmaxCharCode++;\n\t\tmaxState++;\n\n\t\tconst states = new Uint8Matrix(maxState, maxCharCode, State.Invalid);\n\t\tfor (let i = 0, len = edges.length; i < len; i++) {\n\t\t\tconst [from, chCode, to] = edges[i];\n\t\t\tstates.set(from, chCode, to);\n\t\t}\n\n\t\tthis._states = states;\n\t\tthis._maxCharCode = maxCharCode;\n\t}\n\n\tpublic nextState(currentState: State, chCode: number): State {\n\t\tif (chCode < 0 || chCode >= this._maxCharCode) {\n\t\t\treturn State.Invalid;\n\t\t}\n\t\treturn this._states.get(currentState, chCode);\n\t}\n}\n\n// State machine for http:// or https:// or file://\nlet _stateMachine: StateMachine | null = null;\nfunction getStateMachine(): StateMachine {\n\tif (_stateMachine === null) {\n\t\t_stateMachine = new StateMachine([\n\t\t\t[State.Start, CharCode.h, State.H],\n\t\t\t[State.Start, CharCode.H, State.H],\n\t\t\t[State.Start, CharCode.f, State.F],\n\t\t\t[State.Start, CharCode.F, State.F],\n\n\t\t\t[State.H, CharCode.t, State.HT],\n\t\t\t[State.H, CharCode.T, State.HT],\n\n\t\t\t[State.HT, CharCode.t, State.HTT],\n\t\t\t[State.HT, CharCode.T, State.HTT],\n\n\t\t\t[State.HTT, CharCode.p, State.HTTP],\n\t\t\t[State.HTT, CharCode.P, State.HTTP],\n\n\t\t\t[State.HTTP, CharCode.s, State.BeforeColon],\n\t\t\t[State.HTTP, CharCode.S, State.BeforeColon],\n\t\t\t[State.HTTP, CharCode.Colon, State.AfterColon],\n\n\t\t\t[State.F, CharCode.i, State.FI],\n\t\t\t[State.F, CharCode.I, State.FI],\n\n\t\t\t[State.FI, CharCode.l, State.FIL],\n\t\t\t[State.FI, CharCode.L, State.FIL],\n\n\t\t\t[State.FIL, CharCode.e, State.BeforeColon],\n\t\t\t[State.FIL, CharCode.E, State.BeforeColon],\n\n\t\t\t[State.BeforeColon, CharCode.Colon, State.AfterColon],\n\n\t\t\t[State.AfterColon, CharCode.Slash, State.AlmostThere],\n\n\t\t\t[State.AlmostThere, CharCode.Slash, State.End],\n\t\t]);\n\t}\n\treturn _stateMachine;\n}\n\n\nconst enum CharacterClass {\n\tNone = 0,\n\tForceTermination = 1,\n\tCannotEndIn = 2\n}\n\nlet _classifier: CharacterClassifier<CharacterClass> | null = null;\nfunction getClassifier(): CharacterClassifier<CharacterClass> {\n\tif (_classifier === null) {\n\t\t_classifier = new CharacterClassifier<CharacterClass>(CharacterClass.None);\n\n\t\t// allow-any-unicode-next-line\n\t\tconst FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…|';\n\t\tfor (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n\t\t\t_classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\n\t\t}\n\n\t\tconst CANNOT_END_WITH_CHARACTERS = '.,;:';\n\t\tfor (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n\t\t\t_classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\n\t\t}\n\t}\n\treturn _classifier;\n}\n\nexport class LinkComputer {\n\n\tprivate static _createLink(classifier: CharacterClassifier<CharacterClass>, line: string, lineNumber: number, linkBeginIndex: number, linkEndIndex: number): ILink {\n\t\t// Do not allow to end link in certain characters...\n\t\tlet lastIncludedCharIndex = linkEndIndex - 1;\n\t\tdo {\n\t\t\tconst chCode = line.charCodeAt(lastIncludedCharIndex);\n\t\t\tconst chClass = classifier.get(chCode);\n\t\t\tif (chClass !== CharacterClass.CannotEndIn) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastIncludedCharIndex--;\n\t\t} while (lastIncludedCharIndex > linkBeginIndex);\n\n\t\t// Handle links enclosed in parens, square brackets and curlys.\n\t\tif (linkBeginIndex > 0) {\n\t\t\tconst charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n\t\t\tconst lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n\n\t\t\tif (\n\t\t\t\t(charCodeBeforeLink === CharCode.OpenParen && lastCharCodeInLink === CharCode.CloseParen)\n\t\t\t\t|| (charCodeBeforeLink === CharCode.OpenSquareBracket && lastCharCodeInLink === CharCode.CloseSquareBracket)\n\t\t\t\t|| (charCodeBeforeLink === CharCode.OpenCurlyBrace && lastCharCodeInLink === CharCode.CloseCurlyBrace)\n\t\t\t) {\n\t\t\t\t// Do not end in ) if ( is before the link start\n\t\t\t\t// Do not end in ] if [ is before the link start\n\t\t\t\t// Do not end in } if { is before the link start\n\t\t\t\tlastIncludedCharIndex--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trange: {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn: linkBeginIndex + 1,\n\t\t\t\tendLineNumber: lineNumber,\n\t\t\t\tendColumn: lastIncludedCharIndex + 2\n\t\t\t},\n\t\t\turl: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n\t\t};\n\t}\n\n\tpublic static computeLinks(model: ILinkComputerTarget, stateMachine: StateMachine = getStateMachine()): ILink[] {\n\t\tconst classifier = getClassifier();\n\n\t\tconst result: ILink[] = [];\n\t\tfor (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n\t\t\tconst line = model.getLineContent(i);\n\t\t\tconst len = line.length;\n\n\t\t\tlet j = 0;\n\t\t\tlet linkBeginIndex = 0;\n\t\t\tlet linkBeginChCode = 0;\n\t\t\tlet state = State.Start;\n\t\t\tlet hasOpenParens = false;\n\t\t\tlet hasOpenSquareBracket = false;\n\t\t\tlet inSquareBrackets = false;\n\t\t\tlet hasOpenCurlyBracket = false;\n\n\t\t\twhile (j < len) {\n\n\t\t\t\tlet resetStateMachine = false;\n\t\t\t\tconst chCode = line.charCodeAt(j);\n\n\t\t\t\tif (state === State.Accept) {\n\t\t\t\t\tlet chClass: CharacterClass;\n\t\t\t\t\tswitch (chCode) {\n\t\t\t\t\t\tcase CharCode.OpenParen:\n\t\t\t\t\t\t\thasOpenParens = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseParen:\n\t\t\t\t\t\t\tchClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.OpenSquareBracket:\n\t\t\t\t\t\t\tinSquareBrackets = true;\n\t\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseSquareBracket:\n\t\t\t\t\t\t\tinSquareBrackets = false;\n\t\t\t\t\t\t\tchClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.OpenCurlyBrace:\n\t\t\t\t\t\t\thasOpenCurlyBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.CloseCurlyBrace:\n\t\t\t\t\t\t\tchClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// The following three rules make it that ' or \" or ` are allowed inside links\n\t\t\t\t\t\t// only if the link is wrapped by some other quote character\n\t\t\t\t\t\tcase CharCode.SingleQuote:\n\t\t\t\t\t\tcase CharCode.DoubleQuote:\n\t\t\t\t\t\tcase CharCode.BackTick:\n\t\t\t\t\t\t\tif (linkBeginChCode === chCode) {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.ForceTermination;\n\t\t\t\t\t\t\t} else if (linkBeginChCode === CharCode.SingleQuote || linkBeginChCode === CharCode.DoubleQuote || linkBeginChCode === CharCode.BackTick) {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchClass = CharacterClass.ForceTermination;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.Asterisk:\n\t\t\t\t\t\t\t// `*` terminates a link if the link began with `*`\n\t\t\t\t\t\t\tchClass = (linkBeginChCode === CharCode.Asterisk) ? CharacterClass.ForceTermination : CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\t\t// ` ` allow space in between [ and ]\n\t\t\t\t\t\t\tchClass = (inSquareBrackets ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tchClass = classifier.get(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresult.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (state === State.End) {\n\n\t\t\t\t\tlet chClass: CharacterClass;\n\t\t\t\t\tif (chCode === CharCode.OpenSquareBracket) {\n\t\t\t\t\t\t// Allow for the authority part to contain ipv6 addresses which contain [ and ]\n\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchClass = classifier.get(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = State.Accept;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate = stateMachine.nextState(state, chCode);\n\t\t\t\t\tif (state === State.Invalid) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resetStateMachine) {\n\t\t\t\t\tstate = State.Start;\n\t\t\t\t\thasOpenParens = false;\n\t\t\t\t\thasOpenSquareBracket = false;\n\t\t\t\t\thasOpenCurlyBracket = false;\n\n\t\t\t\t\t// Record where the link started\n\t\t\t\t\tlinkBeginIndex = j + 1;\n\t\t\t\t\tlinkBeginChCode = chCode;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (state === State.Accept) {\n\t\t\t\tresult.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model: ILinkComputerTarget | null): ILink[] {\n\tif (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange } from '../../core/range.js';\nimport { IInplaceReplaceSupportResult } from '../../languages.js';\n\nexport class BasicInplaceReplace {\n\n\tpublic static readonly INSTANCE = new BasicInplaceReplace();\n\n\tpublic navigateValueSet(range1: IRange, text1: string, range2: IRange, text2: string | null, up: boolean): IInplaceReplaceSupportResult | null {\n\n\t\tif (range1 && text1) {\n\t\t\tconst result = this.doNavigateValueSet(text1, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range1,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (range2 && text2) {\n\t\t\tconst result = this.doNavigateValueSet(text2, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range2,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate doNavigateValueSet(text: string, up: boolean): string | null {\n\t\tconst numberResult = this.numberReplace(text, up);\n\t\tif (numberResult !== null) {\n\t\t\treturn numberResult;\n\t\t}\n\t\treturn this.textReplace(text, up);\n\t}\n\n\tprivate numberReplace(value: string, up: boolean): string | null {\n\t\tconst precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n\t\tlet n1 = Number(value);\n\t\tconst n2 = parseFloat(value);\n\n\t\tif (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n\n\t\t\tif (n1 === 0 && !up) {\n\t\t\t\treturn null; // don't do negative\n\t\t\t\t//\t\t\t} else if(n1 === 9 && up) {\n\t\t\t\t//\t\t\t\treturn null; // don't insert 10 into a number\n\t\t\t} else {\n\t\t\t\tn1 = Math.floor(n1 * precision);\n\t\t\t\tn1 += up ? precision : -precision;\n\t\t\t\treturn String(n1 / precision);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate readonly _defaultValueSet: string[][] = [\n\t\t['true', 'false'],\n\t\t['True', 'False'],\n\t\t['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n\t\t['public', 'protected', 'private'],\n\t];\n\n\tprivate textReplace(value: string, up: boolean): string | null {\n\t\treturn this.valueSetsReplace(this._defaultValueSet, value, up);\n\t}\n\n\tprivate valueSetsReplace(valueSets: string[][], value: string, up: boolean): string | null {\n\t\tlet result: string | null = null;\n\t\tfor (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n\t\t\tresult = this.valueSetReplace(valueSets[i], value, up);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate valueSetReplace(valueSet: string[], value: string, up: boolean): string | null {\n\t\tlet idx = valueSet.indexOf(value);\n\t\tif (idx >= 0) {\n\t\t\tidx += up ? +1 : -1;\n\t\t\tif (idx < 0) {\n\t\t\t\tidx = valueSet.length - 1;\n\t\t\t} else {\n\t\t\t\tidx %= valueSet.length;\n\t\t\t}\n\t\t\treturn valueSet[idx];\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange } from '../../core/range.js';\nimport { IInplaceReplaceSupportResult } from '../../languages.js';\n\nexport class BasicInplaceReplace {\n\n\tpublic static readonly INSTANCE = new BasicInplaceReplace();\n\n\tpublic navigateValueSet(range1: IRange, text1: string, range2: IRange, text2: string | null, up: boolean): IInplaceReplaceSupportResult | null {\n\n\t\tif (range1 && text1) {\n\t\t\tconst result = this.doNavigateValueSet(text1, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range1,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (range2 && text2) {\n\t\t\tconst result = this.doNavigateValueSet(text2, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range2,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate doNavigateValueSet(text: string, up: boolean): string | null {\n\t\tconst numberResult = this.numberReplace(text, up);\n\t\tif (numberResult !== null) {\n\t\t\treturn numberResult;\n\t\t}\n\t\treturn this.textReplace(text, up);\n\t}\n\n\tprivate numberReplace(value: string, up: boolean): string | null {\n\t\tconst precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n\t\tlet n1 = Number(value);\n\t\tconst n2 = parseFloat(value);\n\n\t\tif (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n\n\t\t\tif (n1 === 0 && !up) {\n\t\t\t\treturn null; // don't do negative\n\t\t\t\t//\t\t\t} else if(n1 === 9 && up) {\n\t\t\t\t//\t\t\t\treturn null; // don't insert 10 into a number\n\t\t\t} else {\n\t\t\t\tn1 = Math.floor(n1 * precision);\n\t\t\t\tn1 += up ? precision : -precision;\n\t\t\t\treturn String(n1 / precision);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate readonly _defaultValueSet: string[][] = [\n\t\t['true', 'false'],\n\t\t['True', 'False'],\n\t\t['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n\t\t['public', 'protected', 'private'],\n\t];\n\n\tprivate textReplace(value: string, up: boolean): string | null {\n\t\treturn this.valueSetsReplace(this._defaultValueSet, value, up);\n\t}\n\n\tprivate valueSetsReplace(valueSets: string[][], value: string, up: boolean): string | null {\n\t\tlet result: string | null = null;\n\t\tfor (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n\t\t\tresult = this.valueSetReplace(valueSets[i], value, up);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate valueSetReplace(valueSet: string[], value: string, up: boolean): string | null {\n\t\tlet idx = valueSet.indexOf(value);\n\t\tif (idx >= 0) {\n\t\t\tidx += up ? +1 : -1;\n\t\t\tif (idx < 0) {\n\t\t\t\tidx = valueSet.length - 1;\n\t\t\t} else {\n\t\t\t\tidx %= valueSet.length;\n\t\t\t}\n\t\t\treturn valueSet[idx];\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport const enum KeyCode {\n\tDependsOnKbLayout = -1,\n\n\t/**\n\t * Placed first to cover the 0 value of the enum.\n\t */\n\tUnknown = 0,\n\n\tBackspace,\n\tTab,\n\tEnter,\n\tShift,\n\tCtrl,\n\tAlt,\n\tPauseBreak,\n\tCapsLock,\n\tEscape,\n\tSpace,\n\tPageUp,\n\tPageDown,\n\tEnd,\n\tHome,\n\tLeftArrow,\n\tUpArrow,\n\tRightArrow,\n\tDownArrow,\n\tInsert,\n\tDelete,\n\n\tDigit0,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\n\tMeta,\n\tContextMenu,\n\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\n\tNumLock,\n\tScrollLock,\n\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ';:' key\n\t */\n\tSemicolon,\n\t/**\n\t * For any country/region, the '+' key\n\t * For the US standard keyboard, the '=+' key\n\t */\n\tEqual,\n\t/**\n\t * For any country/region, the ',' key\n\t * For the US standard keyboard, the ',<' key\n\t */\n\tComma,\n\t/**\n\t * For any country/region, the '-' key\n\t * For the US standard keyboard, the '-_' key\n\t */\n\tMinus,\n\t/**\n\t * For any country/region, the '.' key\n\t * For the US standard keyboard, the '.>' key\n\t */\n\tPeriod,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '/?' key\n\t */\n\tSlash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '`~' key\n\t */\n\tBackquote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '[{' key\n\t */\n\tBracketLeft,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '\\|' key\n\t */\n\tBackslash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ']}' key\n\t */\n\tBracketRight,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ''\"' key\n\t */\n\tQuote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t */\n\tOEM_8,\n\t/**\n\t * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n\t */\n\tIntlBackslash,\n\n\tNumpad0, // VK_NUMPAD0, 0x60, Numeric keypad 0 key\n\tNumpad1, // VK_NUMPAD1, 0x61, Numeric keypad 1 key\n\tNumpad2, // VK_NUMPAD2, 0x62, Numeric keypad 2 key\n\tNumpad3, // VK_NUMPAD3, 0x63, Numeric keypad 3 key\n\tNumpad4, // VK_NUMPAD4, 0x64, Numeric keypad 4 key\n\tNumpad5, // VK_NUMPAD5, 0x65, Numeric keypad 5 key\n\tNumpad6, // VK_NUMPAD6, 0x66, Numeric keypad 6 key\n\tNumpad7, // VK_NUMPAD7, 0x67, Numeric keypad 7 key\n\tNumpad8, // VK_NUMPAD8, 0x68, Numeric keypad 8 key\n\tNumpad9, // VK_NUMPAD9, 0x69, Numeric keypad 9 key\n\n\tNumpadMultiply,\t// VK_MULTIPLY, 0x6A, Multiply key\n\tNumpadAdd,\t\t// VK_ADD, 0x6B, Add key\n\tNUMPAD_SEPARATOR,\t// VK_SEPARATOR, 0x6C, Separator key\n\tNumpadSubtract,\t// VK_SUBTRACT, 0x6D, Subtract key\n\tNumpadDecimal,\t// VK_DECIMAL, 0x6E, Decimal key\n\tNumpadDivide,\t// VK_DIVIDE, 0x6F,\n\n\t/**\n\t * Cover all key codes when IME is processing input.\n\t */\n\tKEY_IN_COMPOSITION,\n\n\tABNT_C1, // Brazilian (ABNT) Keyboard\n\tABNT_C2, // Brazilian (ABNT) Keyboard\n\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tMediaPlayPause,\n\tLaunchMediaPlayer,\n\tLaunchMail,\n\tLaunchApp2,\n\n\t/**\n\t * VK_CLEAR, 0x0C, CLEAR key\n\t */\n\tClear,\n\n\t/**\n\t * Placed last to cover the length of the enum.\n\t * Please do not depend on this value!\n\t */\n\tMAX_VALUE\n}\n\n/**\n * keyboardEvent.code\n */\nexport const enum ScanCode {\n\tDependsOnKbLayout = -1,\n\tNone,\n\tHyper,\n\tSuper,\n\tFn,\n\tFnLock,\n\tSuspend,\n\tResume,\n\tTurbo,\n\tSleep,\n\tWakeUp,\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\tDigit0,\n\tEnter,\n\tEscape,\n\tBackspace,\n\tTab,\n\tSpace,\n\tMinus,\n\tEqual,\n\tBracketLeft,\n\tBracketRight,\n\tBackslash,\n\tIntlHash,\n\tSemicolon,\n\tQuote,\n\tBackquote,\n\tComma,\n\tPeriod,\n\tSlash,\n\tCapsLock,\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tPrintScreen,\n\tScrollLock,\n\tPause,\n\tInsert,\n\tHome,\n\tPageUp,\n\tDelete,\n\tEnd,\n\tPageDown,\n\tArrowRight,\n\tArrowLeft,\n\tArrowDown,\n\tArrowUp,\n\tNumLock,\n\tNumpadDivide,\n\tNumpadMultiply,\n\tNumpadSubtract,\n\tNumpadAdd,\n\tNumpadEnter,\n\tNumpad1,\n\tNumpad2,\n\tNumpad3,\n\tNumpad4,\n\tNumpad5,\n\tNumpad6,\n\tNumpad7,\n\tNumpad8,\n\tNumpad9,\n\tNumpad0,\n\tNumpadDecimal,\n\tIntlBackslash,\n\tContextMenu,\n\tPower,\n\tNumpadEqual,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\tOpen,\n\tHelp,\n\tSelect,\n\tAgain,\n\tUndo,\n\tCut,\n\tCopy,\n\tPaste,\n\tFind,\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\tNumpadComma,\n\tIntlRo,\n\tKanaMode,\n\tIntlYen,\n\tConvert,\n\tNonConvert,\n\tLang1,\n\tLang2,\n\tLang3,\n\tLang4,\n\tLang5,\n\tAbort,\n\tProps,\n\tNumpadParenLeft,\n\tNumpadParenRight,\n\tNumpadBackspace,\n\tNumpadMemoryStore,\n\tNumpadMemoryRecall,\n\tNumpadMemoryClear,\n\tNumpadMemoryAdd,\n\tNumpadMemorySubtract,\n\tNumpadClear,\n\tNumpadClearEntry,\n\tControlLeft,\n\tShiftLeft,\n\tAltLeft,\n\tMetaLeft,\n\tControlRight,\n\tShiftRight,\n\tAltRight,\n\tMetaRight,\n\tBrightnessUp,\n\tBrightnessDown,\n\tMediaPlay,\n\tMediaRecord,\n\tMediaFastForward,\n\tMediaRewind,\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tEject,\n\tMediaPlayPause,\n\tMediaSelect,\n\tLaunchMail,\n\tLaunchApp2,\n\tLaunchApp1,\n\tSelectTask,\n\tLaunchScreenSaver,\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\tBrowserStop,\n\tBrowserRefresh,\n\tBrowserFavorites,\n\tZoomToggle,\n\tMailReply,\n\tMailForward,\n\tMailSend,\n\n\tMAX_VALUE\n}\n\nclass KeyCodeStrMap {\n\n\tpublic _keyCodeToStr: string[];\n\tpublic _strToKeyCode: { [str: string]: KeyCode };\n\n\tconstructor() {\n\t\tthis._keyCodeToStr = [];\n\t\tthis._strToKeyCode = Object.create(null);\n\t}\n\n\tdefine(keyCode: KeyCode, str: string): void {\n\t\tthis._keyCodeToStr[keyCode] = str;\n\t\tthis._strToKeyCode[str.toLowerCase()] = keyCode;\n\t}\n\n\tkeyCodeToStr(keyCode: KeyCode): string {\n\t\treturn this._keyCodeToStr[keyCode];\n\t}\n\n\tstrToKeyCode(str: string): KeyCode {\n\t\treturn this._strToKeyCode[str.toLowerCase()] || KeyCode.Unknown;\n\t}\n}\n\nconst uiMap = new KeyCodeStrMap();\nconst userSettingsUSMap = new KeyCodeStrMap();\nconst userSettingsGeneralMap = new KeyCodeStrMap();\nexport const EVENT_KEY_CODE_MAP: { [keyCode: number]: KeyCode } = new Array(230);\nexport const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE: { [nativeKeyCode: string]: KeyCode } = {};\nconst scanCodeIntToStr: string[] = [];\nconst scanCodeStrToInt: { [code: string]: number } = Object.create(null);\nconst scanCodeLowerCaseStrToInt: { [code: string]: number } = Object.create(null);\n\nexport const ScanCodeUtils = {\n\tlowerCaseToEnum: (scanCode: string) => scanCodeLowerCaseStrToInt[scanCode] || ScanCode.None,\n\ttoEnum: (scanCode: string) => scanCodeStrToInt[scanCode] || ScanCode.None,\n\ttoString: (scanCode: ScanCode) => scanCodeIntToStr[scanCode] || 'None'\n};\n\n/**\n * -1 if a ScanCode => KeyCode mapping depends on kb layout.\n */\nexport const IMMUTABLE_CODE_TO_KEY_CODE: KeyCode[] = [];\n\n/**\n * -1 if a KeyCode => ScanCode mapping depends on kb layout.\n */\nexport const IMMUTABLE_KEY_CODE_TO_CODE: ScanCode[] = [];\n\nfor (let i = 0; i <= ScanCode.MAX_VALUE; i++) {\n\tIMMUTABLE_CODE_TO_KEY_CODE[i] = KeyCode.DependsOnKbLayout;\n}\n\nfor (let i = 0; i <= KeyCode.MAX_VALUE; i++) {\n\tIMMUTABLE_KEY_CODE_TO_CODE[i] = ScanCode.DependsOnKbLayout;\n}\n\n(function () {\n\n\t// See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n\t// See https://github.com/microsoft/node-native-keymap/blob/88c0b0e5/deps/chromium/keyboard_codes_win.h\n\n\tconst empty = '';\n\ttype IMappingEntry = [0 | 1, ScanCode, string, KeyCode, string, number, string, string, string];\n\tconst mappings: IMappingEntry[] = [\n\t\t// immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\n\t\t[1, ScanCode.None, 'None', KeyCode.Unknown, 'unknown', 0, 'VK_UNKNOWN', empty, empty],\n\t\t[1, ScanCode.Hyper, 'Hyper', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Super, 'Super', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Fn, 'Fn', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.FnLock, 'FnLock', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Suspend, 'Suspend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Resume, 'Resume', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Turbo, 'Turbo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Sleep, 'Sleep', KeyCode.Unknown, empty, 0, 'VK_SLEEP', empty, empty],\n\t\t[1, ScanCode.WakeUp, 'WakeUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[0, ScanCode.KeyA, 'KeyA', KeyCode.KeyA, 'A', 65, 'VK_A', empty, empty],\n\t\t[0, ScanCode.KeyB, 'KeyB', KeyCode.KeyB, 'B', 66, 'VK_B', empty, empty],\n\t\t[0, ScanCode.KeyC, 'KeyC', KeyCode.KeyC, 'C', 67, 'VK_C', empty, empty],\n\t\t[0, ScanCode.KeyD, 'KeyD', KeyCode.KeyD, 'D', 68, 'VK_D', empty, empty],\n\t\t[0, ScanCode.KeyE, 'KeyE', KeyCode.KeyE, 'E', 69, 'VK_E', empty, empty],\n\t\t[0, ScanCode.KeyF, 'KeyF', KeyCode.KeyF, 'F', 70, 'VK_F', empty, empty],\n\t\t[0, ScanCode.KeyG, 'KeyG', KeyCode.KeyG, 'G', 71, 'VK_G', empty, empty],\n\t\t[0, ScanCode.KeyH, 'KeyH', KeyCode.KeyH, 'H', 72, 'VK_H', empty, empty],\n\t\t[0, ScanCode.KeyI, 'KeyI', KeyCode.KeyI, 'I', 73, 'VK_I', empty, empty],\n\t\t[0, ScanCode.KeyJ, 'KeyJ', KeyCode.KeyJ, 'J', 74, 'VK_J', empty, empty],\n\t\t[0, ScanCode.KeyK, 'KeyK', KeyCode.KeyK, 'K', 75, 'VK_K', empty, empty],\n\t\t[0, ScanCode.KeyL, 'KeyL', KeyCode.KeyL, 'L', 76, 'VK_L', empty, empty],\n\t\t[0, ScanCode.KeyM, 'KeyM', KeyCode.KeyM, 'M', 77, 'VK_M', empty, empty],\n\t\t[0, ScanCode.KeyN, 'KeyN', KeyCode.KeyN, 'N', 78, 'VK_N', empty, empty],\n\t\t[0, ScanCode.KeyO, 'KeyO', KeyCode.KeyO, 'O', 79, 'VK_O', empty, empty],\n\t\t[0, ScanCode.KeyP, 'KeyP', KeyCode.KeyP, 'P', 80, 'VK_P', empty, empty],\n\t\t[0, ScanCode.KeyQ, 'KeyQ', KeyCode.KeyQ, 'Q', 81, 'VK_Q', empty, empty],\n\t\t[0, ScanCode.KeyR, 'KeyR', KeyCode.KeyR, 'R', 82, 'VK_R', empty, empty],\n\t\t[0, ScanCode.KeyS, 'KeyS', KeyCode.KeyS, 'S', 83, 'VK_S', empty, empty],\n\t\t[0, ScanCode.KeyT, 'KeyT', KeyCode.KeyT, 'T', 84, 'VK_T', empty, empty],\n\t\t[0, ScanCode.KeyU, 'KeyU', KeyCode.KeyU, 'U', 85, 'VK_U', empty, empty],\n\t\t[0, ScanCode.KeyV, 'KeyV', KeyCode.KeyV, 'V', 86, 'VK_V', empty, empty],\n\t\t[0, ScanCode.KeyW, 'KeyW', KeyCode.KeyW, 'W', 87, 'VK_W', empty, empty],\n\t\t[0, ScanCode.KeyX, 'KeyX', KeyCode.KeyX, 'X', 88, 'VK_X', empty, empty],\n\t\t[0, ScanCode.KeyY, 'KeyY', KeyCode.KeyY, 'Y', 89, 'VK_Y', empty, empty],\n\t\t[0, ScanCode.KeyZ, 'KeyZ', KeyCode.KeyZ, 'Z', 90, 'VK_Z', empty, empty],\n\t\t[0, ScanCode.Digit1, 'Digit1', KeyCode.Digit1, '1', 49, 'VK_1', empty, empty],\n\t\t[0, ScanCode.Digit2, 'Digit2', KeyCode.Digit2, '2', 50, 'VK_2', empty, empty],\n\t\t[0, ScanCode.Digit3, 'Digit3', KeyCode.Digit3, '3', 51, 'VK_3', empty, empty],\n\t\t[0, ScanCode.Digit4, 'Digit4', KeyCode.Digit4, '4', 52, 'VK_4', empty, empty],\n\t\t[0, ScanCode.Digit5, 'Digit5', KeyCode.Digit5, '5', 53, 'VK_5', empty, empty],\n\t\t[0, ScanCode.Digit6, 'Digit6', KeyCode.Digit6, '6', 54, 'VK_6', empty, empty],\n\t\t[0, ScanCode.Digit7, 'Digit7', KeyCode.Digit7, '7', 55, 'VK_7', empty, empty],\n\t\t[0, ScanCode.Digit8, 'Digit8', KeyCode.Digit8, '8', 56, 'VK_8', empty, empty],\n\t\t[0, ScanCode.Digit9, 'Digit9', KeyCode.Digit9, '9', 57, 'VK_9', empty, empty],\n\t\t[0, ScanCode.Digit0, 'Digit0', KeyCode.Digit0, '0', 48, 'VK_0', empty, empty],\n\t\t[1, ScanCode.Enter, 'Enter', KeyCode.Enter, 'Enter', 13, 'VK_RETURN', empty, empty],\n\t\t[1, ScanCode.Escape, 'Escape', KeyCode.Escape, 'Escape', 27, 'VK_ESCAPE', empty, empty],\n\t\t[1, ScanCode.Backspace, 'Backspace', KeyCode.Backspace, 'Backspace', 8, 'VK_BACK', empty, empty],\n\t\t[1, ScanCode.Tab, 'Tab', KeyCode.Tab, 'Tab', 9, 'VK_TAB', empty, empty],\n\t\t[1, ScanCode.Space, 'Space', KeyCode.Space, 'Space', 32, 'VK_SPACE', empty, empty],\n\t\t[0, ScanCode.Minus, 'Minus', KeyCode.Minus, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],\n\t\t[0, ScanCode.Equal, 'Equal', KeyCode.Equal, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],\n\t\t[0, ScanCode.BracketLeft, 'BracketLeft', KeyCode.BracketLeft, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],\n\t\t[0, ScanCode.BracketRight, 'BracketRight', KeyCode.BracketRight, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],\n\t\t[0, ScanCode.Backslash, 'Backslash', KeyCode.Backslash, '\\\\', 220, 'VK_OEM_5', '\\\\', 'OEM_5'],\n\t\t[0, ScanCode.IntlHash, 'IntlHash', KeyCode.Unknown, empty, 0, empty, empty, empty], // has been dropped from the w3c spec\n\t\t[0, ScanCode.Semicolon, 'Semicolon', KeyCode.Semicolon, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],\n\t\t[0, ScanCode.Quote, 'Quote', KeyCode.Quote, '\\'', 222, 'VK_OEM_7', '\\'', 'OEM_7'],\n\t\t[0, ScanCode.Backquote, 'Backquote', KeyCode.Backquote, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],\n\t\t[0, ScanCode.Comma, 'Comma', KeyCode.Comma, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],\n\t\t[0, ScanCode.Period, 'Period', KeyCode.Period, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],\n\t\t[0, ScanCode.Slash, 'Slash', KeyCode.Slash, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],\n\t\t[1, ScanCode.CapsLock, 'CapsLock', KeyCode.CapsLock, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],\n\t\t[1, ScanCode.F1, 'F1', KeyCode.F1, 'F1', 112, 'VK_F1', empty, empty],\n\t\t[1, ScanCode.F2, 'F2', KeyCode.F2, 'F2', 113, 'VK_F2', empty, empty],\n\t\t[1, ScanCode.F3, 'F3', KeyCode.F3, 'F3', 114, 'VK_F3', empty, empty],\n\t\t[1, ScanCode.F4, 'F4', KeyCode.F4, 'F4', 115, 'VK_F4', empty, empty],\n\t\t[1, ScanCode.F5, 'F5', KeyCode.F5, 'F5', 116, 'VK_F5', empty, empty],\n\t\t[1, ScanCode.F6, 'F6', KeyCode.F6, 'F6', 117, 'VK_F6', empty, empty],\n\t\t[1, ScanCode.F7, 'F7', KeyCode.F7, 'F7', 118, 'VK_F7', empty, empty],\n\t\t[1, ScanCode.F8, 'F8', KeyCode.F8, 'F8', 119, 'VK_F8', empty, empty],\n\t\t[1, ScanCode.F9, 'F9', KeyCode.F9, 'F9', 120, 'VK_F9', empty, empty],\n\t\t[1, ScanCode.F10, 'F10', KeyCode.F10, 'F10', 121, 'VK_F10', empty, empty],\n\t\t[1, ScanCode.F11, 'F11', KeyCode.F11, 'F11', 122, 'VK_F11', empty, empty],\n\t\t[1, ScanCode.F12, 'F12', KeyCode.F12, 'F12', 123, 'VK_F12', empty, empty],\n\t\t[1, ScanCode.PrintScreen, 'PrintScreen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.ScrollLock, 'ScrollLock', KeyCode.ScrollLock, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],\n\t\t[1, ScanCode.Pause, 'Pause', KeyCode.PauseBreak, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],\n\t\t[1, ScanCode.Insert, 'Insert', KeyCode.Insert, 'Insert', 45, 'VK_INSERT', empty, empty],\n\t\t[1, ScanCode.Home, 'Home', KeyCode.Home, 'Home', 36, 'VK_HOME', empty, empty],\n\t\t[1, ScanCode.PageUp, 'PageUp', KeyCode.PageUp, 'PageUp', 33, 'VK_PRIOR', empty, empty],\n\t\t[1, ScanCode.Delete, 'Delete', KeyCode.Delete, 'Delete', 46, 'VK_DELETE', empty, empty],\n\t\t[1, ScanCode.End, 'End', KeyCode.End, 'End', 35, 'VK_END', empty, empty],\n\t\t[1, ScanCode.PageDown, 'PageDown', KeyCode.PageDown, 'PageDown', 34, 'VK_NEXT', empty, empty],\n\t\t[1, ScanCode.ArrowRight, 'ArrowRight', KeyCode.RightArrow, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],\n\t\t[1, ScanCode.ArrowLeft, 'ArrowLeft', KeyCode.LeftArrow, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],\n\t\t[1, ScanCode.ArrowDown, 'ArrowDown', KeyCode.DownArrow, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],\n\t\t[1, ScanCode.ArrowUp, 'ArrowUp', KeyCode.UpArrow, 'UpArrow', 38, 'VK_UP', 'Up', empty],\n\t\t[1, ScanCode.NumLock, 'NumLock', KeyCode.NumLock, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],\n\t\t[1, ScanCode.NumpadDivide, 'NumpadDivide', KeyCode.NumpadDivide, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],\n\t\t[1, ScanCode.NumpadMultiply, 'NumpadMultiply', KeyCode.NumpadMultiply, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],\n\t\t[1, ScanCode.NumpadSubtract, 'NumpadSubtract', KeyCode.NumpadSubtract, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],\n\t\t[1, ScanCode.NumpadAdd, 'NumpadAdd', KeyCode.NumpadAdd, 'NumPad_Add', 107, 'VK_ADD', empty, empty],\n\t\t[1, ScanCode.NumpadEnter, 'NumpadEnter', KeyCode.Enter, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Numpad1, 'Numpad1', KeyCode.Numpad1, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],\n\t\t[1, ScanCode.Numpad2, 'Numpad2', KeyCode.Numpad2, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],\n\t\t[1, ScanCode.Numpad3, 'Numpad3', KeyCode.Numpad3, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],\n\t\t[1, ScanCode.Numpad4, 'Numpad4', KeyCode.Numpad4, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],\n\t\t[1, ScanCode.Numpad5, 'Numpad5', KeyCode.Numpad5, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],\n\t\t[1, ScanCode.Numpad6, 'Numpad6', KeyCode.Numpad6, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],\n\t\t[1, ScanCode.Numpad7, 'Numpad7', KeyCode.Numpad7, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],\n\t\t[1, ScanCode.Numpad8, 'Numpad8', KeyCode.Numpad8, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],\n\t\t[1, ScanCode.Numpad9, 'Numpad9', KeyCode.Numpad9, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],\n\t\t[1, ScanCode.Numpad0, 'Numpad0', KeyCode.Numpad0, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],\n\t\t[1, ScanCode.NumpadDecimal, 'NumpadDecimal', KeyCode.NumpadDecimal, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],\n\t\t[0, ScanCode.IntlBackslash, 'IntlBackslash', KeyCode.IntlBackslash, 'OEM_102', 226, 'VK_OEM_102', empty, empty],\n\t\t[1, ScanCode.ContextMenu, 'ContextMenu', KeyCode.ContextMenu, 'ContextMenu', 93, empty, empty, empty],\n\t\t[1, ScanCode.Power, 'Power', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadEqual, 'NumpadEqual', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.F13, 'F13', KeyCode.F13, 'F13', 124, 'VK_F13', empty, empty],\n\t\t[1, ScanCode.F14, 'F14', KeyCode.F14, 'F14', 125, 'VK_F14', empty, empty],\n\t\t[1, ScanCode.F15, 'F15', KeyCode.F15, 'F15', 126, 'VK_F15', empty, empty],\n\t\t[1, ScanCode.F16, 'F16', KeyCode.F16, 'F16', 127, 'VK_F16', empty, empty],\n\t\t[1, ScanCode.F17, 'F17', KeyCode.F17, 'F17', 128, 'VK_F17', empty, empty],\n\t\t[1, ScanCode.F18, 'F18', KeyCode.F18, 'F18', 129, 'VK_F18', empty, empty],\n\t\t[1, ScanCode.F19, 'F19', KeyCode.F19, 'F19', 130, 'VK_F19', empty, empty],\n\t\t[1, ScanCode.F20, 'F20', KeyCode.F20, 'F20', 131, 'VK_F20', empty, empty],\n\t\t[1, ScanCode.F21, 'F21', KeyCode.F21, 'F21', 132, 'VK_F21', empty, empty],\n\t\t[1, ScanCode.F22, 'F22', KeyCode.F22, 'F22', 133, 'VK_F22', empty, empty],\n\t\t[1, ScanCode.F23, 'F23', KeyCode.F23, 'F23', 134, 'VK_F23', empty, empty],\n\t\t[1, ScanCode.F24, 'F24', KeyCode.F24, 'F24', 135, 'VK_F24', empty, empty],\n\t\t[1, ScanCode.Open, 'Open', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Help, 'Help', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Select, 'Select', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Again, 'Again', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Undo, 'Undo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Cut, 'Cut', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Copy, 'Copy', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Paste, 'Paste', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Find, 'Find', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.AudioVolumeMute, 'AudioVolumeMute', KeyCode.AudioVolumeMute, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],\n\t\t[1, ScanCode.AudioVolumeUp, 'AudioVolumeUp', KeyCode.AudioVolumeUp, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],\n\t\t[1, ScanCode.AudioVolumeDown, 'AudioVolumeDown', KeyCode.AudioVolumeDown, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],\n\t\t[1, ScanCode.NumpadComma, 'NumpadComma', KeyCode.NUMPAD_SEPARATOR, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],\n\t\t[0, ScanCode.IntlRo, 'IntlRo', KeyCode.ABNT_C1, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],\n\t\t[1, ScanCode.KanaMode, 'KanaMode', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[0, ScanCode.IntlYen, 'IntlYen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Convert, 'Convert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NonConvert, 'NonConvert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang1, 'Lang1', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang2, 'Lang2', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang3, 'Lang3', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang4, 'Lang4', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang5, 'Lang5', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Abort, 'Abort', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Props, 'Props', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadParenLeft, 'NumpadParenLeft', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadParenRight, 'NumpadParenRight', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadBackspace, 'NumpadBackspace', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryStore, 'NumpadMemoryStore', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryRecall, 'NumpadMemoryRecall', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryClear, 'NumpadMemoryClear', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryAdd, 'NumpadMemoryAdd', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemorySubtract, 'NumpadMemorySubtract', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadClear, 'NumpadClear', KeyCode.Clear, 'Clear', 12, 'VK_CLEAR', empty, empty],\n\t\t[1, ScanCode.NumpadClearEntry, 'NumpadClearEntry', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Ctrl, 'Ctrl', 17, 'VK_CONTROL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Shift, 'Shift', 16, 'VK_SHIFT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Alt, 'Alt', 18, 'VK_MENU', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Meta, 'Meta', 91, 'VK_COMMAND', empty, empty],\n\t\t[1, ScanCode.ControlLeft, 'ControlLeft', KeyCode.Ctrl, empty, 0, 'VK_LCONTROL', empty, empty],\n\t\t[1, ScanCode.ShiftLeft, 'ShiftLeft', KeyCode.Shift, empty, 0, 'VK_LSHIFT', empty, empty],\n\t\t[1, ScanCode.AltLeft, 'AltLeft', KeyCode.Alt, empty, 0, 'VK_LMENU', empty, empty],\n\t\t[1, ScanCode.MetaLeft, 'MetaLeft', KeyCode.Meta, empty, 0, 'VK_LWIN', empty, empty],\n\t\t[1, ScanCode.ControlRight, 'ControlRight', KeyCode.Ctrl, empty, 0, 'VK_RCONTROL', empty, empty],\n\t\t[1, ScanCode.ShiftRight, 'ShiftRight', KeyCode.Shift, empty, 0, 'VK_RSHIFT', empty, empty],\n\t\t[1, ScanCode.AltRight, 'AltRight', KeyCode.Alt, empty, 0, 'VK_RMENU', empty, empty],\n\t\t[1, ScanCode.MetaRight, 'MetaRight', KeyCode.Meta, empty, 0, 'VK_RWIN', empty, empty],\n\t\t[1, ScanCode.BrightnessUp, 'BrightnessUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.BrightnessDown, 'BrightnessDown', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaPlay, 'MediaPlay', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaRecord, 'MediaRecord', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaFastForward, 'MediaFastForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaRewind, 'MediaRewind', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaTrackNext, 'MediaTrackNext', KeyCode.MediaTrackNext, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],\n\t\t[1, ScanCode.MediaTrackPrevious, 'MediaTrackPrevious', KeyCode.MediaTrackPrevious, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],\n\t\t[1, ScanCode.MediaStop, 'MediaStop', KeyCode.MediaStop, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],\n\t\t[1, ScanCode.Eject, 'Eject', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaPlayPause, 'MediaPlayPause', KeyCode.MediaPlayPause, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],\n\t\t[1, ScanCode.MediaSelect, 'MediaSelect', KeyCode.LaunchMediaPlayer, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],\n\t\t[1, ScanCode.LaunchMail, 'LaunchMail', KeyCode.LaunchMail, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],\n\t\t[1, ScanCode.LaunchApp2, 'LaunchApp2', KeyCode.LaunchApp2, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],\n\t\t[1, ScanCode.LaunchApp1, 'LaunchApp1', KeyCode.Unknown, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],\n\t\t[1, ScanCode.SelectTask, 'SelectTask', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.LaunchScreenSaver, 'LaunchScreenSaver', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.BrowserSearch, 'BrowserSearch', KeyCode.BrowserSearch, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],\n\t\t[1, ScanCode.BrowserHome, 'BrowserHome', KeyCode.BrowserHome, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],\n\t\t[1, ScanCode.BrowserBack, 'BrowserBack', KeyCode.BrowserBack, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],\n\t\t[1, ScanCode.BrowserForward, 'BrowserForward', KeyCode.BrowserForward, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],\n\t\t[1, ScanCode.BrowserStop, 'BrowserStop', KeyCode.Unknown, empty, 0, 'VK_BROWSER_STOP', empty, empty],\n\t\t[1, ScanCode.BrowserRefresh, 'BrowserRefresh', KeyCode.Unknown, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],\n\t\t[1, ScanCode.BrowserFavorites, 'BrowserFavorites', KeyCode.Unknown, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],\n\t\t[1, ScanCode.ZoomToggle, 'ZoomToggle', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailReply, 'MailReply', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailForward, 'MailForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailSend, 'MailSend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\n\t\t// See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n\t\t// If an Input Method Editor is processing key input and the event is keydown, return 229.\n\t\t[1, ScanCode.None, empty, KeyCode.KEY_IN_COMPOSITION, 'KeyInComposition', 229, empty, empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.ABNT_C2, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.OEM_8, 'OEM_8', 223, 'VK_OEM_8', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANGUL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_JUNJA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_FINAL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANJA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANJI', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CONVERT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONCONVERT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ACCEPT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_MODECHANGE', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SELECT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PRINT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXECUTE', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SNAPSHOT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HELP', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_APPS', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PROCESSKEY', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PACKET', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ATTN', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CRSEL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXSEL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EREOF', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PLAY', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ZOOM', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONAME', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PA1', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_OEM_CLEAR', empty, empty],\n\t];\n\n\tconst seenKeyCode: boolean[] = [];\n\tconst seenScanCode: boolean[] = [];\n\tfor (const mapping of mappings) {\n\t\tconst [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n\t\tif (!seenScanCode[scanCode]) {\n\t\t\tseenScanCode[scanCode] = true;\n\t\t\tscanCodeIntToStr[scanCode] = scanCodeStr;\n\t\t\tscanCodeStrToInt[scanCodeStr] = scanCode;\n\t\t\tscanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n\t\t\tif (immutable) {\n\t\t\t\tIMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n\t\t\t\tif (\n\t\t\t\t\t(keyCode !== KeyCode.Unknown)\n\t\t\t\t\t&& (keyCode !== KeyCode.Enter)\n\t\t\t\t\t&& (keyCode !== KeyCode.Ctrl)\n\t\t\t\t\t&& (keyCode !== KeyCode.Shift)\n\t\t\t\t\t&& (keyCode !== KeyCode.Alt)\n\t\t\t\t\t&& (keyCode !== KeyCode.Meta)\n\t\t\t\t) {\n\t\t\t\t\tIMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!seenKeyCode[keyCode]) {\n\t\t\tseenKeyCode[keyCode] = true;\n\t\t\tif (!keyCodeStr) {\n\t\t\t\tthrow new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\n\t\t\t}\n\t\t\tuiMap.define(keyCode, keyCodeStr);\n\t\t\tuserSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n\t\t\tuserSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n\t\t}\n\t\tif (eventKeyCode) {\n\t\t\tEVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n\t\t}\n\t\tif (vkey) {\n\t\t\tNATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n\t\t}\n\t}\n\t// Manually added due to the exclusion above (due to duplication with NumpadEnter)\n\tIMMUTABLE_KEY_CODE_TO_CODE[KeyCode.Enter] = ScanCode.Enter;\n\n})();\n\nexport namespace KeyCodeUtils {\n\texport function toString(keyCode: KeyCode): string {\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromString(key: string): KeyCode {\n\t\treturn uiMap.strToKeyCode(key);\n\t}\n\n\texport function toUserSettingsUS(keyCode: KeyCode): string {\n\t\treturn userSettingsUSMap.keyCodeToStr(keyCode);\n\t}\n\texport function toUserSettingsGeneral(keyCode: KeyCode): string {\n\t\treturn userSettingsGeneralMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromUserSettings(key: string): KeyCode {\n\t\treturn userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n\t}\n\n\texport function toElectronAccelerator(keyCode: KeyCode): string | null {\n\t\tif (keyCode >= KeyCode.Numpad0 && keyCode <= KeyCode.NumpadDivide) {\n\t\t\t// [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it\n\t\t\t// renders them just as regular keys in menus. For example, num0 is rendered as \"0\",\n\t\t\t// numdiv is rendered as \"/\", numsub is rendered as \"-\".\n\t\t\t//\n\t\t\t// This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable\n\t\t\t// from keybindings based on regular keys.\n\t\t\t//\n\t\t\t// We therefore need to fall back to custom rendering for numpad keys.\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (keyCode) {\n\t\t\tcase KeyCode.UpArrow:\n\t\t\t\treturn 'Up';\n\t\t\tcase KeyCode.DownArrow:\n\t\t\t\treturn 'Down';\n\t\t\tcase KeyCode.LeftArrow:\n\t\t\t\treturn 'Left';\n\t\t\tcase KeyCode.RightArrow:\n\t\t\t\treturn 'Right';\n\t\t}\n\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n}\n\nexport const enum KeyMod {\n\tCtrlCmd = (1 << 11) >>> 0,\n\tShift = (1 << 10) >>> 0,\n\tAlt = (1 << 9) >>> 0,\n\tWinCtrl = (1 << 8) >>> 0,\n}\n\nexport function KeyChord(firstPart: number, secondPart: number): number {\n\tconst chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n\treturn (firstPart | chordPart) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport const enum KeyCode {\n\tDependsOnKbLayout = -1,\n\n\t/**\n\t * Placed first to cover the 0 value of the enum.\n\t */\n\tUnknown = 0,\n\n\tBackspace,\n\tTab,\n\tEnter,\n\tShift,\n\tCtrl,\n\tAlt,\n\tPauseBreak,\n\tCapsLock,\n\tEscape,\n\tSpace,\n\tPageUp,\n\tPageDown,\n\tEnd,\n\tHome,\n\tLeftArrow,\n\tUpArrow,\n\tRightArrow,\n\tDownArrow,\n\tInsert,\n\tDelete,\n\n\tDigit0,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\n\tMeta,\n\tContextMenu,\n\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\n\tNumLock,\n\tScrollLock,\n\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ';:' key\n\t */\n\tSemicolon,\n\t/**\n\t * For any country/region, the '+' key\n\t * For the US standard keyboard, the '=+' key\n\t */\n\tEqual,\n\t/**\n\t * For any country/region, the ',' key\n\t * For the US standard keyboard, the ',<' key\n\t */\n\tComma,\n\t/**\n\t * For any country/region, the '-' key\n\t * For the US standard keyboard, the '-_' key\n\t */\n\tMinus,\n\t/**\n\t * For any country/region, the '.' key\n\t * For the US standard keyboard, the '.>' key\n\t */\n\tPeriod,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '/?' key\n\t */\n\tSlash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '`~' key\n\t */\n\tBackquote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '[{' key\n\t */\n\tBracketLeft,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '\\|' key\n\t */\n\tBackslash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ']}' key\n\t */\n\tBracketRight,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ''\"' key\n\t */\n\tQuote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t */\n\tOEM_8,\n\t/**\n\t * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n\t */\n\tIntlBackslash,\n\n\tNumpad0, // VK_NUMPAD0, 0x60, Numeric keypad 0 key\n\tNumpad1, // VK_NUMPAD1, 0x61, Numeric keypad 1 key\n\tNumpad2, // VK_NUMPAD2, 0x62, Numeric keypad 2 key\n\tNumpad3, // VK_NUMPAD3, 0x63, Numeric keypad 3 key\n\tNumpad4, // VK_NUMPAD4, 0x64, Numeric keypad 4 key\n\tNumpad5, // VK_NUMPAD5, 0x65, Numeric keypad 5 key\n\tNumpad6, // VK_NUMPAD6, 0x66, Numeric keypad 6 key\n\tNumpad7, // VK_NUMPAD7, 0x67, Numeric keypad 7 key\n\tNumpad8, // VK_NUMPAD8, 0x68, Numeric keypad 8 key\n\tNumpad9, // VK_NUMPAD9, 0x69, Numeric keypad 9 key\n\n\tNumpadMultiply,\t// VK_MULTIPLY, 0x6A, Multiply key\n\tNumpadAdd,\t\t// VK_ADD, 0x6B, Add key\n\tNUMPAD_SEPARATOR,\t// VK_SEPARATOR, 0x6C, Separator key\n\tNumpadSubtract,\t// VK_SUBTRACT, 0x6D, Subtract key\n\tNumpadDecimal,\t// VK_DECIMAL, 0x6E, Decimal key\n\tNumpadDivide,\t// VK_DIVIDE, 0x6F,\n\n\t/**\n\t * Cover all key codes when IME is processing input.\n\t */\n\tKEY_IN_COMPOSITION,\n\n\tABNT_C1, // Brazilian (ABNT) Keyboard\n\tABNT_C2, // Brazilian (ABNT) Keyboard\n\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tMediaPlayPause,\n\tLaunchMediaPlayer,\n\tLaunchMail,\n\tLaunchApp2,\n\n\t/**\n\t * VK_CLEAR, 0x0C, CLEAR key\n\t */\n\tClear,\n\n\t/**\n\t * Placed last to cover the length of the enum.\n\t * Please do not depend on this value!\n\t */\n\tMAX_VALUE\n}\n\n/**\n * keyboardEvent.code\n */\nexport const enum ScanCode {\n\tDependsOnKbLayout = -1,\n\tNone,\n\tHyper,\n\tSuper,\n\tFn,\n\tFnLock,\n\tSuspend,\n\tResume,\n\tTurbo,\n\tSleep,\n\tWakeUp,\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\tDigit0,\n\tEnter,\n\tEscape,\n\tBackspace,\n\tTab,\n\tSpace,\n\tMinus,\n\tEqual,\n\tBracketLeft,\n\tBracketRight,\n\tBackslash,\n\tIntlHash,\n\tSemicolon,\n\tQuote,\n\tBackquote,\n\tComma,\n\tPeriod,\n\tSlash,\n\tCapsLock,\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tPrintScreen,\n\tScrollLock,\n\tPause,\n\tInsert,\n\tHome,\n\tPageUp,\n\tDelete,\n\tEnd,\n\tPageDown,\n\tArrowRight,\n\tArrowLeft,\n\tArrowDown,\n\tArrowUp,\n\tNumLock,\n\tNumpadDivide,\n\tNumpadMultiply,\n\tNumpadSubtract,\n\tNumpadAdd,\n\tNumpadEnter,\n\tNumpad1,\n\tNumpad2,\n\tNumpad3,\n\tNumpad4,\n\tNumpad5,\n\tNumpad6,\n\tNumpad7,\n\tNumpad8,\n\tNumpad9,\n\tNumpad0,\n\tNumpadDecimal,\n\tIntlBackslash,\n\tContextMenu,\n\tPower,\n\tNumpadEqual,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\tOpen,\n\tHelp,\n\tSelect,\n\tAgain,\n\tUndo,\n\tCut,\n\tCopy,\n\tPaste,\n\tFind,\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\tNumpadComma,\n\tIntlRo,\n\tKanaMode,\n\tIntlYen,\n\tConvert,\n\tNonConvert,\n\tLang1,\n\tLang2,\n\tLang3,\n\tLang4,\n\tLang5,\n\tAbort,\n\tProps,\n\tNumpadParenLeft,\n\tNumpadParenRight,\n\tNumpadBackspace,\n\tNumpadMemoryStore,\n\tNumpadMemoryRecall,\n\tNumpadMemoryClear,\n\tNumpadMemoryAdd,\n\tNumpadMemorySubtract,\n\tNumpadClear,\n\tNumpadClearEntry,\n\tControlLeft,\n\tShiftLeft,\n\tAltLeft,\n\tMetaLeft,\n\tControlRight,\n\tShiftRight,\n\tAltRight,\n\tMetaRight,\n\tBrightnessUp,\n\tBrightnessDown,\n\tMediaPlay,\n\tMediaRecord,\n\tMediaFastForward,\n\tMediaRewind,\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tEject,\n\tMediaPlayPause,\n\tMediaSelect,\n\tLaunchMail,\n\tLaunchApp2,\n\tLaunchApp1,\n\tSelectTask,\n\tLaunchScreenSaver,\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\tBrowserStop,\n\tBrowserRefresh,\n\tBrowserFavorites,\n\tZoomToggle,\n\tMailReply,\n\tMailForward,\n\tMailSend,\n\n\tMAX_VALUE\n}\n\nclass KeyCodeStrMap {\n\n\tpublic _keyCodeToStr: string[];\n\tpublic _strToKeyCode: { [str: string]: KeyCode };\n\n\tconstructor() {\n\t\tthis._keyCodeToStr = [];\n\t\tthis._strToKeyCode = Object.create(null);\n\t}\n\n\tdefine(keyCode: KeyCode, str: string): void {\n\t\tthis._keyCodeToStr[keyCode] = str;\n\t\tthis._strToKeyCode[str.toLowerCase()] = keyCode;\n\t}\n\n\tkeyCodeToStr(keyCode: KeyCode): string {\n\t\treturn this._keyCodeToStr[keyCode];\n\t}\n\n\tstrToKeyCode(str: string): KeyCode {\n\t\treturn this._strToKeyCode[str.toLowerCase()] || KeyCode.Unknown;\n\t}\n}\n\nconst uiMap = new KeyCodeStrMap();\nconst userSettingsUSMap = new KeyCodeStrMap();\nconst userSettingsGeneralMap = new KeyCodeStrMap();\nexport const EVENT_KEY_CODE_MAP: { [keyCode: number]: KeyCode } = new Array(230);\nexport const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE: { [nativeKeyCode: string]: KeyCode } = {};\nconst scanCodeIntToStr: string[] = [];\nconst scanCodeStrToInt: { [code: string]: number } = Object.create(null);\nconst scanCodeLowerCaseStrToInt: { [code: string]: number } = Object.create(null);\n\nexport const ScanCodeUtils = {\n\tlowerCaseToEnum: (scanCode: string) => scanCodeLowerCaseStrToInt[scanCode] || ScanCode.None,\n\ttoEnum: (scanCode: string) => scanCodeStrToInt[scanCode] || ScanCode.None,\n\ttoString: (scanCode: ScanCode) => scanCodeIntToStr[scanCode] || 'None'\n};\n\n/**\n * -1 if a ScanCode => KeyCode mapping depends on kb layout.\n */\nexport const IMMUTABLE_CODE_TO_KEY_CODE: KeyCode[] = [];\n\n/**\n * -1 if a KeyCode => ScanCode mapping depends on kb layout.\n */\nexport const IMMUTABLE_KEY_CODE_TO_CODE: ScanCode[] = [];\n\nfor (let i = 0; i <= ScanCode.MAX_VALUE; i++) {\n\tIMMUTABLE_CODE_TO_KEY_CODE[i] = KeyCode.DependsOnKbLayout;\n}\n\nfor (let i = 0; i <= KeyCode.MAX_VALUE; i++) {\n\tIMMUTABLE_KEY_CODE_TO_CODE[i] = ScanCode.DependsOnKbLayout;\n}\n\n(function () {\n\n\t// See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n\t// See https://github.com/microsoft/node-native-keymap/blob/88c0b0e5/deps/chromium/keyboard_codes_win.h\n\n\tconst empty = '';\n\ttype IMappingEntry = [0 | 1, ScanCode, string, KeyCode, string, number, string, string, string];\n\tconst mappings: IMappingEntry[] = [\n\t\t// immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\n\t\t[1, ScanCode.None, 'None', KeyCode.Unknown, 'unknown', 0, 'VK_UNKNOWN', empty, empty],\n\t\t[1, ScanCode.Hyper, 'Hyper', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Super, 'Super', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Fn, 'Fn', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.FnLock, 'FnLock', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Suspend, 'Suspend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Resume, 'Resume', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Turbo, 'Turbo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Sleep, 'Sleep', KeyCode.Unknown, empty, 0, 'VK_SLEEP', empty, empty],\n\t\t[1, ScanCode.WakeUp, 'WakeUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[0, ScanCode.KeyA, 'KeyA', KeyCode.KeyA, 'A', 65, 'VK_A', empty, empty],\n\t\t[0, ScanCode.KeyB, 'KeyB', KeyCode.KeyB, 'B', 66, 'VK_B', empty, empty],\n\t\t[0, ScanCode.KeyC, 'KeyC', KeyCode.KeyC, 'C', 67, 'VK_C', empty, empty],\n\t\t[0, ScanCode.KeyD, 'KeyD', KeyCode.KeyD, 'D', 68, 'VK_D', empty, empty],\n\t\t[0, ScanCode.KeyE, 'KeyE', KeyCode.KeyE, 'E', 69, 'VK_E', empty, empty],\n\t\t[0, ScanCode.KeyF, 'KeyF', KeyCode.KeyF, 'F', 70, 'VK_F', empty, empty],\n\t\t[0, ScanCode.KeyG, 'KeyG', KeyCode.KeyG, 'G', 71, 'VK_G', empty, empty],\n\t\t[0, ScanCode.KeyH, 'KeyH', KeyCode.KeyH, 'H', 72, 'VK_H', empty, empty],\n\t\t[0, ScanCode.KeyI, 'KeyI', KeyCode.KeyI, 'I', 73, 'VK_I', empty, empty],\n\t\t[0, ScanCode.KeyJ, 'KeyJ', KeyCode.KeyJ, 'J', 74, 'VK_J', empty, empty],\n\t\t[0, ScanCode.KeyK, 'KeyK', KeyCode.KeyK, 'K', 75, 'VK_K', empty, empty],\n\t\t[0, ScanCode.KeyL, 'KeyL', KeyCode.KeyL, 'L', 76, 'VK_L', empty, empty],\n\t\t[0, ScanCode.KeyM, 'KeyM', KeyCode.KeyM, 'M', 77, 'VK_M', empty, empty],\n\t\t[0, ScanCode.KeyN, 'KeyN', KeyCode.KeyN, 'N', 78, 'VK_N', empty, empty],\n\t\t[0, ScanCode.KeyO, 'KeyO', KeyCode.KeyO, 'O', 79, 'VK_O', empty, empty],\n\t\t[0, ScanCode.KeyP, 'KeyP', KeyCode.KeyP, 'P', 80, 'VK_P', empty, empty],\n\t\t[0, ScanCode.KeyQ, 'KeyQ', KeyCode.KeyQ, 'Q', 81, 'VK_Q', empty, empty],\n\t\t[0, ScanCode.KeyR, 'KeyR', KeyCode.KeyR, 'R', 82, 'VK_R', empty, empty],\n\t\t[0, ScanCode.KeyS, 'KeyS', KeyCode.KeyS, 'S', 83, 'VK_S', empty, empty],\n\t\t[0, ScanCode.KeyT, 'KeyT', KeyCode.KeyT, 'T', 84, 'VK_T', empty, empty],\n\t\t[0, ScanCode.KeyU, 'KeyU', KeyCode.KeyU, 'U', 85, 'VK_U', empty, empty],\n\t\t[0, ScanCode.KeyV, 'KeyV', KeyCode.KeyV, 'V', 86, 'VK_V', empty, empty],\n\t\t[0, ScanCode.KeyW, 'KeyW', KeyCode.KeyW, 'W', 87, 'VK_W', empty, empty],\n\t\t[0, ScanCode.KeyX, 'KeyX', KeyCode.KeyX, 'X', 88, 'VK_X', empty, empty],\n\t\t[0, ScanCode.KeyY, 'KeyY', KeyCode.KeyY, 'Y', 89, 'VK_Y', empty, empty],\n\t\t[0, ScanCode.KeyZ, 'KeyZ', KeyCode.KeyZ, 'Z', 90, 'VK_Z', empty, empty],\n\t\t[0, ScanCode.Digit1, 'Digit1', KeyCode.Digit1, '1', 49, 'VK_1', empty, empty],\n\t\t[0, ScanCode.Digit2, 'Digit2', KeyCode.Digit2, '2', 50, 'VK_2', empty, empty],\n\t\t[0, ScanCode.Digit3, 'Digit3', KeyCode.Digit3, '3', 51, 'VK_3', empty, empty],\n\t\t[0, ScanCode.Digit4, 'Digit4', KeyCode.Digit4, '4', 52, 'VK_4', empty, empty],\n\t\t[0, ScanCode.Digit5, 'Digit5', KeyCode.Digit5, '5', 53, 'VK_5', empty, empty],\n\t\t[0, ScanCode.Digit6, 'Digit6', KeyCode.Digit6, '6', 54, 'VK_6', empty, empty],\n\t\t[0, ScanCode.Digit7, 'Digit7', KeyCode.Digit7, '7', 55, 'VK_7', empty, empty],\n\t\t[0, ScanCode.Digit8, 'Digit8', KeyCode.Digit8, '8', 56, 'VK_8', empty, empty],\n\t\t[0, ScanCode.Digit9, 'Digit9', KeyCode.Digit9, '9', 57, 'VK_9', empty, empty],\n\t\t[0, ScanCode.Digit0, 'Digit0', KeyCode.Digit0, '0', 48, 'VK_0', empty, empty],\n\t\t[1, ScanCode.Enter, 'Enter', KeyCode.Enter, 'Enter', 13, 'VK_RETURN', empty, empty],\n\t\t[1, ScanCode.Escape, 'Escape', KeyCode.Escape, 'Escape', 27, 'VK_ESCAPE', empty, empty],\n\t\t[1, ScanCode.Backspace, 'Backspace', KeyCode.Backspace, 'Backspace', 8, 'VK_BACK', empty, empty],\n\t\t[1, ScanCode.Tab, 'Tab', KeyCode.Tab, 'Tab', 9, 'VK_TAB', empty, empty],\n\t\t[1, ScanCode.Space, 'Space', KeyCode.Space, 'Space', 32, 'VK_SPACE', empty, empty],\n\t\t[0, ScanCode.Minus, 'Minus', KeyCode.Minus, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],\n\t\t[0, ScanCode.Equal, 'Equal', KeyCode.Equal, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],\n\t\t[0, ScanCode.BracketLeft, 'BracketLeft', KeyCode.BracketLeft, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],\n\t\t[0, ScanCode.BracketRight, 'BracketRight', KeyCode.BracketRight, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],\n\t\t[0, ScanCode.Backslash, 'Backslash', KeyCode.Backslash, '\\\\', 220, 'VK_OEM_5', '\\\\', 'OEM_5'],\n\t\t[0, ScanCode.IntlHash, 'IntlHash', KeyCode.Unknown, empty, 0, empty, empty, empty], // has been dropped from the w3c spec\n\t\t[0, ScanCode.Semicolon, 'Semicolon', KeyCode.Semicolon, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],\n\t\t[0, ScanCode.Quote, 'Quote', KeyCode.Quote, '\\'', 222, 'VK_OEM_7', '\\'', 'OEM_7'],\n\t\t[0, ScanCode.Backquote, 'Backquote', KeyCode.Backquote, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],\n\t\t[0, ScanCode.Comma, 'Comma', KeyCode.Comma, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],\n\t\t[0, ScanCode.Period, 'Period', KeyCode.Period, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],\n\t\t[0, ScanCode.Slash, 'Slash', KeyCode.Slash, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],\n\t\t[1, ScanCode.CapsLock, 'CapsLock', KeyCode.CapsLock, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],\n\t\t[1, ScanCode.F1, 'F1', KeyCode.F1, 'F1', 112, 'VK_F1', empty, empty],\n\t\t[1, ScanCode.F2, 'F2', KeyCode.F2, 'F2', 113, 'VK_F2', empty, empty],\n\t\t[1, ScanCode.F3, 'F3', KeyCode.F3, 'F3', 114, 'VK_F3', empty, empty],\n\t\t[1, ScanCode.F4, 'F4', KeyCode.F4, 'F4', 115, 'VK_F4', empty, empty],\n\t\t[1, ScanCode.F5, 'F5', KeyCode.F5, 'F5', 116, 'VK_F5', empty, empty],\n\t\t[1, ScanCode.F6, 'F6', KeyCode.F6, 'F6', 117, 'VK_F6', empty, empty],\n\t\t[1, ScanCode.F7, 'F7', KeyCode.F7, 'F7', 118, 'VK_F7', empty, empty],\n\t\t[1, ScanCode.F8, 'F8', KeyCode.F8, 'F8', 119, 'VK_F8', empty, empty],\n\t\t[1, ScanCode.F9, 'F9', KeyCode.F9, 'F9', 120, 'VK_F9', empty, empty],\n\t\t[1, ScanCode.F10, 'F10', KeyCode.F10, 'F10', 121, 'VK_F10', empty, empty],\n\t\t[1, ScanCode.F11, 'F11', KeyCode.F11, 'F11', 122, 'VK_F11', empty, empty],\n\t\t[1, ScanCode.F12, 'F12', KeyCode.F12, 'F12', 123, 'VK_F12', empty, empty],\n\t\t[1, ScanCode.PrintScreen, 'PrintScreen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.ScrollLock, 'ScrollLock', KeyCode.ScrollLock, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],\n\t\t[1, ScanCode.Pause, 'Pause', KeyCode.PauseBreak, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],\n\t\t[1, ScanCode.Insert, 'Insert', KeyCode.Insert, 'Insert', 45, 'VK_INSERT', empty, empty],\n\t\t[1, ScanCode.Home, 'Home', KeyCode.Home, 'Home', 36, 'VK_HOME', empty, empty],\n\t\t[1, ScanCode.PageUp, 'PageUp', KeyCode.PageUp, 'PageUp', 33, 'VK_PRIOR', empty, empty],\n\t\t[1, ScanCode.Delete, 'Delete', KeyCode.Delete, 'Delete', 46, 'VK_DELETE', empty, empty],\n\t\t[1, ScanCode.End, 'End', KeyCode.End, 'End', 35, 'VK_END', empty, empty],\n\t\t[1, ScanCode.PageDown, 'PageDown', KeyCode.PageDown, 'PageDown', 34, 'VK_NEXT', empty, empty],\n\t\t[1, ScanCode.ArrowRight, 'ArrowRight', KeyCode.RightArrow, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],\n\t\t[1, ScanCode.ArrowLeft, 'ArrowLeft', KeyCode.LeftArrow, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],\n\t\t[1, ScanCode.ArrowDown, 'ArrowDown', KeyCode.DownArrow, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],\n\t\t[1, ScanCode.ArrowUp, 'ArrowUp', KeyCode.UpArrow, 'UpArrow', 38, 'VK_UP', 'Up', empty],\n\t\t[1, ScanCode.NumLock, 'NumLock', KeyCode.NumLock, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],\n\t\t[1, ScanCode.NumpadDivide, 'NumpadDivide', KeyCode.NumpadDivide, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],\n\t\t[1, ScanCode.NumpadMultiply, 'NumpadMultiply', KeyCode.NumpadMultiply, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],\n\t\t[1, ScanCode.NumpadSubtract, 'NumpadSubtract', KeyCode.NumpadSubtract, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],\n\t\t[1, ScanCode.NumpadAdd, 'NumpadAdd', KeyCode.NumpadAdd, 'NumPad_Add', 107, 'VK_ADD', empty, empty],\n\t\t[1, ScanCode.NumpadEnter, 'NumpadEnter', KeyCode.Enter, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Numpad1, 'Numpad1', KeyCode.Numpad1, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],\n\t\t[1, ScanCode.Numpad2, 'Numpad2', KeyCode.Numpad2, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],\n\t\t[1, ScanCode.Numpad3, 'Numpad3', KeyCode.Numpad3, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],\n\t\t[1, ScanCode.Numpad4, 'Numpad4', KeyCode.Numpad4, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],\n\t\t[1, ScanCode.Numpad5, 'Numpad5', KeyCode.Numpad5, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],\n\t\t[1, ScanCode.Numpad6, 'Numpad6', KeyCode.Numpad6, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],\n\t\t[1, ScanCode.Numpad7, 'Numpad7', KeyCode.Numpad7, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],\n\t\t[1, ScanCode.Numpad8, 'Numpad8', KeyCode.Numpad8, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],\n\t\t[1, ScanCode.Numpad9, 'Numpad9', KeyCode.Numpad9, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],\n\t\t[1, ScanCode.Numpad0, 'Numpad0', KeyCode.Numpad0, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],\n\t\t[1, ScanCode.NumpadDecimal, 'NumpadDecimal', KeyCode.NumpadDecimal, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],\n\t\t[0, ScanCode.IntlBackslash, 'IntlBackslash', KeyCode.IntlBackslash, 'OEM_102', 226, 'VK_OEM_102', empty, empty],\n\t\t[1, ScanCode.ContextMenu, 'ContextMenu', KeyCode.ContextMenu, 'ContextMenu', 93, empty, empty, empty],\n\t\t[1, ScanCode.Power, 'Power', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadEqual, 'NumpadEqual', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.F13, 'F13', KeyCode.F13, 'F13', 124, 'VK_F13', empty, empty],\n\t\t[1, ScanCode.F14, 'F14', KeyCode.F14, 'F14', 125, 'VK_F14', empty, empty],\n\t\t[1, ScanCode.F15, 'F15', KeyCode.F15, 'F15', 126, 'VK_F15', empty, empty],\n\t\t[1, ScanCode.F16, 'F16', KeyCode.F16, 'F16', 127, 'VK_F16', empty, empty],\n\t\t[1, ScanCode.F17, 'F17', KeyCode.F17, 'F17', 128, 'VK_F17', empty, empty],\n\t\t[1, ScanCode.F18, 'F18', KeyCode.F18, 'F18', 129, 'VK_F18', empty, empty],\n\t\t[1, ScanCode.F19, 'F19', KeyCode.F19, 'F19', 130, 'VK_F19', empty, empty],\n\t\t[1, ScanCode.F20, 'F20', KeyCode.F20, 'F20', 131, 'VK_F20', empty, empty],\n\t\t[1, ScanCode.F21, 'F21', KeyCode.F21, 'F21', 132, 'VK_F21', empty, empty],\n\t\t[1, ScanCode.F22, 'F22', KeyCode.F22, 'F22', 133, 'VK_F22', empty, empty],\n\t\t[1, ScanCode.F23, 'F23', KeyCode.F23, 'F23', 134, 'VK_F23', empty, empty],\n\t\t[1, ScanCode.F24, 'F24', KeyCode.F24, 'F24', 135, 'VK_F24', empty, empty],\n\t\t[1, ScanCode.Open, 'Open', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Help, 'Help', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Select, 'Select', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Again, 'Again', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Undo, 'Undo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Cut, 'Cut', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Copy, 'Copy', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Paste, 'Paste', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Find, 'Find', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.AudioVolumeMute, 'AudioVolumeMute', KeyCode.AudioVolumeMute, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],\n\t\t[1, ScanCode.AudioVolumeUp, 'AudioVolumeUp', KeyCode.AudioVolumeUp, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],\n\t\t[1, ScanCode.AudioVolumeDown, 'AudioVolumeDown', KeyCode.AudioVolumeDown, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],\n\t\t[1, ScanCode.NumpadComma, 'NumpadComma', KeyCode.NUMPAD_SEPARATOR, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],\n\t\t[0, ScanCode.IntlRo, 'IntlRo', KeyCode.ABNT_C1, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],\n\t\t[1, ScanCode.KanaMode, 'KanaMode', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[0, ScanCode.IntlYen, 'IntlYen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Convert, 'Convert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NonConvert, 'NonConvert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang1, 'Lang1', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang2, 'Lang2', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang3, 'Lang3', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang4, 'Lang4', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Lang5, 'Lang5', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Abort, 'Abort', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.Props, 'Props', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadParenLeft, 'NumpadParenLeft', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadParenRight, 'NumpadParenRight', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadBackspace, 'NumpadBackspace', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryStore, 'NumpadMemoryStore', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryRecall, 'NumpadMemoryRecall', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryClear, 'NumpadMemoryClear', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemoryAdd, 'NumpadMemoryAdd', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadMemorySubtract, 'NumpadMemorySubtract', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.NumpadClear, 'NumpadClear', KeyCode.Clear, 'Clear', 12, 'VK_CLEAR', empty, empty],\n\t\t[1, ScanCode.NumpadClearEntry, 'NumpadClearEntry', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Ctrl, 'Ctrl', 17, 'VK_CONTROL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Shift, 'Shift', 16, 'VK_SHIFT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Alt, 'Alt', 18, 'VK_MENU', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Meta, 'Meta', 91, 'VK_COMMAND', empty, empty],\n\t\t[1, ScanCode.ControlLeft, 'ControlLeft', KeyCode.Ctrl, empty, 0, 'VK_LCONTROL', empty, empty],\n\t\t[1, ScanCode.ShiftLeft, 'ShiftLeft', KeyCode.Shift, empty, 0, 'VK_LSHIFT', empty, empty],\n\t\t[1, ScanCode.AltLeft, 'AltLeft', KeyCode.Alt, empty, 0, 'VK_LMENU', empty, empty],\n\t\t[1, ScanCode.MetaLeft, 'MetaLeft', KeyCode.Meta, empty, 0, 'VK_LWIN', empty, empty],\n\t\t[1, ScanCode.ControlRight, 'ControlRight', KeyCode.Ctrl, empty, 0, 'VK_RCONTROL', empty, empty],\n\t\t[1, ScanCode.ShiftRight, 'ShiftRight', KeyCode.Shift, empty, 0, 'VK_RSHIFT', empty, empty],\n\t\t[1, ScanCode.AltRight, 'AltRight', KeyCode.Alt, empty, 0, 'VK_RMENU', empty, empty],\n\t\t[1, ScanCode.MetaRight, 'MetaRight', KeyCode.Meta, empty, 0, 'VK_RWIN', empty, empty],\n\t\t[1, ScanCode.BrightnessUp, 'BrightnessUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.BrightnessDown, 'BrightnessDown', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaPlay, 'MediaPlay', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaRecord, 'MediaRecord', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaFastForward, 'MediaFastForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaRewind, 'MediaRewind', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaTrackNext, 'MediaTrackNext', KeyCode.MediaTrackNext, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],\n\t\t[1, ScanCode.MediaTrackPrevious, 'MediaTrackPrevious', KeyCode.MediaTrackPrevious, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],\n\t\t[1, ScanCode.MediaStop, 'MediaStop', KeyCode.MediaStop, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],\n\t\t[1, ScanCode.Eject, 'Eject', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MediaPlayPause, 'MediaPlayPause', KeyCode.MediaPlayPause, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],\n\t\t[1, ScanCode.MediaSelect, 'MediaSelect', KeyCode.LaunchMediaPlayer, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],\n\t\t[1, ScanCode.LaunchMail, 'LaunchMail', KeyCode.LaunchMail, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],\n\t\t[1, ScanCode.LaunchApp2, 'LaunchApp2', KeyCode.LaunchApp2, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],\n\t\t[1, ScanCode.LaunchApp1, 'LaunchApp1', KeyCode.Unknown, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],\n\t\t[1, ScanCode.SelectTask, 'SelectTask', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.LaunchScreenSaver, 'LaunchScreenSaver', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.BrowserSearch, 'BrowserSearch', KeyCode.BrowserSearch, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],\n\t\t[1, ScanCode.BrowserHome, 'BrowserHome', KeyCode.BrowserHome, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],\n\t\t[1, ScanCode.BrowserBack, 'BrowserBack', KeyCode.BrowserBack, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],\n\t\t[1, ScanCode.BrowserForward, 'BrowserForward', KeyCode.BrowserForward, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],\n\t\t[1, ScanCode.BrowserStop, 'BrowserStop', KeyCode.Unknown, empty, 0, 'VK_BROWSER_STOP', empty, empty],\n\t\t[1, ScanCode.BrowserRefresh, 'BrowserRefresh', KeyCode.Unknown, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],\n\t\t[1, ScanCode.BrowserFavorites, 'BrowserFavorites', KeyCode.Unknown, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],\n\t\t[1, ScanCode.ZoomToggle, 'ZoomToggle', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailReply, 'MailReply', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailForward, 'MailForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\t\t[1, ScanCode.MailSend, 'MailSend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n\n\t\t// See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n\t\t// If an Input Method Editor is processing key input and the event is keydown, return 229.\n\t\t[1, ScanCode.None, empty, KeyCode.KEY_IN_COMPOSITION, 'KeyInComposition', 229, empty, empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.ABNT_C2, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.OEM_8, 'OEM_8', 223, 'VK_OEM_8', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANGUL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_JUNJA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_FINAL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANJA', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANJI', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CONVERT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONCONVERT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ACCEPT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_MODECHANGE', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SELECT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PRINT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXECUTE', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SNAPSHOT', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HELP', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_APPS', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PROCESSKEY', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PACKET', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ATTN', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CRSEL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXSEL', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EREOF', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PLAY', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ZOOM', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONAME', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PA1', empty, empty],\n\t\t[1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_OEM_CLEAR', empty, empty],\n\t];\n\n\tconst seenKeyCode: boolean[] = [];\n\tconst seenScanCode: boolean[] = [];\n\tfor (const mapping of mappings) {\n\t\tconst [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n\t\tif (!seenScanCode[scanCode]) {\n\t\t\tseenScanCode[scanCode] = true;\n\t\t\tscanCodeIntToStr[scanCode] = scanCodeStr;\n\t\t\tscanCodeStrToInt[scanCodeStr] = scanCode;\n\t\t\tscanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n\t\t\tif (immutable) {\n\t\t\t\tIMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n\t\t\t\tif (\n\t\t\t\t\t(keyCode !== KeyCode.Unknown)\n\t\t\t\t\t&& (keyCode !== KeyCode.Enter)\n\t\t\t\t\t&& (keyCode !== KeyCode.Ctrl)\n\t\t\t\t\t&& (keyCode !== KeyCode.Shift)\n\t\t\t\t\t&& (keyCode !== KeyCode.Alt)\n\t\t\t\t\t&& (keyCode !== KeyCode.Meta)\n\t\t\t\t) {\n\t\t\t\t\tIMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!seenKeyCode[keyCode]) {\n\t\t\tseenKeyCode[keyCode] = true;\n\t\t\tif (!keyCodeStr) {\n\t\t\t\tthrow new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\n\t\t\t}\n\t\t\tuiMap.define(keyCode, keyCodeStr);\n\t\t\tuserSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n\t\t\tuserSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n\t\t}\n\t\tif (eventKeyCode) {\n\t\t\tEVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n\t\t}\n\t\tif (vkey) {\n\t\t\tNATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n\t\t}\n\t}\n\t// Manually added due to the exclusion above (due to duplication with NumpadEnter)\n\tIMMUTABLE_KEY_CODE_TO_CODE[KeyCode.Enter] = ScanCode.Enter;\n\n})();\n\nexport namespace KeyCodeUtils {\n\texport function toString(keyCode: KeyCode): string {\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromString(key: string): KeyCode {\n\t\treturn uiMap.strToKeyCode(key);\n\t}\n\n\texport function toUserSettingsUS(keyCode: KeyCode): string {\n\t\treturn userSettingsUSMap.keyCodeToStr(keyCode);\n\t}\n\texport function toUserSettingsGeneral(keyCode: KeyCode): string {\n\t\treturn userSettingsGeneralMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromUserSettings(key: string): KeyCode {\n\t\treturn userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n\t}\n\n\texport function toElectronAccelerator(keyCode: KeyCode): string | null {\n\t\tif (keyCode >= KeyCode.Numpad0 && keyCode <= KeyCode.NumpadDivide) {\n\t\t\t// [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it\n\t\t\t// renders them just as regular keys in menus. For example, num0 is rendered as \"0\",\n\t\t\t// numdiv is rendered as \"/\", numsub is rendered as \"-\".\n\t\t\t//\n\t\t\t// This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable\n\t\t\t// from keybindings based on regular keys.\n\t\t\t//\n\t\t\t// We therefore need to fall back to custom rendering for numpad keys.\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (keyCode) {\n\t\t\tcase KeyCode.UpArrow:\n\t\t\t\treturn 'Up';\n\t\t\tcase KeyCode.DownArrow:\n\t\t\t\treturn 'Down';\n\t\t\tcase KeyCode.LeftArrow:\n\t\t\t\treturn 'Left';\n\t\t\tcase KeyCode.RightArrow:\n\t\t\t\treturn 'Right';\n\t\t}\n\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n}\n\nexport const enum KeyMod {\n\tCtrlCmd = (1 << 11) >>> 0,\n\tShift = (1 << 10) >>> 0,\n\tAlt = (1 << 9) >>> 0,\n\tWinCtrl = (1 << 8) >>> 0,\n}\n\nexport function KeyChord(firstPart: number, secondPart: number): number {\n\tconst chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n\treturn (firstPart | chordPart) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { INodeProcess, isMacintosh, isWindows } from './platform.js';\n\nlet safeProcess: Omit<INodeProcess, 'arch'> & { arch: string | undefined };\ndeclare const process: INodeProcess;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as any).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\n\tconst sandboxProcess: INodeProcess = vscodeGlobal.process;\n\tsafeProcess = {\n\t\tget platform() { return sandboxProcess.platform; },\n\t\tget arch() { return sandboxProcess.arch; },\n\t\tget env() { return sandboxProcess.env; },\n\t\tcwd() { return sandboxProcess.cwd(); }\n\t};\n}\n\n// Native node.js environment\nelse if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\tsafeProcess = {\n\t\tget platform() { return process.platform; },\n\t\tget arch() { return process.arch; },\n\t\tget env() { return process.env; },\n\t\tcwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\n\t};\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tget arch() { return undefined; /* arch is undefined in web */ },\n\n\t\t// Unsupported\n\t\tget env() { return {}; },\n\t\tcwd() { return '/'; }\n\t};\n}\n\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n *\n * @skipMangle\n */\nexport const cwd = safeProcess.cwd;\n\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n\n/**\n * Provides safe access to the `arch` method in node.js, sandboxed or web\n * environments.\n * Note: `arch` is `undefined` in web\n */\nexport const arch = safeProcess.arch;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { INodeProcess, isMacintosh, isWindows } from './platform.js';\n\nlet safeProcess: Omit<INodeProcess, 'arch'> & { arch: string | undefined };\ndeclare const process: INodeProcess;\n\n// Native sandbox environment\nconst vscodeGlobal = (globalThis as any).vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\n\tconst sandboxProcess: INodeProcess = vscodeGlobal.process;\n\tsafeProcess = {\n\t\tget platform() { return sandboxProcess.platform; },\n\t\tget arch() { return sandboxProcess.arch; },\n\t\tget env() { return sandboxProcess.env; },\n\t\tcwd() { return sandboxProcess.cwd(); }\n\t};\n}\n\n// Native node.js environment\nelse if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\tsafeProcess = {\n\t\tget platform() { return process.platform; },\n\t\tget arch() { return process.arch; },\n\t\tget env() { return process.env; },\n\t\tcwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\n\t};\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tget arch() { return undefined; /* arch is undefined in web */ },\n\n\t\t// Unsupported\n\t\tget env() { return {}; },\n\t\tcwd() { return '/'; }\n\t};\n}\n\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n *\n * @skipMangle\n */\nexport const cwd = safeProcess.cwd;\n\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n\n/**\n * Provides safe access to the `arch` method in node.js, sandboxed or web\n * environments.\n * Note: `arch` is `undefined` in web\n */\nexport const arch = safeProcess.arch;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/commits/v22.15.0/lib/path.js\n// Excluding: the change that adds primordials\n// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)\n// Excluding: the change that adds glob matching\n// (https://github.com/nodejs/node/commit/57b8b8e18e5e2007114c63b71bf0baedc01936a6)\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from './process.js';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateObject(pathObject: object, name: string) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType(name, 'Object', pathObject);\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction formatExt(ext: string): string {\n\treturn ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tvalidateObject(pathObject, 'pathObject');\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, suffix?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (!isAbsolute && device === undefined && path.includes(':')) {\n\t\t\t// If the original path was not absolute and if we have not been able to\n\t\t\t// resolve it relative to a particular device, we need to ensure that the\n\t\t\t// `tail` has not become something that Windows might interpret as an\n\t\t\t// absolute path. See CVE-2024-36139.\n\t\t\tif (tail.length >= 2 &&\n\t\t\t\tisWindowsDeviceRoot(tail.charCodeAt(0)) &&\n\t\t\t\ttail.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t}\n\t\t\tlet index = path.indexOf(':');\n\t\t\tdo {\n\t\t\t\tif (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {\n\t\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t\t}\n\t\t\t} while ((index = path.indexOf(':', index + 1)) !== -1);\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (fromOrig.length !== from.length || toOrig.length !== to.length) {\n\t\t\tconst fromSplit = fromOrig.split('\\\\');\n\t\t\tconst toSplit = toOrig.split('\\\\');\n\t\t\tif (fromSplit[fromSplit.length - 1] === '') {\n\t\t\t\tfromSplit.pop();\n\t\t\t}\n\t\t\tif (toSplit[toSplit.length - 1] === '') {\n\t\t\t\ttoSplit.pop();\n\t\t\t}\n\n\t\t\tconst fromLen = fromSplit.length;\n\t\t\tconst toLen = toSplit.length;\n\t\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tif (fromSplit[i].toLowerCase() !== toSplit[i].toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === 0) {\n\t\t\t\treturn toOrig;\n\t\t\t} else if (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\treturn toSplit.slice(i).join('\\\\');\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\treturn '..\\\\'.repeat(fromLen - 1 - i) + '..';\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\treturn '..\\\\'.repeat(fromLen - i) + toSplit.slice(i).join('\\\\');\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string' || path.length === 0) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn resolvedPath;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nconst posixCwd = (() => {\n\tif (platformIsWin32) {\n\t\t// Converts Windows' backslash path separators to POSIX forward slashes\n\t\t// and truncates any drive indicator\n\t\tconst regexp = /\\\\/g;\n\t\treturn () => {\n\t\t\tconst cwd = process.cwd().replace(regexp, '/');\n\t\t\treturn cwd.slice(cwd.indexOf('/'));\n\t\t};\n\t}\n\n\t// We're already on POSIX, no need for any transformations\n\treturn () => process.cwd();\n})();\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {\n\t\t\tconst path = pathSegments[i];\n\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (!resolvedAbsolute) {\n\t\t\tconst cwd = posixCwd();\n\t\t\tresolvedPath = `${cwd}/${resolvedPath}`;\n\t\t\tresolvedAbsolute =\n\t\t\t\tcwd.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst path = [];\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tpath.push(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\treturn posix.normalize(path.join('/'));\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst char = path[i];\n\t\t\tif (char === '/') {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (char === '.') {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nexport const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (platformIsWin32 ? win32.join : posix.join);\nexport const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nexport const relative = (platformIsWin32 ? win32.relative : posix.relative);\nexport const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nexport const basename = (platformIsWin32 ? win32.basename : posix.basename);\nexport const extname = (platformIsWin32 ? win32.extname : posix.extname);\nexport const format = (platformIsWin32 ? win32.format : posix.format);\nexport const parse = (platformIsWin32 ? win32.parse : posix.parse);\nexport const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (platformIsWin32 ? win32.sep : posix.sep);\nexport const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/commits/v22.15.0/lib/path.js\n// Excluding: the change that adds primordials\n// (https://github.com/nodejs/node/commit/187a862d221dec42fa9a5c4214e7034d9092792f and others)\n// Excluding: the change that adds glob matching\n// (https://github.com/nodejs/node/commit/57b8b8e18e5e2007114c63b71bf0baedc01936a6)\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from './process.js';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateObject(pathObject: object, name: string) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType(name, 'Object', pathObject);\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction formatExt(ext: string): string {\n\treturn ext ? `${ext[0] === '.' ? '' : '.'}${ext}` : '';\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tvalidateObject(pathObject, 'pathObject');\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${formatExt(pathObject.ext)}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, suffix?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (!isAbsolute && device === undefined && path.includes(':')) {\n\t\t\t// If the original path was not absolute and if we have not been able to\n\t\t\t// resolve it relative to a particular device, we need to ensure that the\n\t\t\t// `tail` has not become something that Windows might interpret as an\n\t\t\t// absolute path. See CVE-2024-36139.\n\t\t\tif (tail.length >= 2 &&\n\t\t\t\tisWindowsDeviceRoot(tail.charCodeAt(0)) &&\n\t\t\t\ttail.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t}\n\t\t\tlet index = path.indexOf(':');\n\t\t\tdo {\n\t\t\t\tif (index === len - 1 || isPathSeparator(path.charCodeAt(index + 1))) {\n\t\t\t\t\treturn `.\\\\${tail}`;\n\t\t\t\t}\n\t\t\t} while ((index = path.indexOf(':', index + 1)) !== -1);\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (fromOrig.length !== from.length || toOrig.length !== to.length) {\n\t\t\tconst fromSplit = fromOrig.split('\\\\');\n\t\t\tconst toSplit = toOrig.split('\\\\');\n\t\t\tif (fromSplit[fromSplit.length - 1] === '') {\n\t\t\t\tfromSplit.pop();\n\t\t\t}\n\t\t\tif (toSplit[toSplit.length - 1] === '') {\n\t\t\t\ttoSplit.pop();\n\t\t\t}\n\n\t\t\tconst fromLen = fromSplit.length;\n\t\t\tconst toLen = toSplit.length;\n\t\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tif (fromSplit[i].toLowerCase() !== toSplit[i].toLowerCase()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i === 0) {\n\t\t\t\treturn toOrig;\n\t\t\t} else if (i === length) {\n\t\t\t\tif (toLen > length) {\n\t\t\t\t\treturn toSplit.slice(i).join('\\\\');\n\t\t\t\t}\n\t\t\t\tif (fromLen > length) {\n\t\t\t\t\treturn '..\\\\'.repeat(fromLen - 1 - i) + '..';\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\treturn '..\\\\'.repeat(fromLen - i) + toSplit.slice(i).join('\\\\');\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string' || path.length === 0) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn resolvedPath;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nconst posixCwd = (() => {\n\tif (platformIsWin32) {\n\t\t// Converts Windows' backslash path separators to POSIX forward slashes\n\t\t// and truncates any drive indicator\n\t\tconst regexp = /\\\\/g;\n\t\treturn () => {\n\t\t\tconst cwd = process.cwd().replace(regexp, '/');\n\t\t\treturn cwd.slice(cwd.indexOf('/'));\n\t\t};\n\t}\n\n\t// We're already on POSIX, no need for any transformations\n\treturn () => process.cwd();\n})();\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= 0 && !resolvedAbsolute; i--) {\n\t\t\tconst path = pathSegments[i];\n\t\t\tvalidateString(path, `paths[${i}]`);\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (!resolvedAbsolute) {\n\t\t\tconst cwd = posixCwd();\n\t\t\tresolvedPath = `${cwd}/${resolvedPath}`;\n\t\t\tresolvedAbsolute =\n\t\t\t\tcwd.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst path = [];\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tpath.push(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\treturn posix.normalize(path.join('/'));\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, suffix?: string): string {\n\t\tif (suffix !== undefined) {\n\t\t\tvalidateString(suffix, 'suffix');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n\t\t\tif (suffix === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = suffix.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === suffix.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst char = path[i];\n\t\t\tif (char === '/') {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (char === '.') {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nexport const isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (platformIsWin32 ? win32.join : posix.join);\nexport const resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nexport const relative = (platformIsWin32 ? win32.relative : posix.relative);\nexport const dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nexport const basename = (platformIsWin32 ? win32.basename : posix.basename);\nexport const extname = (platformIsWin32 ? win32.extname : posix.extname);\nexport const format = (platformIsWin32 ? win32.format : posix.format);\nexport const parse = (platformIsWin32 ? win32.parse : posix.parse);\nexport const toNamespacedPath = (platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (platformIsWin32 ? win32.sep : posix.sep);\nexport const delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { MarshalledId } from './marshallingIds.js';\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: unknown): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\t/**\n\t * Creates new URI from uri components.\n\t *\n\t * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n\t * validation and should be used for untrusted uri components retrieved from storage,\n\t * user input, command arguments etc\n\t */\n\tstatic from(components: UriComponents, strict?: boolean): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t\tstrict\n\t\t);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPath on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\t/**\n\t * A helper function to revive URIs.\n\t *\n\t * **Note** that this function should only be used when receiving URI#toJSON generated data\n\t * and that it doesn't do any validation. Use {@link URI.from} when received \"untrusted\"\n\t * uri components such as command arguments or data from storage.\n\t *\n\t * @param data The URI components or URI to revive.\n\t * @returns The revived URI or undefined or null.\n\t */\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external ?? null;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath ?? null : null;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t[Symbol.for('debug.description')]() {\n\t\treturn `URI(${this.toString()})`;\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority?: string;\n\tpath?: string;\n\tquery?: string;\n\tfragment?: string;\n}\n\nexport function isUriComponents(thing: unknown): thing is UriComponents {\n\tif (!thing || typeof thing !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<UriComponents>thing).scheme === 'string'\n\t\t&& (typeof (<UriComponents>thing).authority === 'string' || typeof (<UriComponents>thing).authority === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).path === 'string' || typeof (<UriComponents>thing).path === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).query === 'string' || typeof (<UriComponents>thing).query === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).fragment === 'string' || typeof (<UriComponents>thing).fragment === 'undefined');\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal?: string;\n\tfsPath?: string;\n\t_sep?: 1;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t//--- uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\t// TODO\n\t\t// this isn't correct and can violate the UriComponents contract but\n\t\t// this is part of the vscode.Uri API and we shouldn't change how that\n\t\t// works anymore\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { MarshalledId } from './marshallingIds.js';\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: unknown): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\t/**\n\t * Creates new URI from uri components.\n\t *\n\t * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n\t * validation and should be used for untrusted uri components retrieved from storage,\n\t * user input, command arguments etc\n\t */\n\tstatic from(components: UriComponents, strict?: boolean): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t\tstrict\n\t\t);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPath on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\t/**\n\t * A helper function to revive URIs.\n\t *\n\t * **Note** that this function should only be used when receiving URI#toJSON generated data\n\t * and that it doesn't do any validation. Use {@link URI.from} when received \"untrusted\"\n\t * uri components such as command arguments or data from storage.\n\t *\n\t * @param data The URI components or URI to revive.\n\t * @returns The revived URI or undefined or null.\n\t */\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external ?? null;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath ?? null : null;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t[Symbol.for('debug.description')]() {\n\t\treturn `URI(${this.toString()})`;\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority?: string;\n\tpath?: string;\n\tquery?: string;\n\tfragment?: string;\n}\n\nexport function isUriComponents(thing: unknown): thing is UriComponents {\n\tif (!thing || typeof thing !== 'object') {\n\t\treturn false;\n\t}\n\treturn typeof (<UriComponents>thing).scheme === 'string'\n\t\t&& (typeof (<UriComponents>thing).authority === 'string' || typeof (<UriComponents>thing).authority === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).path === 'string' || typeof (<UriComponents>thing).path === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).query === 'string' || typeof (<UriComponents>thing).query === 'undefined')\n\t\t&& (typeof (<UriComponents>thing).fragment === 'string' || typeof (<UriComponents>thing).fragment === 'undefined');\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal?: string;\n\tfsPath?: string;\n\t_sep?: 1;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\t// eslint-disable-next-line local/code-no-dangerous-type-assertions\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t//--- uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\t// TODO\n\t\t// this isn't correct and can violate the UriComponents contract but\n\t\t// this is part of the vscode.Uri API and we shouldn't change how that\n\t\t// works anymore\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\nimport { Range } from './range.js';\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\treadonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\treadonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\treadonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\treadonly positionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport const enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tpublic readonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tpublic readonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpublic readonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpublic readonly positionColumn: number;\n\n\tconstructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number) {\n\t\tsuper(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n\t\tthis.selectionStartLineNumber = selectionStartLineNumber;\n\t\tthis.selectionStartColumn = selectionStartColumn;\n\t\tthis.positionLineNumber = positionLineNumber;\n\t\tthis.positionColumn = positionColumn;\n\t}\n\n\t/**\n\t * Transform to a human-readable representation.\n\t */\n\tpublic override toString(): string {\n\t\treturn '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n\t}\n\n\t/**\n\t * Test if equals other selection.\n\t */\n\tpublic equalsSelection(other: ISelection): boolean {\n\t\treturn (\n\t\t\tSelection.selectionsEqual(this, other)\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two selections are equal.\n\t */\n\tpublic static selectionsEqual(a: ISelection, b: ISelection): boolean {\n\t\treturn (\n\t\t\ta.selectionStartLineNumber === b.selectionStartLineNumber &&\n\t\t\ta.selectionStartColumn === b.selectionStartColumn &&\n\t\t\ta.positionLineNumber === b.positionLineNumber &&\n\t\t\ta.positionColumn === b.positionColumn\n\t\t);\n\t}\n\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tpublic getDirection(): SelectionDirection {\n\t\tif (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n\t\t\treturn SelectionDirection.LTR;\n\t\t}\n\t\treturn SelectionDirection.RTL;\n\t}\n\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic override setEndPosition(endLineNumber: number, endColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t\t}\n\t\treturn new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Get the position at `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic getPosition(): Position {\n\t\treturn new Position(this.positionLineNumber, this.positionColumn);\n\t}\n\n\t/**\n\t * Get the position at the start of the selection.\n\t*/\n\tpublic getSelectionStart(): Position {\n\t\treturn new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n\t}\n\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tpublic override setStartPosition(startLineNumber: number, startColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t\t}\n\t\treturn new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n\t}\n\n\t// ----\n\n\t/**\n\t * Create a `Selection` from one or two positions\n\t */\n\tpublic static override fromPositions(start: IPosition, end: IPosition = start): Selection {\n\t\treturn new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Creates a `Selection` from a range, given a direction.\n\t */\n\tpublic static fromRange(range: Range, direction: SelectionDirection): Selection {\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t} else {\n\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Create a `Selection` from an `ISelection`.\n\t */\n\tpublic static liftSelection(sel: ISelection): Selection {\n\t\treturn new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n\t}\n\n\t/**\n\t * `a` equals `b`.\n\t */\n\tpublic static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean {\n\t\tif (a && !b || !a && b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (!this.selectionsEqual(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `obj` is an `ISelection`.\n\t */\n\tpublic static isISelection(obj: any): obj is ISelection {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.selectionStartLineNumber === 'number')\n\t\t\t&& (typeof obj.selectionStartColumn === 'number')\n\t\t\t&& (typeof obj.positionLineNumber === 'number')\n\t\t\t&& (typeof obj.positionColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Create with a direction.\n\t */\n\tpublic static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection {\n\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\treturn new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\nimport { Range } from './range.js';\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\treadonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\treadonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\treadonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\treadonly positionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport const enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tpublic readonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tpublic readonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpublic readonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpublic readonly positionColumn: number;\n\n\tconstructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number) {\n\t\tsuper(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n\t\tthis.selectionStartLineNumber = selectionStartLineNumber;\n\t\tthis.selectionStartColumn = selectionStartColumn;\n\t\tthis.positionLineNumber = positionLineNumber;\n\t\tthis.positionColumn = positionColumn;\n\t}\n\n\t/**\n\t * Transform to a human-readable representation.\n\t */\n\tpublic override toString(): string {\n\t\treturn '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n\t}\n\n\t/**\n\t * Test if equals other selection.\n\t */\n\tpublic equalsSelection(other: ISelection): boolean {\n\t\treturn (\n\t\t\tSelection.selectionsEqual(this, other)\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two selections are equal.\n\t */\n\tpublic static selectionsEqual(a: ISelection, b: ISelection): boolean {\n\t\treturn (\n\t\t\ta.selectionStartLineNumber === b.selectionStartLineNumber &&\n\t\t\ta.selectionStartColumn === b.selectionStartColumn &&\n\t\t\ta.positionLineNumber === b.positionLineNumber &&\n\t\t\ta.positionColumn === b.positionColumn\n\t\t);\n\t}\n\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tpublic getDirection(): SelectionDirection {\n\t\tif (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n\t\t\treturn SelectionDirection.LTR;\n\t\t}\n\t\treturn SelectionDirection.RTL;\n\t}\n\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic override setEndPosition(endLineNumber: number, endColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t\t}\n\t\treturn new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Get the position at `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic getPosition(): Position {\n\t\treturn new Position(this.positionLineNumber, this.positionColumn);\n\t}\n\n\t/**\n\t * Get the position at the start of the selection.\n\t*/\n\tpublic getSelectionStart(): Position {\n\t\treturn new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n\t}\n\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tpublic override setStartPosition(startLineNumber: number, startColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t\t}\n\t\treturn new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n\t}\n\n\t// ----\n\n\t/**\n\t * Create a `Selection` from one or two positions\n\t */\n\tpublic static override fromPositions(start: IPosition, end: IPosition = start): Selection {\n\t\treturn new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Creates a `Selection` from a range, given a direction.\n\t */\n\tpublic static fromRange(range: Range, direction: SelectionDirection): Selection {\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t} else {\n\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Create a `Selection` from an `ISelection`.\n\t */\n\tpublic static liftSelection(sel: ISelection): Selection {\n\t\treturn new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n\t}\n\n\t/**\n\t * `a` equals `b`.\n\t */\n\tpublic static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean {\n\t\tif (a && !b || !a && b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (!this.selectionsEqual(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `obj` is an `ISelection`.\n\t */\n\tpublic static isISelection(obj: any): obj is ISelection {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.selectionStartLineNumber === 'number')\n\t\t\t&& (typeof obj.selectionStartColumn === 'number')\n\t\t\t&& (typeof obj.positionLineNumber === 'number')\n\t\t\t&& (typeof obj.positionColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Create with a direction.\n\t */\n\tpublic static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection {\n\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\treturn new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThemeIcon } from './themables.js';\nimport { isString } from './types.js';\n\n\nconst _codiconFontCharacters: { [id: string]: number } = Object.create(null);\n\nexport function register(id: string, fontCharacter: number | string): ThemeIcon {\n\tif (isString(fontCharacter)) {\n\t\tconst val = _codiconFontCharacters[fontCharacter];\n\t\tif (val === undefined) {\n\t\t\tthrow new Error(`${id} references an unknown codicon: ${fontCharacter}`);\n\t\t}\n\t\tfontCharacter = val;\n\t}\n\t_codiconFontCharacters[id] = fontCharacter;\n\treturn { id };\n}\n\n/**\n * Only to be used by the iconRegistry.\n */\nexport function getCodiconFontCharacters(): { [id: string]: number } {\n\treturn _codiconFontCharacters;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThemeIcon } from './themables.js';\nimport { isString } from './types.js';\n\n\nconst _codiconFontCharacters: { [id: string]: number } = Object.create(null);\n\nexport function register(id: string, fontCharacter: number | string): ThemeIcon {\n\tif (isString(fontCharacter)) {\n\t\tconst val = _codiconFontCharacters[fontCharacter];\n\t\tif (val === undefined) {\n\t\t\tthrow new Error(`${id} references an unknown codicon: ${fontCharacter}`);\n\t\t}\n\t\tfontCharacter = val;\n\t}\n\t_codiconFontCharacters[id] = fontCharacter;\n\treturn { id };\n}\n\n/**\n * Only to be used by the iconRegistry.\n */\nexport function getCodiconFontCharacters(): { [id: string]: number } {\n\treturn _codiconFontCharacters;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { register } from './codiconsUtil.js';\n\n\n// This file is automatically generated by (microsoft/vscode-codicons)/scripts/export-to-ts.js\n// Please don't edit it, as your changes will be overwritten.\n// Instead, add mappings to codiconsDerived in codicons.ts.\nexport const codiconsLibrary = {\n\tadd: register('add', 0xea60),\n\tplus: register('plus', 0xea60),\n\tgistNew: register('gist-new', 0xea60),\n\trepoCreate: register('repo-create', 0xea60),\n\tlightbulb: register('lightbulb', 0xea61),\n\tlightBulb: register('light-bulb', 0xea61),\n\trepo: register('repo', 0xea62),\n\trepoDelete: register('repo-delete', 0xea62),\n\tgistFork: register('gist-fork', 0xea63),\n\trepoForked: register('repo-forked', 0xea63),\n\tgitPullRequest: register('git-pull-request', 0xea64),\n\tgitPullRequestAbandoned: register('git-pull-request-abandoned', 0xea64),\n\trecordKeys: register('record-keys', 0xea65),\n\tkeyboard: register('keyboard', 0xea65),\n\ttag: register('tag', 0xea66),\n\tgitPullRequestLabel: register('git-pull-request-label', 0xea66),\n\ttagAdd: register('tag-add', 0xea66),\n\ttagRemove: register('tag-remove', 0xea66),\n\tperson: register('person', 0xea67),\n\tpersonFollow: register('person-follow', 0xea67),\n\tpersonOutline: register('person-outline', 0xea67),\n\tpersonFilled: register('person-filled', 0xea67),\n\tgitBranch: register('git-branch', 0xea68),\n\tgitBranchCreate: register('git-branch-create', 0xea68),\n\tgitBranchDelete: register('git-branch-delete', 0xea68),\n\tsourceControl: register('source-control', 0xea68),\n\tmirror: register('mirror', 0xea69),\n\tmirrorPublic: register('mirror-public', 0xea69),\n\tstar: register('star', 0xea6a),\n\tstarAdd: register('star-add', 0xea6a),\n\tstarDelete: register('star-delete', 0xea6a),\n\tstarEmpty: register('star-empty', 0xea6a),\n\tcomment: register('comment', 0xea6b),\n\tcommentAdd: register('comment-add', 0xea6b),\n\talert: register('alert', 0xea6c),\n\twarning: register('warning', 0xea6c),\n\tsearch: register('search', 0xea6d),\n\tsearchSave: register('search-save', 0xea6d),\n\tlogOut: register('log-out', 0xea6e),\n\tsignOut: register('sign-out', 0xea6e),\n\tlogIn: register('log-in', 0xea6f),\n\tsignIn: register('sign-in', 0xea6f),\n\teye: register('eye', 0xea70),\n\teyeUnwatch: register('eye-unwatch', 0xea70),\n\teyeWatch: register('eye-watch', 0xea70),\n\tcircleFilled: register('circle-filled', 0xea71),\n\tprimitiveDot: register('primitive-dot', 0xea71),\n\tcloseDirty: register('close-dirty', 0xea71),\n\tdebugBreakpoint: register('debug-breakpoint', 0xea71),\n\tdebugBreakpointDisabled: register('debug-breakpoint-disabled', 0xea71),\n\tdebugHint: register('debug-hint', 0xea71),\n\tterminalDecorationSuccess: register('terminal-decoration-success', 0xea71),\n\tprimitiveSquare: register('primitive-square', 0xea72),\n\tedit: register('edit', 0xea73),\n\tpencil: register('pencil', 0xea73),\n\tinfo: register('info', 0xea74),\n\tissueOpened: register('issue-opened', 0xea74),\n\tgistPrivate: register('gist-private', 0xea75),\n\tgitForkPrivate: register('git-fork-private', 0xea75),\n\tlock: register('lock', 0xea75),\n\tmirrorPrivate: register('mirror-private', 0xea75),\n\tclose: register('close', 0xea76),\n\tremoveClose: register('remove-close', 0xea76),\n\tx: register('x', 0xea76),\n\trepoSync: register('repo-sync', 0xea77),\n\tsync: register('sync', 0xea77),\n\tclone: register('clone', 0xea78),\n\tdesktopDownload: register('desktop-download', 0xea78),\n\tbeaker: register('beaker', 0xea79),\n\tmicroscope: register('microscope', 0xea79),\n\tvm: register('vm', 0xea7a),\n\tdeviceDesktop: register('device-desktop', 0xea7a),\n\tfile: register('file', 0xea7b),\n\tfileText: register('file-text', 0xea7b),\n\tmore: register('more', 0xea7c),\n\tellipsis: register('ellipsis', 0xea7c),\n\tkebabHorizontal: register('kebab-horizontal', 0xea7c),\n\tmailReply: register('mail-reply', 0xea7d),\n\treply: register('reply', 0xea7d),\n\torganization: register('organization', 0xea7e),\n\torganizationFilled: register('organization-filled', 0xea7e),\n\torganizationOutline: register('organization-outline', 0xea7e),\n\tnewFile: register('new-file', 0xea7f),\n\tfileAdd: register('file-add', 0xea7f),\n\tnewFolder: register('new-folder', 0xea80),\n\tfileDirectoryCreate: register('file-directory-create', 0xea80),\n\ttrash: register('trash', 0xea81),\n\ttrashcan: register('trashcan', 0xea81),\n\thistory: register('history', 0xea82),\n\tclock: register('clock', 0xea82),\n\tfolder: register('folder', 0xea83),\n\tfileDirectory: register('file-directory', 0xea83),\n\tsymbolFolder: register('symbol-folder', 0xea83),\n\tlogoGithub: register('logo-github', 0xea84),\n\tmarkGithub: register('mark-github', 0xea84),\n\tgithub: register('github', 0xea84),\n\tterminal: register('terminal', 0xea85),\n\tconsole: register('console', 0xea85),\n\trepl: register('repl', 0xea85),\n\tzap: register('zap', 0xea86),\n\tsymbolEvent: register('symbol-event', 0xea86),\n\terror: register('error', 0xea87),\n\tstop: register('stop', 0xea87),\n\tvariable: register('variable', 0xea88),\n\tsymbolVariable: register('symbol-variable', 0xea88),\n\tarray: register('array', 0xea8a),\n\tsymbolArray: register('symbol-array', 0xea8a),\n\tsymbolModule: register('symbol-module', 0xea8b),\n\tsymbolPackage: register('symbol-package', 0xea8b),\n\tsymbolNamespace: register('symbol-namespace', 0xea8b),\n\tsymbolObject: register('symbol-object', 0xea8b),\n\tsymbolMethod: register('symbol-method', 0xea8c),\n\tsymbolFunction: register('symbol-function', 0xea8c),\n\tsymbolConstructor: register('symbol-constructor', 0xea8c),\n\tsymbolBoolean: register('symbol-boolean', 0xea8f),\n\tsymbolNull: register('symbol-null', 0xea8f),\n\tsymbolNumeric: register('symbol-numeric', 0xea90),\n\tsymbolNumber: register('symbol-number', 0xea90),\n\tsymbolStructure: register('symbol-structure', 0xea91),\n\tsymbolStruct: register('symbol-struct', 0xea91),\n\tsymbolParameter: register('symbol-parameter', 0xea92),\n\tsymbolTypeParameter: register('symbol-type-parameter', 0xea92),\n\tsymbolKey: register('symbol-key', 0xea93),\n\tsymbolText: register('symbol-text', 0xea93),\n\tsymbolReference: register('symbol-reference', 0xea94),\n\tgoToFile: register('go-to-file', 0xea94),\n\tsymbolEnum: register('symbol-enum', 0xea95),\n\tsymbolValue: register('symbol-value', 0xea95),\n\tsymbolRuler: register('symbol-ruler', 0xea96),\n\tsymbolUnit: register('symbol-unit', 0xea96),\n\tactivateBreakpoints: register('activate-breakpoints', 0xea97),\n\tarchive: register('archive', 0xea98),\n\tarrowBoth: register('arrow-both', 0xea99),\n\tarrowDown: register('arrow-down', 0xea9a),\n\tarrowLeft: register('arrow-left', 0xea9b),\n\tarrowRight: register('arrow-right', 0xea9c),\n\tarrowSmallDown: register('arrow-small-down', 0xea9d),\n\tarrowSmallLeft: register('arrow-small-left', 0xea9e),\n\tarrowSmallRight: register('arrow-small-right', 0xea9f),\n\tarrowSmallUp: register('arrow-small-up', 0xeaa0),\n\tarrowUp: register('arrow-up', 0xeaa1),\n\tbell: register('bell', 0xeaa2),\n\tbold: register('bold', 0xeaa3),\n\tbook: register('book', 0xeaa4),\n\tbookmark: register('bookmark', 0xeaa5),\n\tdebugBreakpointConditionalUnverified: register('debug-breakpoint-conditional-unverified', 0xeaa6),\n\tdebugBreakpointConditional: register('debug-breakpoint-conditional', 0xeaa7),\n\tdebugBreakpointConditionalDisabled: register('debug-breakpoint-conditional-disabled', 0xeaa7),\n\tdebugBreakpointDataUnverified: register('debug-breakpoint-data-unverified', 0xeaa8),\n\tdebugBreakpointData: register('debug-breakpoint-data', 0xeaa9),\n\tdebugBreakpointDataDisabled: register('debug-breakpoint-data-disabled', 0xeaa9),\n\tdebugBreakpointLogUnverified: register('debug-breakpoint-log-unverified', 0xeaaa),\n\tdebugBreakpointLog: register('debug-breakpoint-log', 0xeaab),\n\tdebugBreakpointLogDisabled: register('debug-breakpoint-log-disabled', 0xeaab),\n\tbriefcase: register('briefcase', 0xeaac),\n\tbroadcast: register('broadcast', 0xeaad),\n\tbrowser: register('browser', 0xeaae),\n\tbug: register('bug', 0xeaaf),\n\tcalendar: register('calendar', 0xeab0),\n\tcaseSensitive: register('case-sensitive', 0xeab1),\n\tcheck: register('check', 0xeab2),\n\tchecklist: register('checklist', 0xeab3),\n\tchevronDown: register('chevron-down', 0xeab4),\n\tchevronLeft: register('chevron-left', 0xeab5),\n\tchevronRight: register('chevron-right', 0xeab6),\n\tchevronUp: register('chevron-up', 0xeab7),\n\tchromeClose: register('chrome-close', 0xeab8),\n\tchromeMaximize: register('chrome-maximize', 0xeab9),\n\tchromeMinimize: register('chrome-minimize', 0xeaba),\n\tchromeRestore: register('chrome-restore', 0xeabb),\n\tcircleOutline: register('circle-outline', 0xeabc),\n\tcircle: register('circle', 0xeabc),\n\tdebugBreakpointUnverified: register('debug-breakpoint-unverified', 0xeabc),\n\tterminalDecorationIncomplete: register('terminal-decoration-incomplete', 0xeabc),\n\tcircleSlash: register('circle-slash', 0xeabd),\n\tcircuitBoard: register('circuit-board', 0xeabe),\n\tclearAll: register('clear-all', 0xeabf),\n\tclippy: register('clippy', 0xeac0),\n\tcloseAll: register('close-all', 0xeac1),\n\tcloudDownload: register('cloud-download', 0xeac2),\n\tcloudUpload: register('cloud-upload', 0xeac3),\n\tcode: register('code', 0xeac4),\n\tcollapseAll: register('collapse-all', 0xeac5),\n\tcolorMode: register('color-mode', 0xeac6),\n\tcommentDiscussion: register('comment-discussion', 0xeac7),\n\tcreditCard: register('credit-card', 0xeac9),\n\tdash: register('dash', 0xeacc),\n\tdashboard: register('dashboard', 0xeacd),\n\tdatabase: register('database', 0xeace),\n\tdebugContinue: register('debug-continue', 0xeacf),\n\tdebugDisconnect: register('debug-disconnect', 0xead0),\n\tdebugPause: register('debug-pause', 0xead1),\n\tdebugRestart: register('debug-restart', 0xead2),\n\tdebugStart: register('debug-start', 0xead3),\n\tdebugStepInto: register('debug-step-into', 0xead4),\n\tdebugStepOut: register('debug-step-out', 0xead5),\n\tdebugStepOver: register('debug-step-over', 0xead6),\n\tdebugStop: register('debug-stop', 0xead7),\n\tdebug: register('debug', 0xead8),\n\tdeviceCameraVideo: register('device-camera-video', 0xead9),\n\tdeviceCamera: register('device-camera', 0xeada),\n\tdeviceMobile: register('device-mobile', 0xeadb),\n\tdiffAdded: register('diff-added', 0xeadc),\n\tdiffIgnored: register('diff-ignored', 0xeadd),\n\tdiffModified: register('diff-modified', 0xeade),\n\tdiffRemoved: register('diff-removed', 0xeadf),\n\tdiffRenamed: register('diff-renamed', 0xeae0),\n\tdiff: register('diff', 0xeae1),\n\tdiffSidebyside: register('diff-sidebyside', 0xeae1),\n\tdiscard: register('discard', 0xeae2),\n\teditorLayout: register('editor-layout', 0xeae3),\n\temptyWindow: register('empty-window', 0xeae4),\n\texclude: register('exclude', 0xeae5),\n\textensions: register('extensions', 0xeae6),\n\teyeClosed: register('eye-closed', 0xeae7),\n\tfileBinary: register('file-binary', 0xeae8),\n\tfileCode: register('file-code', 0xeae9),\n\tfileMedia: register('file-media', 0xeaea),\n\tfilePdf: register('file-pdf', 0xeaeb),\n\tfileSubmodule: register('file-submodule', 0xeaec),\n\tfileSymlinkDirectory: register('file-symlink-directory', 0xeaed),\n\tfileSymlinkFile: register('file-symlink-file', 0xeaee),\n\tfileZip: register('file-zip', 0xeaef),\n\tfiles: register('files', 0xeaf0),\n\tfilter: register('filter', 0xeaf1),\n\tflame: register('flame', 0xeaf2),\n\tfoldDown: register('fold-down', 0xeaf3),\n\tfoldUp: register('fold-up', 0xeaf4),\n\tfold: register('fold', 0xeaf5),\n\tfolderActive: register('folder-active', 0xeaf6),\n\tfolderOpened: register('folder-opened', 0xeaf7),\n\tgear: register('gear', 0xeaf8),\n\tgift: register('gift', 0xeaf9),\n\tgistSecret: register('gist-secret', 0xeafa),\n\tgist: register('gist', 0xeafb),\n\tgitCommit: register('git-commit', 0xeafc),\n\tgitCompare: register('git-compare', 0xeafd),\n\tcompareChanges: register('compare-changes', 0xeafd),\n\tgitMerge: register('git-merge', 0xeafe),\n\tgithubAction: register('github-action', 0xeaff),\n\tgithubAlt: register('github-alt', 0xeb00),\n\tglobe: register('globe', 0xeb01),\n\tgrabber: register('grabber', 0xeb02),\n\tgraph: register('graph', 0xeb03),\n\tgripper: register('gripper', 0xeb04),\n\theart: register('heart', 0xeb05),\n\thome: register('home', 0xeb06),\n\thorizontalRule: register('horizontal-rule', 0xeb07),\n\thubot: register('hubot', 0xeb08),\n\tinbox: register('inbox', 0xeb09),\n\tissueReopened: register('issue-reopened', 0xeb0b),\n\tissues: register('issues', 0xeb0c),\n\titalic: register('italic', 0xeb0d),\n\tjersey: register('jersey', 0xeb0e),\n\tjson: register('json', 0xeb0f),\n\tkebabVertical: register('kebab-vertical', 0xeb10),\n\tkey: register('key', 0xeb11),\n\tlaw: register('law', 0xeb12),\n\tlightbulbAutofix: register('lightbulb-autofix', 0xeb13),\n\tlinkExternal: register('link-external', 0xeb14),\n\tlink: register('link', 0xeb15),\n\tlistOrdered: register('list-ordered', 0xeb16),\n\tlistUnordered: register('list-unordered', 0xeb17),\n\tliveShare: register('live-share', 0xeb18),\n\tloading: register('loading', 0xeb19),\n\tlocation: register('location', 0xeb1a),\n\tmailRead: register('mail-read', 0xeb1b),\n\tmail: register('mail', 0xeb1c),\n\tmarkdown: register('markdown', 0xeb1d),\n\tmegaphone: register('megaphone', 0xeb1e),\n\tmention: register('mention', 0xeb1f),\n\tmilestone: register('milestone', 0xeb20),\n\tgitPullRequestMilestone: register('git-pull-request-milestone', 0xeb20),\n\tmortarBoard: register('mortar-board', 0xeb21),\n\tmove: register('move', 0xeb22),\n\tmultipleWindows: register('multiple-windows', 0xeb23),\n\tmute: register('mute', 0xeb24),\n\tnoNewline: register('no-newline', 0xeb25),\n\tnote: register('note', 0xeb26),\n\toctoface: register('octoface', 0xeb27),\n\topenPreview: register('open-preview', 0xeb28),\n\tpackage: register('package', 0xeb29),\n\tpaintcan: register('paintcan', 0xeb2a),\n\tpin: register('pin', 0xeb2b),\n\tplay: register('play', 0xeb2c),\n\trun: register('run', 0xeb2c),\n\tplug: register('plug', 0xeb2d),\n\tpreserveCase: register('preserve-case', 0xeb2e),\n\tpreview: register('preview', 0xeb2f),\n\tproject: register('project', 0xeb30),\n\tpulse: register('pulse', 0xeb31),\n\tquestion: register('question', 0xeb32),\n\tquote: register('quote', 0xeb33),\n\tradioTower: register('radio-tower', 0xeb34),\n\treactions: register('reactions', 0xeb35),\n\treferences: register('references', 0xeb36),\n\trefresh: register('refresh', 0xeb37),\n\tregex: register('regex', 0xeb38),\n\tremoteExplorer: register('remote-explorer', 0xeb39),\n\tremote: register('remote', 0xeb3a),\n\tremove: register('remove', 0xeb3b),\n\treplaceAll: register('replace-all', 0xeb3c),\n\treplace: register('replace', 0xeb3d),\n\trepoClone: register('repo-clone', 0xeb3e),\n\trepoForcePush: register('repo-force-push', 0xeb3f),\n\trepoPull: register('repo-pull', 0xeb40),\n\trepoPush: register('repo-push', 0xeb41),\n\treport: register('report', 0xeb42),\n\trequestChanges: register('request-changes', 0xeb43),\n\trocket: register('rocket', 0xeb44),\n\trootFolderOpened: register('root-folder-opened', 0xeb45),\n\trootFolder: register('root-folder', 0xeb46),\n\trss: register('rss', 0xeb47),\n\truby: register('ruby', 0xeb48),\n\tsaveAll: register('save-all', 0xeb49),\n\tsaveAs: register('save-as', 0xeb4a),\n\tsave: register('save', 0xeb4b),\n\tscreenFull: register('screen-full', 0xeb4c),\n\tscreenNormal: register('screen-normal', 0xeb4d),\n\tsearchStop: register('search-stop', 0xeb4e),\n\tserver: register('server', 0xeb50),\n\tsettingsGear: register('settings-gear', 0xeb51),\n\tsettings: register('settings', 0xeb52),\n\tshield: register('shield', 0xeb53),\n\tsmiley: register('smiley', 0xeb54),\n\tsortPrecedence: register('sort-precedence', 0xeb55),\n\tsplitHorizontal: register('split-horizontal', 0xeb56),\n\tsplitVertical: register('split-vertical', 0xeb57),\n\tsquirrel: register('squirrel', 0xeb58),\n\tstarFull: register('star-full', 0xeb59),\n\tstarHalf: register('star-half', 0xeb5a),\n\tsymbolClass: register('symbol-class', 0xeb5b),\n\tsymbolColor: register('symbol-color', 0xeb5c),\n\tsymbolConstant: register('symbol-constant', 0xeb5d),\n\tsymbolEnumMember: register('symbol-enum-member', 0xeb5e),\n\tsymbolField: register('symbol-field', 0xeb5f),\n\tsymbolFile: register('symbol-file', 0xeb60),\n\tsymbolInterface: register('symbol-interface', 0xeb61),\n\tsymbolKeyword: register('symbol-keyword', 0xeb62),\n\tsymbolMisc: register('symbol-misc', 0xeb63),\n\tsymbolOperator: register('symbol-operator', 0xeb64),\n\tsymbolProperty: register('symbol-property', 0xeb65),\n\twrench: register('wrench', 0xeb65),\n\twrenchSubaction: register('wrench-subaction', 0xeb65),\n\tsymbolSnippet: register('symbol-snippet', 0xeb66),\n\ttasklist: register('tasklist', 0xeb67),\n\ttelescope: register('telescope', 0xeb68),\n\ttextSize: register('text-size', 0xeb69),\n\tthreeBars: register('three-bars', 0xeb6a),\n\tthumbsdown: register('thumbsdown', 0xeb6b),\n\tthumbsup: register('thumbsup', 0xeb6c),\n\ttools: register('tools', 0xeb6d),\n\ttriangleDown: register('triangle-down', 0xeb6e),\n\ttriangleLeft: register('triangle-left', 0xeb6f),\n\ttriangleRight: register('triangle-right', 0xeb70),\n\ttriangleUp: register('triangle-up', 0xeb71),\n\ttwitter: register('twitter', 0xeb72),\n\tunfold: register('unfold', 0xeb73),\n\tunlock: register('unlock', 0xeb74),\n\tunmute: register('unmute', 0xeb75),\n\tunverified: register('unverified', 0xeb76),\n\tverified: register('verified', 0xeb77),\n\tversions: register('versions', 0xeb78),\n\tvmActive: register('vm-active', 0xeb79),\n\tvmOutline: register('vm-outline', 0xeb7a),\n\tvmRunning: register('vm-running', 0xeb7b),\n\twatch: register('watch', 0xeb7c),\n\twhitespace: register('whitespace', 0xeb7d),\n\twholeWord: register('whole-word', 0xeb7e),\n\twindow: register('window', 0xeb7f),\n\twordWrap: register('word-wrap', 0xeb80),\n\tzoomIn: register('zoom-in', 0xeb81),\n\tzoomOut: register('zoom-out', 0xeb82),\n\tlistFilter: register('list-filter', 0xeb83),\n\tlistFlat: register('list-flat', 0xeb84),\n\tlistSelection: register('list-selection', 0xeb85),\n\tselection: register('selection', 0xeb85),\n\tlistTree: register('list-tree', 0xeb86),\n\tdebugBreakpointFunctionUnverified: register('debug-breakpoint-function-unverified', 0xeb87),\n\tdebugBreakpointFunction: register('debug-breakpoint-function', 0xeb88),\n\tdebugBreakpointFunctionDisabled: register('debug-breakpoint-function-disabled', 0xeb88),\n\tdebugStackframeActive: register('debug-stackframe-active', 0xeb89),\n\tcircleSmallFilled: register('circle-small-filled', 0xeb8a),\n\tdebugStackframeDot: register('debug-stackframe-dot', 0xeb8a),\n\tterminalDecorationMark: register('terminal-decoration-mark', 0xeb8a),\n\tdebugStackframe: register('debug-stackframe', 0xeb8b),\n\tdebugStackframeFocused: register('debug-stackframe-focused', 0xeb8b),\n\tdebugBreakpointUnsupported: register('debug-breakpoint-unsupported', 0xeb8c),\n\tsymbolString: register('symbol-string', 0xeb8d),\n\tdebugReverseContinue: register('debug-reverse-continue', 0xeb8e),\n\tdebugStepBack: register('debug-step-back', 0xeb8f),\n\tdebugRestartFrame: register('debug-restart-frame', 0xeb90),\n\tdebugAlt: register('debug-alt', 0xeb91),\n\tcallIncoming: register('call-incoming', 0xeb92),\n\tcallOutgoing: register('call-outgoing', 0xeb93),\n\tmenu: register('menu', 0xeb94),\n\texpandAll: register('expand-all', 0xeb95),\n\tfeedback: register('feedback', 0xeb96),\n\tgitPullRequestReviewer: register('git-pull-request-reviewer', 0xeb96),\n\tgroupByRefType: register('group-by-ref-type', 0xeb97),\n\tungroupByRefType: register('ungroup-by-ref-type', 0xeb98),\n\taccount: register('account', 0xeb99),\n\tgitPullRequestAssignee: register('git-pull-request-assignee', 0xeb99),\n\tbellDot: register('bell-dot', 0xeb9a),\n\tdebugConsole: register('debug-console', 0xeb9b),\n\tlibrary: register('library', 0xeb9c),\n\toutput: register('output', 0xeb9d),\n\trunAll: register('run-all', 0xeb9e),\n\tsyncIgnored: register('sync-ignored', 0xeb9f),\n\tpinned: register('pinned', 0xeba0),\n\tgithubInverted: register('github-inverted', 0xeba1),\n\tserverProcess: register('server-process', 0xeba2),\n\tserverEnvironment: register('server-environment', 0xeba3),\n\tpass: register('pass', 0xeba4),\n\tissueClosed: register('issue-closed', 0xeba4),\n\tstopCircle: register('stop-circle', 0xeba5),\n\tplayCircle: register('play-circle', 0xeba6),\n\trecord: register('record', 0xeba7),\n\tdebugAltSmall: register('debug-alt-small', 0xeba8),\n\tvmConnect: register('vm-connect', 0xeba9),\n\tcloud: register('cloud', 0xebaa),\n\tmerge: register('merge', 0xebab),\n\texport: register('export', 0xebac),\n\tgraphLeft: register('graph-left', 0xebad),\n\tmagnet: register('magnet', 0xebae),\n\tnotebook: register('notebook', 0xebaf),\n\tredo: register('redo', 0xebb0),\n\tcheckAll: register('check-all', 0xebb1),\n\tpinnedDirty: register('pinned-dirty', 0xebb2),\n\tpassFilled: register('pass-filled', 0xebb3),\n\tcircleLargeFilled: register('circle-large-filled', 0xebb4),\n\tcircleLarge: register('circle-large', 0xebb5),\n\tcircleLargeOutline: register('circle-large-outline', 0xebb5),\n\tcombine: register('combine', 0xebb6),\n\tgather: register('gather', 0xebb6),\n\ttable: register('table', 0xebb7),\n\tvariableGroup: register('variable-group', 0xebb8),\n\ttypeHierarchy: register('type-hierarchy', 0xebb9),\n\ttypeHierarchySub: register('type-hierarchy-sub', 0xebba),\n\ttypeHierarchySuper: register('type-hierarchy-super', 0xebbb),\n\tgitPullRequestCreate: register('git-pull-request-create', 0xebbc),\n\trunAbove: register('run-above', 0xebbd),\n\trunBelow: register('run-below', 0xebbe),\n\tnotebookTemplate: register('notebook-template', 0xebbf),\n\tdebugRerun: register('debug-rerun', 0xebc0),\n\tworkspaceTrusted: register('workspace-trusted', 0xebc1),\n\tworkspaceUntrusted: register('workspace-untrusted', 0xebc2),\n\tworkspaceUnknown: register('workspace-unknown', 0xebc3),\n\tterminalCmd: register('terminal-cmd', 0xebc4),\n\tterminalDebian: register('terminal-debian', 0xebc5),\n\tterminalLinux: register('terminal-linux', 0xebc6),\n\tterminalPowershell: register('terminal-powershell', 0xebc7),\n\tterminalTmux: register('terminal-tmux', 0xebc8),\n\tterminalUbuntu: register('terminal-ubuntu', 0xebc9),\n\tterminalBash: register('terminal-bash', 0xebca),\n\tarrowSwap: register('arrow-swap', 0xebcb),\n\tcopy: register('copy', 0xebcc),\n\tpersonAdd: register('person-add', 0xebcd),\n\tfilterFilled: register('filter-filled', 0xebce),\n\twand: register('wand', 0xebcf),\n\tdebugLineByLine: register('debug-line-by-line', 0xebd0),\n\tinspect: register('inspect', 0xebd1),\n\tlayers: register('layers', 0xebd2),\n\tlayersDot: register('layers-dot', 0xebd3),\n\tlayersActive: register('layers-active', 0xebd4),\n\tcompass: register('compass', 0xebd5),\n\tcompassDot: register('compass-dot', 0xebd6),\n\tcompassActive: register('compass-active', 0xebd7),\n\tazure: register('azure', 0xebd8),\n\tissueDraft: register('issue-draft', 0xebd9),\n\tgitPullRequestClosed: register('git-pull-request-closed', 0xebda),\n\tgitPullRequestDraft: register('git-pull-request-draft', 0xebdb),\n\tdebugAll: register('debug-all', 0xebdc),\n\tdebugCoverage: register('debug-coverage', 0xebdd),\n\trunErrors: register('run-errors', 0xebde),\n\tfolderLibrary: register('folder-library', 0xebdf),\n\tdebugContinueSmall: register('debug-continue-small', 0xebe0),\n\tbeakerStop: register('beaker-stop', 0xebe1),\n\tgraphLine: register('graph-line', 0xebe2),\n\tgraphScatter: register('graph-scatter', 0xebe3),\n\tpieChart: register('pie-chart', 0xebe4),\n\tbracket: register('bracket', 0xeb0f),\n\tbracketDot: register('bracket-dot', 0xebe5),\n\tbracketError: register('bracket-error', 0xebe6),\n\tlockSmall: register('lock-small', 0xebe7),\n\tazureDevops: register('azure-devops', 0xebe8),\n\tverifiedFilled: register('verified-filled', 0xebe9),\n\tnewline: register('newline', 0xebea),\n\tlayout: register('layout', 0xebeb),\n\tlayoutActivitybarLeft: register('layout-activitybar-left', 0xebec),\n\tlayoutActivitybarRight: register('layout-activitybar-right', 0xebed),\n\tlayoutPanelLeft: register('layout-panel-left', 0xebee),\n\tlayoutPanelCenter: register('layout-panel-center', 0xebef),\n\tlayoutPanelJustify: register('layout-panel-justify', 0xebf0),\n\tlayoutPanelRight: register('layout-panel-right', 0xebf1),\n\tlayoutPanel: register('layout-panel', 0xebf2),\n\tlayoutSidebarLeft: register('layout-sidebar-left', 0xebf3),\n\tlayoutSidebarRight: register('layout-sidebar-right', 0xebf4),\n\tlayoutStatusbar: register('layout-statusbar', 0xebf5),\n\tlayoutMenubar: register('layout-menubar', 0xebf6),\n\tlayoutCentered: register('layout-centered', 0xebf7),\n\ttarget: register('target', 0xebf8),\n\tindent: register('indent', 0xebf9),\n\trecordSmall: register('record-small', 0xebfa),\n\terrorSmall: register('error-small', 0xebfb),\n\tterminalDecorationError: register('terminal-decoration-error', 0xebfb),\n\tarrowCircleDown: register('arrow-circle-down', 0xebfc),\n\tarrowCircleLeft: register('arrow-circle-left', 0xebfd),\n\tarrowCircleRight: register('arrow-circle-right', 0xebfe),\n\tarrowCircleUp: register('arrow-circle-up', 0xebff),\n\tlayoutSidebarRightOff: register('layout-sidebar-right-off', 0xec00),\n\tlayoutPanelOff: register('layout-panel-off', 0xec01),\n\tlayoutSidebarLeftOff: register('layout-sidebar-left-off', 0xec02),\n\tblank: register('blank', 0xec03),\n\theartFilled: register('heart-filled', 0xec04),\n\tmap: register('map', 0xec05),\n\tmapHorizontal: register('map-horizontal', 0xec05),\n\tfoldHorizontal: register('fold-horizontal', 0xec05),\n\tmapFilled: register('map-filled', 0xec06),\n\tmapHorizontalFilled: register('map-horizontal-filled', 0xec06),\n\tfoldHorizontalFilled: register('fold-horizontal-filled', 0xec06),\n\tcircleSmall: register('circle-small', 0xec07),\n\tbellSlash: register('bell-slash', 0xec08),\n\tbellSlashDot: register('bell-slash-dot', 0xec09),\n\tcommentUnresolved: register('comment-unresolved', 0xec0a),\n\tgitPullRequestGoToChanges: register('git-pull-request-go-to-changes', 0xec0b),\n\tgitPullRequestNewChanges: register('git-pull-request-new-changes', 0xec0c),\n\tsearchFuzzy: register('search-fuzzy', 0xec0d),\n\tcommentDraft: register('comment-draft', 0xec0e),\n\tsend: register('send', 0xec0f),\n\tsparkle: register('sparkle', 0xec10),\n\tinsert: register('insert', 0xec11),\n\tmic: register('mic', 0xec12),\n\tthumbsdownFilled: register('thumbsdown-filled', 0xec13),\n\tthumbsupFilled: register('thumbsup-filled', 0xec14),\n\tcoffee: register('coffee', 0xec15),\n\tsnake: register('snake', 0xec16),\n\tgame: register('game', 0xec17),\n\tvr: register('vr', 0xec18),\n\tchip: register('chip', 0xec19),\n\tpiano: register('piano', 0xec1a),\n\tmusic: register('music', 0xec1b),\n\tmicFilled: register('mic-filled', 0xec1c),\n\trepoFetch: register('repo-fetch', 0xec1d),\n\tcopilot: register('copilot', 0xec1e),\n\tlightbulbSparkle: register('lightbulb-sparkle', 0xec1f),\n\trobot: register('robot', 0xec20),\n\tsparkleFilled: register('sparkle-filled', 0xec21),\n\tdiffSingle: register('diff-single', 0xec22),\n\tdiffMultiple: register('diff-multiple', 0xec23),\n\tsurroundWith: register('surround-with', 0xec24),\n\tshare: register('share', 0xec25),\n\tgitStash: register('git-stash', 0xec26),\n\tgitStashApply: register('git-stash-apply', 0xec27),\n\tgitStashPop: register('git-stash-pop', 0xec28),\n\tvscode: register('vscode', 0xec29),\n\tvscodeInsiders: register('vscode-insiders', 0xec2a),\n\tcodeOss: register('code-oss', 0xec2b),\n\trunCoverage: register('run-coverage', 0xec2c),\n\trunAllCoverage: register('run-all-coverage', 0xec2d),\n\tcoverage: register('coverage', 0xec2e),\n\tgithubProject: register('github-project', 0xec2f),\n\tmapVertical: register('map-vertical', 0xec30),\n\tfoldVertical: register('fold-vertical', 0xec30),\n\tmapVerticalFilled: register('map-vertical-filled', 0xec31),\n\tfoldVerticalFilled: register('fold-vertical-filled', 0xec31),\n\tgoToSearch: register('go-to-search', 0xec32),\n\tpercentage: register('percentage', 0xec33),\n\tsortPercentage: register('sort-percentage', 0xec33),\n\tattach: register('attach', 0xec34),\n\tgoToEditingSession: register('go-to-editing-session', 0xec35),\n\teditSession: register('edit-session', 0xec36),\n\tcodeReview: register('code-review', 0xec37),\n\tcopilotWarning: register('copilot-warning', 0xec38),\n\tpython: register('python', 0xec39),\n\tcopilotLarge: register('copilot-large', 0xec3a),\n\tcopilotWarningLarge: register('copilot-warning-large', 0xec3b),\n\tkeyboardTab: register('keyboard-tab', 0xec3c),\n\tcopilotBlocked: register('copilot-blocked', 0xec3d),\n\tcopilotNotConnected: register('copilot-not-connected', 0xec3e),\n\tflag: register('flag', 0xec3f),\n\tlightbulbEmpty: register('lightbulb-empty', 0xec40),\n\tsymbolMethodArrow: register('symbol-method-arrow', 0xec41),\n\tcopilotUnavailable: register('copilot-unavailable', 0xec42),\n\trepoPinned: register('repo-pinned', 0xec43),\n\tkeyboardTabAbove: register('keyboard-tab-above', 0xec44),\n\tkeyboardTabBelow: register('keyboard-tab-below', 0xec45),\n\tgitPullRequestDone: register('git-pull-request-done', 0xec46),\n\tmcp: register('mcp', 0xec47),\n\textensionsLarge: register('extensions-large', 0xec48),\n\tlayoutPanelDock: register('layout-panel-dock', 0xec49),\n\tlayoutSidebarLeftDock: register('layout-sidebar-left-dock', 0xec4a),\n\tlayoutSidebarRightDock: register('layout-sidebar-right-dock', 0xec4b),\n\tcopilotInProgress: register('copilot-in-progress', 0xec4c),\n\tcopilotError: register('copilot-error', 0xec4d),\n\tcopilotSuccess: register('copilot-success', 0xec4e),\n\tchatSparkle: register('chat-sparkle', 0xec4f),\n\tsearchSparkle: register('search-sparkle', 0xec50),\n\teditSparkle: register('edit-sparkle', 0xec51),\n\tcopilotSnooze: register('copilot-snooze', 0xec52),\n\tsendToRemoteAgent: register('send-to-remote-agent', 0xec53),\n\tcommentDiscussionSparkle: register('comment-discussion-sparkle', 0xec54),\n\tchatSparkleWarning: register('chat-sparkle-warning', 0xec55),\n\tchatSparkleError: register('chat-sparkle-error', 0xec56),\n\tcollection: register('collection', 0xec57),\n\tnewCollection: register('new-collection', 0xec58),\n\tthinking: register('thinking', 0xec59),\n} as const;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { register } from './codiconsUtil.js';\n\n\n// This file is automatically generated by (microsoft/vscode-codicons)/scripts/export-to-ts.js\n// Please don't edit it, as your changes will be overwritten.\n// Instead, add mappings to codiconsDerived in codicons.ts.\nexport const codiconsLibrary = {\n\tadd: register('add', 0xea60),\n\tplus: register('plus', 0xea60),\n\tgistNew: register('gist-new', 0xea60),\n\trepoCreate: register('repo-create', 0xea60),\n\tlightbulb: register('lightbulb', 0xea61),\n\tlightBulb: register('light-bulb', 0xea61),\n\trepo: register('repo', 0xea62),\n\trepoDelete: register('repo-delete', 0xea62),\n\tgistFork: register('gist-fork', 0xea63),\n\trepoForked: register('repo-forked', 0xea63),\n\tgitPullRequest: register('git-pull-request', 0xea64),\n\tgitPullRequestAbandoned: register('git-pull-request-abandoned', 0xea64),\n\trecordKeys: register('record-keys', 0xea65),\n\tkeyboard: register('keyboard', 0xea65),\n\ttag: register('tag', 0xea66),\n\tgitPullRequestLabel: register('git-pull-request-label', 0xea66),\n\ttagAdd: register('tag-add', 0xea66),\n\ttagRemove: register('tag-remove', 0xea66),\n\tperson: register('person', 0xea67),\n\tpersonFollow: register('person-follow', 0xea67),\n\tpersonOutline: register('person-outline', 0xea67),\n\tpersonFilled: register('person-filled', 0xea67),\n\tgitBranch: register('git-branch', 0xea68),\n\tgitBranchCreate: register('git-branch-create', 0xea68),\n\tgitBranchDelete: register('git-branch-delete', 0xea68),\n\tsourceControl: register('source-control', 0xea68),\n\tmirror: register('mirror', 0xea69),\n\tmirrorPublic: register('mirror-public', 0xea69),\n\tstar: register('star', 0xea6a),\n\tstarAdd: register('star-add', 0xea6a),\n\tstarDelete: register('star-delete', 0xea6a),\n\tstarEmpty: register('star-empty', 0xea6a),\n\tcomment: register('comment', 0xea6b),\n\tcommentAdd: register('comment-add', 0xea6b),\n\talert: register('alert', 0xea6c),\n\twarning: register('warning', 0xea6c),\n\tsearch: register('search', 0xea6d),\n\tsearchSave: register('search-save', 0xea6d),\n\tlogOut: register('log-out', 0xea6e),\n\tsignOut: register('sign-out', 0xea6e),\n\tlogIn: register('log-in', 0xea6f),\n\tsignIn: register('sign-in', 0xea6f),\n\teye: register('eye', 0xea70),\n\teyeUnwatch: register('eye-unwatch', 0xea70),\n\teyeWatch: register('eye-watch', 0xea70),\n\tcircleFilled: register('circle-filled', 0xea71),\n\tprimitiveDot: register('primitive-dot', 0xea71),\n\tcloseDirty: register('close-dirty', 0xea71),\n\tdebugBreakpoint: register('debug-breakpoint', 0xea71),\n\tdebugBreakpointDisabled: register('debug-breakpoint-disabled', 0xea71),\n\tdebugHint: register('debug-hint', 0xea71),\n\tterminalDecorationSuccess: register('terminal-decoration-success', 0xea71),\n\tprimitiveSquare: register('primitive-square', 0xea72),\n\tedit: register('edit', 0xea73),\n\tpencil: register('pencil', 0xea73),\n\tinfo: register('info', 0xea74),\n\tissueOpened: register('issue-opened', 0xea74),\n\tgistPrivate: register('gist-private', 0xea75),\n\tgitForkPrivate: register('git-fork-private', 0xea75),\n\tlock: register('lock', 0xea75),\n\tmirrorPrivate: register('mirror-private', 0xea75),\n\tclose: register('close', 0xea76),\n\tremoveClose: register('remove-close', 0xea76),\n\tx: register('x', 0xea76),\n\trepoSync: register('repo-sync', 0xea77),\n\tsync: register('sync', 0xea77),\n\tclone: register('clone', 0xea78),\n\tdesktopDownload: register('desktop-download', 0xea78),\n\tbeaker: register('beaker', 0xea79),\n\tmicroscope: register('microscope', 0xea79),\n\tvm: register('vm', 0xea7a),\n\tdeviceDesktop: register('device-desktop', 0xea7a),\n\tfile: register('file', 0xea7b),\n\tfileText: register('file-text', 0xea7b),\n\tmore: register('more', 0xea7c),\n\tellipsis: register('ellipsis', 0xea7c),\n\tkebabHorizontal: register('kebab-horizontal', 0xea7c),\n\tmailReply: register('mail-reply', 0xea7d),\n\treply: register('reply', 0xea7d),\n\torganization: register('organization', 0xea7e),\n\torganizationFilled: register('organization-filled', 0xea7e),\n\torganizationOutline: register('organization-outline', 0xea7e),\n\tnewFile: register('new-file', 0xea7f),\n\tfileAdd: register('file-add', 0xea7f),\n\tnewFolder: register('new-folder', 0xea80),\n\tfileDirectoryCreate: register('file-directory-create', 0xea80),\n\ttrash: register('trash', 0xea81),\n\ttrashcan: register('trashcan', 0xea81),\n\thistory: register('history', 0xea82),\n\tclock: register('clock', 0xea82),\n\tfolder: register('folder', 0xea83),\n\tfileDirectory: register('file-directory', 0xea83),\n\tsymbolFolder: register('symbol-folder', 0xea83),\n\tlogoGithub: register('logo-github', 0xea84),\n\tmarkGithub: register('mark-github', 0xea84),\n\tgithub: register('github', 0xea84),\n\tterminal: register('terminal', 0xea85),\n\tconsole: register('console', 0xea85),\n\trepl: register('repl', 0xea85),\n\tzap: register('zap', 0xea86),\n\tsymbolEvent: register('symbol-event', 0xea86),\n\terror: register('error', 0xea87),\n\tstop: register('stop', 0xea87),\n\tvariable: register('variable', 0xea88),\n\tsymbolVariable: register('symbol-variable', 0xea88),\n\tarray: register('array', 0xea8a),\n\tsymbolArray: register('symbol-array', 0xea8a),\n\tsymbolModule: register('symbol-module', 0xea8b),\n\tsymbolPackage: register('symbol-package', 0xea8b),\n\tsymbolNamespace: register('symbol-namespace', 0xea8b),\n\tsymbolObject: register('symbol-object', 0xea8b),\n\tsymbolMethod: register('symbol-method', 0xea8c),\n\tsymbolFunction: register('symbol-function', 0xea8c),\n\tsymbolConstructor: register('symbol-constructor', 0xea8c),\n\tsymbolBoolean: register('symbol-boolean', 0xea8f),\n\tsymbolNull: register('symbol-null', 0xea8f),\n\tsymbolNumeric: register('symbol-numeric', 0xea90),\n\tsymbolNumber: register('symbol-number', 0xea90),\n\tsymbolStructure: register('symbol-structure', 0xea91),\n\tsymbolStruct: register('symbol-struct', 0xea91),\n\tsymbolParameter: register('symbol-parameter', 0xea92),\n\tsymbolTypeParameter: register('symbol-type-parameter', 0xea92),\n\tsymbolKey: register('symbol-key', 0xea93),\n\tsymbolText: register('symbol-text', 0xea93),\n\tsymbolReference: register('symbol-reference', 0xea94),\n\tgoToFile: register('go-to-file', 0xea94),\n\tsymbolEnum: register('symbol-enum', 0xea95),\n\tsymbolValue: register('symbol-value', 0xea95),\n\tsymbolRuler: register('symbol-ruler', 0xea96),\n\tsymbolUnit: register('symbol-unit', 0xea96),\n\tactivateBreakpoints: register('activate-breakpoints', 0xea97),\n\tarchive: register('archive', 0xea98),\n\tarrowBoth: register('arrow-both', 0xea99),\n\tarrowDown: register('arrow-down', 0xea9a),\n\tarrowLeft: register('arrow-left', 0xea9b),\n\tarrowRight: register('arrow-right', 0xea9c),\n\tarrowSmallDown: register('arrow-small-down', 0xea9d),\n\tarrowSmallLeft: register('arrow-small-left', 0xea9e),\n\tarrowSmallRight: register('arrow-small-right', 0xea9f),\n\tarrowSmallUp: register('arrow-small-up', 0xeaa0),\n\tarrowUp: register('arrow-up', 0xeaa1),\n\tbell: register('bell', 0xeaa2),\n\tbold: register('bold', 0xeaa3),\n\tbook: register('book', 0xeaa4),\n\tbookmark: register('bookmark', 0xeaa5),\n\tdebugBreakpointConditionalUnverified: register('debug-breakpoint-conditional-unverified', 0xeaa6),\n\tdebugBreakpointConditional: register('debug-breakpoint-conditional', 0xeaa7),\n\tdebugBreakpointConditionalDisabled: register('debug-breakpoint-conditional-disabled', 0xeaa7),\n\tdebugBreakpointDataUnverified: register('debug-breakpoint-data-unverified', 0xeaa8),\n\tdebugBreakpointData: register('debug-breakpoint-data', 0xeaa9),\n\tdebugBreakpointDataDisabled: register('debug-breakpoint-data-disabled', 0xeaa9),\n\tdebugBreakpointLogUnverified: register('debug-breakpoint-log-unverified', 0xeaaa),\n\tdebugBreakpointLog: register('debug-breakpoint-log', 0xeaab),\n\tdebugBreakpointLogDisabled: register('debug-breakpoint-log-disabled', 0xeaab),\n\tbriefcase: register('briefcase', 0xeaac),\n\tbroadcast: register('broadcast', 0xeaad),\n\tbrowser: register('browser', 0xeaae),\n\tbug: register('bug', 0xeaaf),\n\tcalendar: register('calendar', 0xeab0),\n\tcaseSensitive: register('case-sensitive', 0xeab1),\n\tcheck: register('check', 0xeab2),\n\tchecklist: register('checklist', 0xeab3),\n\tchevronDown: register('chevron-down', 0xeab4),\n\tchevronLeft: register('chevron-left', 0xeab5),\n\tchevronRight: register('chevron-right', 0xeab6),\n\tchevronUp: register('chevron-up', 0xeab7),\n\tchromeClose: register('chrome-close', 0xeab8),\n\tchromeMaximize: register('chrome-maximize', 0xeab9),\n\tchromeMinimize: register('chrome-minimize', 0xeaba),\n\tchromeRestore: register('chrome-restore', 0xeabb),\n\tcircleOutline: register('circle-outline', 0xeabc),\n\tcircle: register('circle', 0xeabc),\n\tdebugBreakpointUnverified: register('debug-breakpoint-unverified', 0xeabc),\n\tterminalDecorationIncomplete: register('terminal-decoration-incomplete', 0xeabc),\n\tcircleSlash: register('circle-slash', 0xeabd),\n\tcircuitBoard: register('circuit-board', 0xeabe),\n\tclearAll: register('clear-all', 0xeabf),\n\tclippy: register('clippy', 0xeac0),\n\tcloseAll: register('close-all', 0xeac1),\n\tcloudDownload: register('cloud-download', 0xeac2),\n\tcloudUpload: register('cloud-upload', 0xeac3),\n\tcode: register('code', 0xeac4),\n\tcollapseAll: register('collapse-all', 0xeac5),\n\tcolorMode: register('color-mode', 0xeac6),\n\tcommentDiscussion: register('comment-discussion', 0xeac7),\n\tcreditCard: register('credit-card', 0xeac9),\n\tdash: register('dash', 0xeacc),\n\tdashboard: register('dashboard', 0xeacd),\n\tdatabase: register('database', 0xeace),\n\tdebugContinue: register('debug-continue', 0xeacf),\n\tdebugDisconnect: register('debug-disconnect', 0xead0),\n\tdebugPause: register('debug-pause', 0xead1),\n\tdebugRestart: register('debug-restart', 0xead2),\n\tdebugStart: register('debug-start', 0xead3),\n\tdebugStepInto: register('debug-step-into', 0xead4),\n\tdebugStepOut: register('debug-step-out', 0xead5),\n\tdebugStepOver: register('debug-step-over', 0xead6),\n\tdebugStop: register('debug-stop', 0xead7),\n\tdebug: register('debug', 0xead8),\n\tdeviceCameraVideo: register('device-camera-video', 0xead9),\n\tdeviceCamera: register('device-camera', 0xeada),\n\tdeviceMobile: register('device-mobile', 0xeadb),\n\tdiffAdded: register('diff-added', 0xeadc),\n\tdiffIgnored: register('diff-ignored', 0xeadd),\n\tdiffModified: register('diff-modified', 0xeade),\n\tdiffRemoved: register('diff-removed', 0xeadf),\n\tdiffRenamed: register('diff-renamed', 0xeae0),\n\tdiff: register('diff', 0xeae1),\n\tdiffSidebyside: register('diff-sidebyside', 0xeae1),\n\tdiscard: register('discard', 0xeae2),\n\teditorLayout: register('editor-layout', 0xeae3),\n\temptyWindow: register('empty-window', 0xeae4),\n\texclude: register('exclude', 0xeae5),\n\textensions: register('extensions', 0xeae6),\n\teyeClosed: register('eye-closed', 0xeae7),\n\tfileBinary: register('file-binary', 0xeae8),\n\tfileCode: register('file-code', 0xeae9),\n\tfileMedia: register('file-media', 0xeaea),\n\tfilePdf: register('file-pdf', 0xeaeb),\n\tfileSubmodule: register('file-submodule', 0xeaec),\n\tfileSymlinkDirectory: register('file-symlink-directory', 0xeaed),\n\tfileSymlinkFile: register('file-symlink-file', 0xeaee),\n\tfileZip: register('file-zip', 0xeaef),\n\tfiles: register('files', 0xeaf0),\n\tfilter: register('filter', 0xeaf1),\n\tflame: register('flame', 0xeaf2),\n\tfoldDown: register('fold-down', 0xeaf3),\n\tfoldUp: register('fold-up', 0xeaf4),\n\tfold: register('fold', 0xeaf5),\n\tfolderActive: register('folder-active', 0xeaf6),\n\tfolderOpened: register('folder-opened', 0xeaf7),\n\tgear: register('gear', 0xeaf8),\n\tgift: register('gift', 0xeaf9),\n\tgistSecret: register('gist-secret', 0xeafa),\n\tgist: register('gist', 0xeafb),\n\tgitCommit: register('git-commit', 0xeafc),\n\tgitCompare: register('git-compare', 0xeafd),\n\tcompareChanges: register('compare-changes', 0xeafd),\n\tgitMerge: register('git-merge', 0xeafe),\n\tgithubAction: register('github-action', 0xeaff),\n\tgithubAlt: register('github-alt', 0xeb00),\n\tglobe: register('globe', 0xeb01),\n\tgrabber: register('grabber', 0xeb02),\n\tgraph: register('graph', 0xeb03),\n\tgripper: register('gripper', 0xeb04),\n\theart: register('heart', 0xeb05),\n\thome: register('home', 0xeb06),\n\thorizontalRule: register('horizontal-rule', 0xeb07),\n\thubot: register('hubot', 0xeb08),\n\tinbox: register('inbox', 0xeb09),\n\tissueReopened: register('issue-reopened', 0xeb0b),\n\tissues: register('issues', 0xeb0c),\n\titalic: register('italic', 0xeb0d),\n\tjersey: register('jersey', 0xeb0e),\n\tjson: register('json', 0xeb0f),\n\tkebabVertical: register('kebab-vertical', 0xeb10),\n\tkey: register('key', 0xeb11),\n\tlaw: register('law', 0xeb12),\n\tlightbulbAutofix: register('lightbulb-autofix', 0xeb13),\n\tlinkExternal: register('link-external', 0xeb14),\n\tlink: register('link', 0xeb15),\n\tlistOrdered: register('list-ordered', 0xeb16),\n\tlistUnordered: register('list-unordered', 0xeb17),\n\tliveShare: register('live-share', 0xeb18),\n\tloading: register('loading', 0xeb19),\n\tlocation: register('location', 0xeb1a),\n\tmailRead: register('mail-read', 0xeb1b),\n\tmail: register('mail', 0xeb1c),\n\tmarkdown: register('markdown', 0xeb1d),\n\tmegaphone: register('megaphone', 0xeb1e),\n\tmention: register('mention', 0xeb1f),\n\tmilestone: register('milestone', 0xeb20),\n\tgitPullRequestMilestone: register('git-pull-request-milestone', 0xeb20),\n\tmortarBoard: register('mortar-board', 0xeb21),\n\tmove: register('move', 0xeb22),\n\tmultipleWindows: register('multiple-windows', 0xeb23),\n\tmute: register('mute', 0xeb24),\n\tnoNewline: register('no-newline', 0xeb25),\n\tnote: register('note', 0xeb26),\n\toctoface: register('octoface', 0xeb27),\n\topenPreview: register('open-preview', 0xeb28),\n\tpackage: register('package', 0xeb29),\n\tpaintcan: register('paintcan', 0xeb2a),\n\tpin: register('pin', 0xeb2b),\n\tplay: register('play', 0xeb2c),\n\trun: register('run', 0xeb2c),\n\tplug: register('plug', 0xeb2d),\n\tpreserveCase: register('preserve-case', 0xeb2e),\n\tpreview: register('preview', 0xeb2f),\n\tproject: register('project', 0xeb30),\n\tpulse: register('pulse', 0xeb31),\n\tquestion: register('question', 0xeb32),\n\tquote: register('quote', 0xeb33),\n\tradioTower: register('radio-tower', 0xeb34),\n\treactions: register('reactions', 0xeb35),\n\treferences: register('references', 0xeb36),\n\trefresh: register('refresh', 0xeb37),\n\tregex: register('regex', 0xeb38),\n\tremoteExplorer: register('remote-explorer', 0xeb39),\n\tremote: register('remote', 0xeb3a),\n\tremove: register('remove', 0xeb3b),\n\treplaceAll: register('replace-all', 0xeb3c),\n\treplace: register('replace', 0xeb3d),\n\trepoClone: register('repo-clone', 0xeb3e),\n\trepoForcePush: register('repo-force-push', 0xeb3f),\n\trepoPull: register('repo-pull', 0xeb40),\n\trepoPush: register('repo-push', 0xeb41),\n\treport: register('report', 0xeb42),\n\trequestChanges: register('request-changes', 0xeb43),\n\trocket: register('rocket', 0xeb44),\n\trootFolderOpened: register('root-folder-opened', 0xeb45),\n\trootFolder: register('root-folder', 0xeb46),\n\trss: register('rss', 0xeb47),\n\truby: register('ruby', 0xeb48),\n\tsaveAll: register('save-all', 0xeb49),\n\tsaveAs: register('save-as', 0xeb4a),\n\tsave: register('save', 0xeb4b),\n\tscreenFull: register('screen-full', 0xeb4c),\n\tscreenNormal: register('screen-normal', 0xeb4d),\n\tsearchStop: register('search-stop', 0xeb4e),\n\tserver: register('server', 0xeb50),\n\tsettingsGear: register('settings-gear', 0xeb51),\n\tsettings: register('settings', 0xeb52),\n\tshield: register('shield', 0xeb53),\n\tsmiley: register('smiley', 0xeb54),\n\tsortPrecedence: register('sort-precedence', 0xeb55),\n\tsplitHorizontal: register('split-horizontal', 0xeb56),\n\tsplitVertical: register('split-vertical', 0xeb57),\n\tsquirrel: register('squirrel', 0xeb58),\n\tstarFull: register('star-full', 0xeb59),\n\tstarHalf: register('star-half', 0xeb5a),\n\tsymbolClass: register('symbol-class', 0xeb5b),\n\tsymbolColor: register('symbol-color', 0xeb5c),\n\tsymbolConstant: register('symbol-constant', 0xeb5d),\n\tsymbolEnumMember: register('symbol-enum-member', 0xeb5e),\n\tsymbolField: register('symbol-field', 0xeb5f),\n\tsymbolFile: register('symbol-file', 0xeb60),\n\tsymbolInterface: register('symbol-interface', 0xeb61),\n\tsymbolKeyword: register('symbol-keyword', 0xeb62),\n\tsymbolMisc: register('symbol-misc', 0xeb63),\n\tsymbolOperator: register('symbol-operator', 0xeb64),\n\tsymbolProperty: register('symbol-property', 0xeb65),\n\twrench: register('wrench', 0xeb65),\n\twrenchSubaction: register('wrench-subaction', 0xeb65),\n\tsymbolSnippet: register('symbol-snippet', 0xeb66),\n\ttasklist: register('tasklist', 0xeb67),\n\ttelescope: register('telescope', 0xeb68),\n\ttextSize: register('text-size', 0xeb69),\n\tthreeBars: register('three-bars', 0xeb6a),\n\tthumbsdown: register('thumbsdown', 0xeb6b),\n\tthumbsup: register('thumbsup', 0xeb6c),\n\ttools: register('tools', 0xeb6d),\n\ttriangleDown: register('triangle-down', 0xeb6e),\n\ttriangleLeft: register('triangle-left', 0xeb6f),\n\ttriangleRight: register('triangle-right', 0xeb70),\n\ttriangleUp: register('triangle-up', 0xeb71),\n\ttwitter: register('twitter', 0xeb72),\n\tunfold: register('unfold', 0xeb73),\n\tunlock: register('unlock', 0xeb74),\n\tunmute: register('unmute', 0xeb75),\n\tunverified: register('unverified', 0xeb76),\n\tverified: register('verified', 0xeb77),\n\tversions: register('versions', 0xeb78),\n\tvmActive: register('vm-active', 0xeb79),\n\tvmOutline: register('vm-outline', 0xeb7a),\n\tvmRunning: register('vm-running', 0xeb7b),\n\twatch: register('watch', 0xeb7c),\n\twhitespace: register('whitespace', 0xeb7d),\n\twholeWord: register('whole-word', 0xeb7e),\n\twindow: register('window', 0xeb7f),\n\twordWrap: register('word-wrap', 0xeb80),\n\tzoomIn: register('zoom-in', 0xeb81),\n\tzoomOut: register('zoom-out', 0xeb82),\n\tlistFilter: register('list-filter', 0xeb83),\n\tlistFlat: register('list-flat', 0xeb84),\n\tlistSelection: register('list-selection', 0xeb85),\n\tselection: register('selection', 0xeb85),\n\tlistTree: register('list-tree', 0xeb86),\n\tdebugBreakpointFunctionUnverified: register('debug-breakpoint-function-unverified', 0xeb87),\n\tdebugBreakpointFunction: register('debug-breakpoint-function', 0xeb88),\n\tdebugBreakpointFunctionDisabled: register('debug-breakpoint-function-disabled', 0xeb88),\n\tdebugStackframeActive: register('debug-stackframe-active', 0xeb89),\n\tcircleSmallFilled: register('circle-small-filled', 0xeb8a),\n\tdebugStackframeDot: register('debug-stackframe-dot', 0xeb8a),\n\tterminalDecorationMark: register('terminal-decoration-mark', 0xeb8a),\n\tdebugStackframe: register('debug-stackframe', 0xeb8b),\n\tdebugStackframeFocused: register('debug-stackframe-focused', 0xeb8b),\n\tdebugBreakpointUnsupported: register('debug-breakpoint-unsupported', 0xeb8c),\n\tsymbolString: register('symbol-string', 0xeb8d),\n\tdebugReverseContinue: register('debug-reverse-continue', 0xeb8e),\n\tdebugStepBack: register('debug-step-back', 0xeb8f),\n\tdebugRestartFrame: register('debug-restart-frame', 0xeb90),\n\tdebugAlt: register('debug-alt', 0xeb91),\n\tcallIncoming: register('call-incoming', 0xeb92),\n\tcallOutgoing: register('call-outgoing', 0xeb93),\n\tmenu: register('menu', 0xeb94),\n\texpandAll: register('expand-all', 0xeb95),\n\tfeedback: register('feedback', 0xeb96),\n\tgitPullRequestReviewer: register('git-pull-request-reviewer', 0xeb96),\n\tgroupByRefType: register('group-by-ref-type', 0xeb97),\n\tungroupByRefType: register('ungroup-by-ref-type', 0xeb98),\n\taccount: register('account', 0xeb99),\n\tgitPullRequestAssignee: register('git-pull-request-assignee', 0xeb99),\n\tbellDot: register('bell-dot', 0xeb9a),\n\tdebugConsole: register('debug-console', 0xeb9b),\n\tlibrary: register('library', 0xeb9c),\n\toutput: register('output', 0xeb9d),\n\trunAll: register('run-all', 0xeb9e),\n\tsyncIgnored: register('sync-ignored', 0xeb9f),\n\tpinned: register('pinned', 0xeba0),\n\tgithubInverted: register('github-inverted', 0xeba1),\n\tserverProcess: register('server-process', 0xeba2),\n\tserverEnvironment: register('server-environment', 0xeba3),\n\tpass: register('pass', 0xeba4),\n\tissueClosed: register('issue-closed', 0xeba4),\n\tstopCircle: register('stop-circle', 0xeba5),\n\tplayCircle: register('play-circle', 0xeba6),\n\trecord: register('record', 0xeba7),\n\tdebugAltSmall: register('debug-alt-small', 0xeba8),\n\tvmConnect: register('vm-connect', 0xeba9),\n\tcloud: register('cloud', 0xebaa),\n\tmerge: register('merge', 0xebab),\n\texport: register('export', 0xebac),\n\tgraphLeft: register('graph-left', 0xebad),\n\tmagnet: register('magnet', 0xebae),\n\tnotebook: register('notebook', 0xebaf),\n\tredo: register('redo', 0xebb0),\n\tcheckAll: register('check-all', 0xebb1),\n\tpinnedDirty: register('pinned-dirty', 0xebb2),\n\tpassFilled: register('pass-filled', 0xebb3),\n\tcircleLargeFilled: register('circle-large-filled', 0xebb4),\n\tcircleLarge: register('circle-large', 0xebb5),\n\tcircleLargeOutline: register('circle-large-outline', 0xebb5),\n\tcombine: register('combine', 0xebb6),\n\tgather: register('gather', 0xebb6),\n\ttable: register('table', 0xebb7),\n\tvariableGroup: register('variable-group', 0xebb8),\n\ttypeHierarchy: register('type-hierarchy', 0xebb9),\n\ttypeHierarchySub: register('type-hierarchy-sub', 0xebba),\n\ttypeHierarchySuper: register('type-hierarchy-super', 0xebbb),\n\tgitPullRequestCreate: register('git-pull-request-create', 0xebbc),\n\trunAbove: register('run-above', 0xebbd),\n\trunBelow: register('run-below', 0xebbe),\n\tnotebookTemplate: register('notebook-template', 0xebbf),\n\tdebugRerun: register('debug-rerun', 0xebc0),\n\tworkspaceTrusted: register('workspace-trusted', 0xebc1),\n\tworkspaceUntrusted: register('workspace-untrusted', 0xebc2),\n\tworkspaceUnknown: register('workspace-unknown', 0xebc3),\n\tterminalCmd: register('terminal-cmd', 0xebc4),\n\tterminalDebian: register('terminal-debian', 0xebc5),\n\tterminalLinux: register('terminal-linux', 0xebc6),\n\tterminalPowershell: register('terminal-powershell', 0xebc7),\n\tterminalTmux: register('terminal-tmux', 0xebc8),\n\tterminalUbuntu: register('terminal-ubuntu', 0xebc9),\n\tterminalBash: register('terminal-bash', 0xebca),\n\tarrowSwap: register('arrow-swap', 0xebcb),\n\tcopy: register('copy', 0xebcc),\n\tpersonAdd: register('person-add', 0xebcd),\n\tfilterFilled: register('filter-filled', 0xebce),\n\twand: register('wand', 0xebcf),\n\tdebugLineByLine: register('debug-line-by-line', 0xebd0),\n\tinspect: register('inspect', 0xebd1),\n\tlayers: register('layers', 0xebd2),\n\tlayersDot: register('layers-dot', 0xebd3),\n\tlayersActive: register('layers-active', 0xebd4),\n\tcompass: register('compass', 0xebd5),\n\tcompassDot: register('compass-dot', 0xebd6),\n\tcompassActive: register('compass-active', 0xebd7),\n\tazure: register('azure', 0xebd8),\n\tissueDraft: register('issue-draft', 0xebd9),\n\tgitPullRequestClosed: register('git-pull-request-closed', 0xebda),\n\tgitPullRequestDraft: register('git-pull-request-draft', 0xebdb),\n\tdebugAll: register('debug-all', 0xebdc),\n\tdebugCoverage: register('debug-coverage', 0xebdd),\n\trunErrors: register('run-errors', 0xebde),\n\tfolderLibrary: register('folder-library', 0xebdf),\n\tdebugContinueSmall: register('debug-continue-small', 0xebe0),\n\tbeakerStop: register('beaker-stop', 0xebe1),\n\tgraphLine: register('graph-line', 0xebe2),\n\tgraphScatter: register('graph-scatter', 0xebe3),\n\tpieChart: register('pie-chart', 0xebe4),\n\tbracket: register('bracket', 0xeb0f),\n\tbracketDot: register('bracket-dot', 0xebe5),\n\tbracketError: register('bracket-error', 0xebe6),\n\tlockSmall: register('lock-small', 0xebe7),\n\tazureDevops: register('azure-devops', 0xebe8),\n\tverifiedFilled: register('verified-filled', 0xebe9),\n\tnewline: register('newline', 0xebea),\n\tlayout: register('layout', 0xebeb),\n\tlayoutActivitybarLeft: register('layout-activitybar-left', 0xebec),\n\tlayoutActivitybarRight: register('layout-activitybar-right', 0xebed),\n\tlayoutPanelLeft: register('layout-panel-left', 0xebee),\n\tlayoutPanelCenter: register('layout-panel-center', 0xebef),\n\tlayoutPanelJustify: register('layout-panel-justify', 0xebf0),\n\tlayoutPanelRight: register('layout-panel-right', 0xebf1),\n\tlayoutPanel: register('layout-panel', 0xebf2),\n\tlayoutSidebarLeft: register('layout-sidebar-left', 0xebf3),\n\tlayoutSidebarRight: register('layout-sidebar-right', 0xebf4),\n\tlayoutStatusbar: register('layout-statusbar', 0xebf5),\n\tlayoutMenubar: register('layout-menubar', 0xebf6),\n\tlayoutCentered: register('layout-centered', 0xebf7),\n\ttarget: register('target', 0xebf8),\n\tindent: register('indent', 0xebf9),\n\trecordSmall: register('record-small', 0xebfa),\n\terrorSmall: register('error-small', 0xebfb),\n\tterminalDecorationError: register('terminal-decoration-error', 0xebfb),\n\tarrowCircleDown: register('arrow-circle-down', 0xebfc),\n\tarrowCircleLeft: register('arrow-circle-left', 0xebfd),\n\tarrowCircleRight: register('arrow-circle-right', 0xebfe),\n\tarrowCircleUp: register('arrow-circle-up', 0xebff),\n\tlayoutSidebarRightOff: register('layout-sidebar-right-off', 0xec00),\n\tlayoutPanelOff: register('layout-panel-off', 0xec01),\n\tlayoutSidebarLeftOff: register('layout-sidebar-left-off', 0xec02),\n\tblank: register('blank', 0xec03),\n\theartFilled: register('heart-filled', 0xec04),\n\tmap: register('map', 0xec05),\n\tmapHorizontal: register('map-horizontal', 0xec05),\n\tfoldHorizontal: register('fold-horizontal', 0xec05),\n\tmapFilled: register('map-filled', 0xec06),\n\tmapHorizontalFilled: register('map-horizontal-filled', 0xec06),\n\tfoldHorizontalFilled: register('fold-horizontal-filled', 0xec06),\n\tcircleSmall: register('circle-small', 0xec07),\n\tbellSlash: register('bell-slash', 0xec08),\n\tbellSlashDot: register('bell-slash-dot', 0xec09),\n\tcommentUnresolved: register('comment-unresolved', 0xec0a),\n\tgitPullRequestGoToChanges: register('git-pull-request-go-to-changes', 0xec0b),\n\tgitPullRequestNewChanges: register('git-pull-request-new-changes', 0xec0c),\n\tsearchFuzzy: register('search-fuzzy', 0xec0d),\n\tcommentDraft: register('comment-draft', 0xec0e),\n\tsend: register('send', 0xec0f),\n\tsparkle: register('sparkle', 0xec10),\n\tinsert: register('insert', 0xec11),\n\tmic: register('mic', 0xec12),\n\tthumbsdownFilled: register('thumbsdown-filled', 0xec13),\n\tthumbsupFilled: register('thumbsup-filled', 0xec14),\n\tcoffee: register('coffee', 0xec15),\n\tsnake: register('snake', 0xec16),\n\tgame: register('game', 0xec17),\n\tvr: register('vr', 0xec18),\n\tchip: register('chip', 0xec19),\n\tpiano: register('piano', 0xec1a),\n\tmusic: register('music', 0xec1b),\n\tmicFilled: register('mic-filled', 0xec1c),\n\trepoFetch: register('repo-fetch', 0xec1d),\n\tcopilot: register('copilot', 0xec1e),\n\tlightbulbSparkle: register('lightbulb-sparkle', 0xec1f),\n\trobot: register('robot', 0xec20),\n\tsparkleFilled: register('sparkle-filled', 0xec21),\n\tdiffSingle: register('diff-single', 0xec22),\n\tdiffMultiple: register('diff-multiple', 0xec23),\n\tsurroundWith: register('surround-with', 0xec24),\n\tshare: register('share', 0xec25),\n\tgitStash: register('git-stash', 0xec26),\n\tgitStashApply: register('git-stash-apply', 0xec27),\n\tgitStashPop: register('git-stash-pop', 0xec28),\n\tvscode: register('vscode', 0xec29),\n\tvscodeInsiders: register('vscode-insiders', 0xec2a),\n\tcodeOss: register('code-oss', 0xec2b),\n\trunCoverage: register('run-coverage', 0xec2c),\n\trunAllCoverage: register('run-all-coverage', 0xec2d),\n\tcoverage: register('coverage', 0xec2e),\n\tgithubProject: register('github-project', 0xec2f),\n\tmapVertical: register('map-vertical', 0xec30),\n\tfoldVertical: register('fold-vertical', 0xec30),\n\tmapVerticalFilled: register('map-vertical-filled', 0xec31),\n\tfoldVerticalFilled: register('fold-vertical-filled', 0xec31),\n\tgoToSearch: register('go-to-search', 0xec32),\n\tpercentage: register('percentage', 0xec33),\n\tsortPercentage: register('sort-percentage', 0xec33),\n\tattach: register('attach', 0xec34),\n\tgoToEditingSession: register('go-to-editing-session', 0xec35),\n\teditSession: register('edit-session', 0xec36),\n\tcodeReview: register('code-review', 0xec37),\n\tcopilotWarning: register('copilot-warning', 0xec38),\n\tpython: register('python', 0xec39),\n\tcopilotLarge: register('copilot-large', 0xec3a),\n\tcopilotWarningLarge: register('copilot-warning-large', 0xec3b),\n\tkeyboardTab: register('keyboard-tab', 0xec3c),\n\tcopilotBlocked: register('copilot-blocked', 0xec3d),\n\tcopilotNotConnected: register('copilot-not-connected', 0xec3e),\n\tflag: register('flag', 0xec3f),\n\tlightbulbEmpty: register('lightbulb-empty', 0xec40),\n\tsymbolMethodArrow: register('symbol-method-arrow', 0xec41),\n\tcopilotUnavailable: register('copilot-unavailable', 0xec42),\n\trepoPinned: register('repo-pinned', 0xec43),\n\tkeyboardTabAbove: register('keyboard-tab-above', 0xec44),\n\tkeyboardTabBelow: register('keyboard-tab-below', 0xec45),\n\tgitPullRequestDone: register('git-pull-request-done', 0xec46),\n\tmcp: register('mcp', 0xec47),\n\textensionsLarge: register('extensions-large', 0xec48),\n\tlayoutPanelDock: register('layout-panel-dock', 0xec49),\n\tlayoutSidebarLeftDock: register('layout-sidebar-left-dock', 0xec4a),\n\tlayoutSidebarRightDock: register('layout-sidebar-right-dock', 0xec4b),\n\tcopilotInProgress: register('copilot-in-progress', 0xec4c),\n\tcopilotError: register('copilot-error', 0xec4d),\n\tcopilotSuccess: register('copilot-success', 0xec4e),\n\tchatSparkle: register('chat-sparkle', 0xec4f),\n\tsearchSparkle: register('search-sparkle', 0xec50),\n\teditSparkle: register('edit-sparkle', 0xec51),\n\tcopilotSnooze: register('copilot-snooze', 0xec52),\n\tsendToRemoteAgent: register('send-to-remote-agent', 0xec53),\n\tcommentDiscussionSparkle: register('comment-discussion-sparkle', 0xec54),\n\tchatSparkleWarning: register('chat-sparkle-warning', 0xec55),\n\tchatSparkleError: register('chat-sparkle-error', 0xec56),\n\tcollection: register('collection', 0xec57),\n\tnewCollection: register('new-collection', 0xec58),\n\tthinking: register('thinking', 0xec59),\n} as const;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThemeIcon } from './themables.js';\nimport { register } from './codiconsUtil.js';\nimport { codiconsLibrary } from './codiconsLibrary.js';\n\n\n/**\n * Only to be used by the iconRegistry.\n */\nexport function getAllCodicons(): ThemeIcon[] {\n\treturn Object.values(Codicon);\n}\n\n/**\n * Derived icons, that could become separate icons.\n * These mappings should be moved into the mapping file in the vscode-codicons repo at some point.\n */\nexport const codiconsDerived = {\n\tdialogError: register('dialog-error', 'error'),\n\tdialogWarning: register('dialog-warning', 'warning'),\n\tdialogInfo: register('dialog-info', 'info'),\n\tdialogClose: register('dialog-close', 'close'),\n\ttreeItemExpanded: register('tree-item-expanded', 'chevron-down'), // collapsed is done with rotation\n\ttreeFilterOnTypeOn: register('tree-filter-on-type-on', 'list-filter'),\n\ttreeFilterOnTypeOff: register('tree-filter-on-type-off', 'list-selection'),\n\ttreeFilterClear: register('tree-filter-clear', 'close'),\n\ttreeItemLoading: register('tree-item-loading', 'loading'),\n\tmenuSelection: register('menu-selection', 'check'),\n\tmenuSubmenu: register('menu-submenu', 'chevron-right'),\n\tmenuBarMore: register('menubar-more', 'more'),\n\tscrollbarButtonLeft: register('scrollbar-button-left', 'triangle-left'),\n\tscrollbarButtonRight: register('scrollbar-button-right', 'triangle-right'),\n\tscrollbarButtonUp: register('scrollbar-button-up', 'triangle-up'),\n\tscrollbarButtonDown: register('scrollbar-button-down', 'triangle-down'),\n\ttoolBarMore: register('toolbar-more', 'more'),\n\tquickInputBack: register('quick-input-back', 'arrow-left'),\n\tdropDownButton: register('drop-down-button', 0xeab4),\n\tsymbolCustomColor: register('symbol-customcolor', 0xeb5c),\n\texportIcon: register('export', 0xebac),\n\tworkspaceUnspecified: register('workspace-unspecified', 0xebc3),\n\tnewLine: register('newline', 0xebea),\n\tthumbsDownFilled: register('thumbsdown-filled', 0xec13),\n\tthumbsUpFilled: register('thumbsup-filled', 0xec14),\n\tgitFetch: register('git-fetch', 0xec1d),\n\tlightbulbSparkleAutofix: register('lightbulb-sparkle-autofix', 0xec1f),\n\tdebugBreakpointPending: register('debug-breakpoint-pending', 0xebd9),\n\n} as const;\n\n/**\n * The Codicon library is a set of default icons that are built-in in VS Code.\n *\n * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code\n * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.\n * In that call a Codicon can be named as default.\n */\nexport const Codicon = {\n\t...codiconsLibrary,\n\t...codiconsDerived\n\n} as const;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ThemeIcon } from './themables.js';\nimport { register } from './codiconsUtil.js';\nimport { codiconsLibrary } from './codiconsLibrary.js';\n\n\n/**\n * Only to be used by the iconRegistry.\n */\nexport function getAllCodicons(): ThemeIcon[] {\n\treturn Object.values(Codicon);\n}\n\n/**\n * Derived icons, that could become separate icons.\n * These mappings should be moved into the mapping file in the vscode-codicons repo at some point.\n */\nexport const codiconsDerived = {\n\tdialogError: register('dialog-error', 'error'),\n\tdialogWarning: register('dialog-warning', 'warning'),\n\tdialogInfo: register('dialog-info', 'info'),\n\tdialogClose: register('dialog-close', 'close'),\n\ttreeItemExpanded: register('tree-item-expanded', 'chevron-down'), // collapsed is done with rotation\n\ttreeFilterOnTypeOn: register('tree-filter-on-type-on', 'list-filter'),\n\ttreeFilterOnTypeOff: register('tree-filter-on-type-off', 'list-selection'),\n\ttreeFilterClear: register('tree-filter-clear', 'close'),\n\ttreeItemLoading: register('tree-item-loading', 'loading'),\n\tmenuSelection: register('menu-selection', 'check'),\n\tmenuSubmenu: register('menu-submenu', 'chevron-right'),\n\tmenuBarMore: register('menubar-more', 'more'),\n\tscrollbarButtonLeft: register('scrollbar-button-left', 'triangle-left'),\n\tscrollbarButtonRight: register('scrollbar-button-right', 'triangle-right'),\n\tscrollbarButtonUp: register('scrollbar-button-up', 'triangle-up'),\n\tscrollbarButtonDown: register('scrollbar-button-down', 'triangle-down'),\n\ttoolBarMore: register('toolbar-more', 'more'),\n\tquickInputBack: register('quick-input-back', 'arrow-left'),\n\tdropDownButton: register('drop-down-button', 0xeab4),\n\tsymbolCustomColor: register('symbol-customcolor', 0xeb5c),\n\texportIcon: register('export', 0xebac),\n\tworkspaceUnspecified: register('workspace-unspecified', 0xebc3),\n\tnewLine: register('newline', 0xebea),\n\tthumbsDownFilled: register('thumbsdown-filled', 0xec13),\n\tthumbsUpFilled: register('thumbsup-filled', 0xec14),\n\tgitFetch: register('git-fetch', 0xec1d),\n\tlightbulbSparkleAutofix: register('lightbulb-sparkle-autofix', 0xec1f),\n\tdebugBreakpointPending: register('debug-breakpoint-pending', 0xebd9),\n\n} as const;\n\n/**\n * The Codicon library is a set of default icons that are built-in in VS Code.\n *\n * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code\n * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.\n * In that call a Codicon can be named as default.\n */\nexport const Codicon = {\n\t...codiconsLibrary,\n\t...codiconsDerived\n\n} as const;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Color } from '../../base/common/color.js';\nimport { Emitter, Event } from '../../base/common/event.js';\nimport { Disposable, IDisposable, toDisposable } from '../../base/common/lifecycle.js';\nimport { ITokenizationRegistry, ITokenizationSupportChangedEvent, ILazyTokenizationSupport } from './languages.js';\nimport { ColorId } from './encodedTokenAttributes.js';\n\nexport class TokenizationRegistry<TSupport> implements ITokenizationRegistry<TSupport> {\n\n\tprivate readonly _tokenizationSupports = new Map<string, TSupport>();\n\tprivate readonly _factories = new Map<string, TokenizationSupportFactoryData<TSupport>>();\n\n\tprivate readonly _onDidChange = new Emitter<ITokenizationSupportChangedEvent>();\n\tpublic readonly onDidChange: Event<ITokenizationSupportChangedEvent> = this._onDidChange.event;\n\n\tprivate _colorMap: Color[] | null;\n\n\tconstructor() {\n\t\tthis._colorMap = null;\n\t}\n\n\tpublic handleChange(languageIds: string[]): void {\n\t\tthis._onDidChange.fire({\n\t\t\tchangedLanguages: languageIds,\n\t\t\tchangedColorMap: false\n\t\t});\n\t}\n\n\tpublic register(languageId: string, support: TSupport): IDisposable {\n\t\tthis._tokenizationSupports.set(languageId, support);\n\t\tthis.handleChange([languageId]);\n\t\treturn toDisposable(() => {\n\t\t\tif (this._tokenizationSupports.get(languageId) !== support) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._tokenizationSupports.delete(languageId);\n\t\t\tthis.handleChange([languageId]);\n\t\t});\n\t}\n\n\tpublic get(languageId: string): TSupport | null {\n\t\treturn this._tokenizationSupports.get(languageId) || null;\n\t}\n\n\tpublic registerFactory(languageId: string, factory: ILazyTokenizationSupport<TSupport>): IDisposable {\n\t\tthis._factories.get(languageId)?.dispose();\n\t\tconst myData = new TokenizationSupportFactoryData(this, languageId, factory);\n\t\tthis._factories.set(languageId, myData);\n\t\treturn toDisposable(() => {\n\t\t\tconst v = this._factories.get(languageId);\n\t\t\tif (!v || v !== myData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._factories.delete(languageId);\n\t\t\tv.dispose();\n\t\t});\n\t}\n\n\tpublic async getOrCreate(languageId: string): Promise<TSupport | null> {\n\t\t// check first if the support is already set\n\t\tconst tokenizationSupport = this.get(languageId);\n\t\tif (tokenizationSupport) {\n\t\t\treturn tokenizationSupport;\n\t\t}\n\n\t\tconst factory = this._factories.get(languageId);\n\t\tif (!factory || factory.isResolved) {\n\t\t\t// no factory or factory.resolve already finished\n\t\t\treturn null;\n\t\t}\n\n\t\tawait factory.resolve();\n\n\t\treturn this.get(languageId);\n\t}\n\n\tpublic isResolved(languageId: string): boolean {\n\t\tconst tokenizationSupport = this.get(languageId);\n\t\tif (tokenizationSupport) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst factory = this._factories.get(languageId);\n\t\tif (!factory || factory.isResolved) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic setColorMap(colorMap: Color[]): void {\n\t\tthis._colorMap = colorMap;\n\t\tthis._onDidChange.fire({\n\t\t\tchangedLanguages: Array.from(this._tokenizationSupports.keys()),\n\t\t\tchangedColorMap: true\n\t\t});\n\t}\n\n\tpublic getColorMap(): Color[] | null {\n\t\treturn this._colorMap;\n\t}\n\n\tpublic getDefaultBackground(): Color | null {\n\t\tif (this._colorMap && this._colorMap.length > ColorId.DefaultBackground) {\n\t\t\treturn this._colorMap[ColorId.DefaultBackground];\n\t\t}\n\t\treturn null;\n\t}\n}\n\nclass TokenizationSupportFactoryData<TSupport> extends Disposable {\n\n\tprivate _isDisposed: boolean = false;\n\tprivate _resolvePromise: Promise<void> | null = null;\n\tprivate _isResolved: boolean = false;\n\n\tpublic get isResolved(): boolean {\n\t\treturn this._isResolved;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _registry: TokenizationRegistry<TSupport>,\n\t\tprivate readonly _languageId: string,\n\t\tprivate readonly _factory: ILazyTokenizationSupport<TSupport>,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic async resolve(): Promise<void> {\n\t\tif (!this._resolvePromise) {\n\t\t\tthis._resolvePromise = this._create();\n\t\t}\n\t\treturn this._resolvePromise;\n\t}\n\n\tprivate async _create(): Promise<void> {\n\t\tconst value = await this._factory.tokenizationSupport;\n\t\tthis._isResolved = true;\n\t\tif (value && !this._isDisposed) {\n\t\t\tthis._register(this._registry.register(this._languageId, value));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Color } from '../../base/common/color.js';\nimport { Emitter, Event } from '../../base/common/event.js';\nimport { Disposable, IDisposable, toDisposable } from '../../base/common/lifecycle.js';\nimport { ITokenizationRegistry, ITokenizationSupportChangedEvent, ILazyTokenizationSupport } from './languages.js';\nimport { ColorId } from './encodedTokenAttributes.js';\n\nexport class TokenizationRegistry<TSupport> implements ITokenizationRegistry<TSupport> {\n\n\tprivate readonly _tokenizationSupports = new Map<string, TSupport>();\n\tprivate readonly _factories = new Map<string, TokenizationSupportFactoryData<TSupport>>();\n\n\tprivate readonly _onDidChange = new Emitter<ITokenizationSupportChangedEvent>();\n\tpublic readonly onDidChange: Event<ITokenizationSupportChangedEvent> = this._onDidChange.event;\n\n\tprivate _colorMap: Color[] | null;\n\n\tconstructor() {\n\t\tthis._colorMap = null;\n\t}\n\n\tpublic handleChange(languageIds: string[]): void {\n\t\tthis._onDidChange.fire({\n\t\t\tchangedLanguages: languageIds,\n\t\t\tchangedColorMap: false\n\t\t});\n\t}\n\n\tpublic register(languageId: string, support: TSupport): IDisposable {\n\t\tthis._tokenizationSupports.set(languageId, support);\n\t\tthis.handleChange([languageId]);\n\t\treturn toDisposable(() => {\n\t\t\tif (this._tokenizationSupports.get(languageId) !== support) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._tokenizationSupports.delete(languageId);\n\t\t\tthis.handleChange([languageId]);\n\t\t});\n\t}\n\n\tpublic get(languageId: string): TSupport | null {\n\t\treturn this._tokenizationSupports.get(languageId) || null;\n\t}\n\n\tpublic registerFactory(languageId: string, factory: ILazyTokenizationSupport<TSupport>): IDisposable {\n\t\tthis._factories.get(languageId)?.dispose();\n\t\tconst myData = new TokenizationSupportFactoryData(this, languageId, factory);\n\t\tthis._factories.set(languageId, myData);\n\t\treturn toDisposable(() => {\n\t\t\tconst v = this._factories.get(languageId);\n\t\t\tif (!v || v !== myData) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._factories.delete(languageId);\n\t\t\tv.dispose();\n\t\t});\n\t}\n\n\tpublic async getOrCreate(languageId: string): Promise<TSupport | null> {\n\t\t// check first if the support is already set\n\t\tconst tokenizationSupport = this.get(languageId);\n\t\tif (tokenizationSupport) {\n\t\t\treturn tokenizationSupport;\n\t\t}\n\n\t\tconst factory = this._factories.get(languageId);\n\t\tif (!factory || factory.isResolved) {\n\t\t\t// no factory or factory.resolve already finished\n\t\t\treturn null;\n\t\t}\n\n\t\tawait factory.resolve();\n\n\t\treturn this.get(languageId);\n\t}\n\n\tpublic isResolved(languageId: string): boolean {\n\t\tconst tokenizationSupport = this.get(languageId);\n\t\tif (tokenizationSupport) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst factory = this._factories.get(languageId);\n\t\tif (!factory || factory.isResolved) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic setColorMap(colorMap: Color[]): void {\n\t\tthis._colorMap = colorMap;\n\t\tthis._onDidChange.fire({\n\t\t\tchangedLanguages: Array.from(this._tokenizationSupports.keys()),\n\t\t\tchangedColorMap: true\n\t\t});\n\t}\n\n\tpublic getColorMap(): Color[] | null {\n\t\treturn this._colorMap;\n\t}\n\n\tpublic getDefaultBackground(): Color | null {\n\t\tif (this._colorMap && this._colorMap.length > ColorId.DefaultBackground) {\n\t\t\treturn this._colorMap[ColorId.DefaultBackground];\n\t\t}\n\t\treturn null;\n\t}\n}\n\nclass TokenizationSupportFactoryData<TSupport> extends Disposable {\n\n\tprivate _isDisposed: boolean = false;\n\tprivate _resolvePromise: Promise<void> | null = null;\n\tprivate _isResolved: boolean = false;\n\n\tpublic get isResolved(): boolean {\n\t\treturn this._isResolved;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _registry: TokenizationRegistry<TSupport>,\n\t\tprivate readonly _languageId: string,\n\t\tprivate readonly _factory: ILazyTokenizationSupport<TSupport>,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic async resolve(): Promise<void> {\n\t\tif (!this._resolvePromise) {\n\t\t\tthis._resolvePromise = this._create();\n\t\t}\n\t\treturn this._resolvePromise;\n\t}\n\n\tprivate async _create(): Promise<void> {\n\t\tconst value = await this._factory.tokenizationSupport;\n\t\tthis._isResolved = true;\n\t\tif (value && !this._isDisposed) {\n\t\t\tthis._register(this._registry.register(this._languageId, value));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from '../../base/common/buffer.js';\nimport { CancellationToken } from '../../base/common/cancellation.js';\nimport { Codicon } from '../../base/common/codicons.js';\nimport { Color } from '../../base/common/color.js';\nimport { IReadonlyVSDataTransfer } from '../../base/common/dataTransfer.js';\nimport { Event } from '../../base/common/event.js';\nimport { HierarchicalKind } from '../../base/common/hierarchicalKind.js';\nimport { IMarkdownString } from '../../base/common/htmlContent.js';\nimport { IDisposable } from '../../base/common/lifecycle.js';\nimport { ThemeIcon } from '../../base/common/themables.js';\nimport { URI, UriComponents } from '../../base/common/uri.js';\nimport { EditOperation, ISingleEditOperation } from './core/editOperation.js';\nimport { IPosition, Position } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { LanguageId } from './encodedTokenAttributes.js';\nimport { LanguageSelector } from './languageSelector.js';\nimport * as model from './model.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nimport { ContiguousMultilineTokens } from './tokens/contiguousMultilineTokens.js';\nimport { localize } from '../../nls.js';\nimport { ExtensionIdentifier } from '../../platform/extensions/common/extensions.js';\nimport { IMarkerData } from '../../platform/markers/common/markers.js';\nimport { EditDeltaInfo } from './textModelEditSource.js';\n\n/**\n * @internal\n */\nexport interface ILanguageIdCodec {\n\tencodeLanguageId(languageId: string): LanguageId;\n\tdecodeLanguageId(languageId: LanguageId): string;\n}\n\nexport class Token {\n\t_tokenBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly offset: number,\n\t\tpublic readonly type: string,\n\t\tpublic readonly language: string,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn '(' + this.offset + ', ' + this.type + ')';\n\t}\n}\n\n/**\n * @internal\n */\nexport class TokenizationResult {\n\t_tokenizationResultBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly tokens: Token[],\n\t\tpublic readonly endState: IState,\n\t) {\n\t}\n}\n\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n\t_encodedTokenizationResultBrand: void = undefined;\n\n\tconstructor(\n\t\t/**\n\t\t * The tokens in binary format. Each token occupies two array indices. For token i:\n\t\t *  - at offset 2*i => startIndex\n\t\t *  - at offset 2*i + 1 => metadata\n\t\t *\n\t\t */\n\t\tpublic readonly tokens: Uint32Array,\n\t\tpublic readonly endState: IState,\n\t) {\n\t}\n}\n\nexport interface SyntaxNode {\n\tstartIndex: number;\n\tendIndex: number;\n\tstartPosition: IPosition;\n\tendPosition: IPosition;\n}\n\nexport interface QueryCapture {\n\tname: string;\n\ttext?: string;\n\tnode: SyntaxNode;\n\tencodedLanguageId: number;\n}\n\n/**\n * @internal\n */\nexport interface ITokenizationSupport {\n\t/**\n\t * If true, the background tokenizer will only be used to verify tokens against the default background tokenizer.\n\t * Used for debugging.\n\t */\n\treadonly backgroundTokenizerShouldOnlyVerifyTokens?: boolean;\n\n\tgetInitialState(): IState;\n\n\ttokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult;\n\n\ttokenizeEncoded(line: string, hasEOL: boolean, state: IState): EncodedTokenizationResult;\n\n\t/**\n\t * Can be/return undefined if default background tokenization should be used.\n\t */\n\tcreateBackgroundTokenizer?(textModel: model.ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined;\n}\n\n/**\n * @internal\n */\nexport interface IBackgroundTokenizer extends IDisposable {\n\t/**\n\t * Instructs the background tokenizer to set the tokens for the given range again.\n\t *\n\t * This might be necessary if the renderer overwrote those tokens with heuristically computed ones for some viewport,\n\t * when the change does not even propagate to that viewport.\n\t */\n\trequestTokens(startLineNumber: number, endLineNumberExclusive: number): void;\n\n\treportMismatchingTokens?(lineNumber: number): void;\n}\n\n/**\n * @internal\n */\nexport interface IBackgroundTokenizationStore {\n\tsetTokens(tokens: ContiguousMultilineTokens[]): void;\n\n\tsetEndState(lineNumber: number, state: IState): void;\n\n\t/**\n\t * Should be called to indicate that the background tokenization has finished for now.\n\t * (This triggers bracket pair colorization to re-parse the bracket pairs with token information)\n\t */\n\tbackgroundTokenizationFinished(): void;\n}\n\n/**\n * The state of the tokenizer between two lines.\n * It is useful to store flags such as in multiline comment, etc.\n * The model will clone the previous line's state and pass it in to tokenize the next line.\n */\nexport interface IState {\n\tclone(): IState;\n\tequals(other: IState): boolean;\n}\n\n/**\n * A provider result represents the values a provider, like the {@link HoverProvider},\n * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves\n * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a\n * thenable.\n */\nexport type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;\n\n/**\n * A hover represents additional information for a symbol or word. Hovers are\n * rendered in a tooltip-like widget.\n */\nexport interface Hover {\n\t/**\n\t * The contents of this hover.\n\t */\n\tcontents: IMarkdownString[];\n\n\t/**\n\t * The range to which this hover applies. When missing, the\n\t * editor will use the range at the current position or the\n\t * current position itself.\n\t */\n\trange?: IRange;\n\n\t/**\n\t * Can increase the verbosity of the hover\n\t */\n\tcanIncreaseVerbosity?: boolean;\n\n\t/**\n\t * Can decrease the verbosity of the hover\n\t */\n\tcanDecreaseVerbosity?: boolean;\n}\n\n/**\n * The hover provider interface defines the contract between extensions and\n * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.\n */\nexport interface HoverProvider<THover = Hover> {\n\t/**\n\t * Provide a hover for the given position, context and document. Multiple hovers at the same\n\t * position will be merged by the editor. A hover can have a range which defaults\n\t * to the word range at the position when omitted.\n\t */\n\tprovideHover(model: model.ITextModel, position: Position, token: CancellationToken, context?: HoverContext<THover>): ProviderResult<THover>;\n}\n\nexport interface HoverContext<THover = Hover> {\n\t/**\n\t * Hover verbosity request\n\t */\n\tverbosityRequest?: HoverVerbosityRequest<THover>;\n}\n\nexport interface HoverVerbosityRequest<THover = Hover> {\n\t/**\n\t * The delta by which to increase/decrease the hover verbosity level\n\t */\n\tverbosityDelta: number;\n\t/**\n\t * The previous hover for the same position\n\t */\n\tpreviousHover: THover;\n}\n\nexport enum HoverVerbosityAction {\n\t/**\n\t * Increase the verbosity of the hover\n\t */\n\tIncrease,\n\t/**\n\t * Decrease the verbosity of the hover\n\t */\n\tDecrease\n}\n\n/**\n * An evaluatable expression represents additional information for an expression in a document. Evaluatable expressions are\n * evaluated by a debugger or runtime and their result is rendered in a tooltip-like widget.\n * @internal\n */\nexport interface EvaluatableExpression {\n\t/**\n\t * The range to which this expression applies.\n\t */\n\trange: IRange;\n\t/**\n\t * This expression overrides the expression extracted from the range.\n\t */\n\texpression?: string;\n}\n\n\n/**\n * The evaluatable expression provider interface defines the contract between extensions and\n * the debug hover.\n * @internal\n */\nexport interface EvaluatableExpressionProvider {\n\t/**\n\t * Provide a hover for the given position and document. Multiple hovers at the same\n\t * position will be merged by the editor. A hover can have a range which defaults\n\t * to the word range at the position when omitted.\n\t */\n\tprovideEvaluatableExpression(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<EvaluatableExpression>;\n}\n\n/**\n * A value-object that contains contextual information when requesting inline values from a InlineValuesProvider.\n * @internal\n */\nexport interface InlineValueContext {\n\tframeId: number;\n\tstoppedLocation: Range;\n}\n\n/**\n * Provide inline value as text.\n * @internal\n */\nexport interface InlineValueText {\n\ttype: 'text';\n\trange: IRange;\n\ttext: string;\n}\n\n/**\n * Provide inline value through a variable lookup.\n * @internal\n */\nexport interface InlineValueVariableLookup {\n\ttype: 'variable';\n\trange: IRange;\n\tvariableName?: string;\n\tcaseSensitiveLookup: boolean;\n}\n\n/**\n * Provide inline value through an expression evaluation.\n * @internal\n */\nexport interface InlineValueExpression {\n\ttype: 'expression';\n\trange: IRange;\n\texpression?: string;\n}\n\n/**\n * Inline value information can be provided by different means:\n * - directly as a text value (class InlineValueText).\n * - as a name to use for a variable lookup (class InlineValueVariableLookup)\n * - as an evaluatable expression (class InlineValueEvaluatableExpression)\n * The InlineValue types combines all inline value types into one type.\n * @internal\n */\nexport type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueExpression;\n\n/**\n * The inline values provider interface defines the contract between extensions and\n * the debugger's inline values feature.\n * @internal\n */\nexport interface InlineValuesProvider {\n\t/**\n\t */\n\tonDidChangeInlineValues?: Event<void> | undefined;\n\t/**\n\t * Provide the \"inline values\" for the given range and document. Multiple hovers at the same\n\t * position will be merged by the editor. A hover can have a range which defaults\n\t * to the word range at the position when omitted.\n\t */\n\tprovideInlineValues(model: model.ITextModel, viewPort: Range, context: InlineValueContext, token: CancellationToken): ProviderResult<InlineValue[]>;\n}\n\nexport const enum CompletionItemKind {\n\tMethod,\n\tFunction,\n\tConstructor,\n\tField,\n\tVariable,\n\tClass,\n\tStruct,\n\tInterface,\n\tModule,\n\tProperty,\n\tEvent,\n\tOperator,\n\tUnit,\n\tValue,\n\tConstant,\n\tEnum,\n\tEnumMember,\n\tKeyword,\n\tText,\n\tColor,\n\tFile,\n\tReference,\n\tCustomcolor,\n\tFolder,\n\tTypeParameter,\n\tUser,\n\tIssue,\n\tTool,\n\tSnippet, // <- highest value (used for compare!)\n}\n\n/**\n * @internal\n */\nexport namespace CompletionItemKinds {\n\n\tconst byKind = new Map<CompletionItemKind, ThemeIcon>();\n\tbyKind.set(CompletionItemKind.Method, Codicon.symbolMethod);\n\tbyKind.set(CompletionItemKind.Function, Codicon.symbolFunction);\n\tbyKind.set(CompletionItemKind.Constructor, Codicon.symbolConstructor);\n\tbyKind.set(CompletionItemKind.Field, Codicon.symbolField);\n\tbyKind.set(CompletionItemKind.Variable, Codicon.symbolVariable);\n\tbyKind.set(CompletionItemKind.Class, Codicon.symbolClass);\n\tbyKind.set(CompletionItemKind.Struct, Codicon.symbolStruct);\n\tbyKind.set(CompletionItemKind.Interface, Codicon.symbolInterface);\n\tbyKind.set(CompletionItemKind.Module, Codicon.symbolModule);\n\tbyKind.set(CompletionItemKind.Property, Codicon.symbolProperty);\n\tbyKind.set(CompletionItemKind.Event, Codicon.symbolEvent);\n\tbyKind.set(CompletionItemKind.Operator, Codicon.symbolOperator);\n\tbyKind.set(CompletionItemKind.Unit, Codicon.symbolUnit);\n\tbyKind.set(CompletionItemKind.Value, Codicon.symbolValue);\n\tbyKind.set(CompletionItemKind.Enum, Codicon.symbolEnum);\n\tbyKind.set(CompletionItemKind.Constant, Codicon.symbolConstant);\n\tbyKind.set(CompletionItemKind.Enum, Codicon.symbolEnum);\n\tbyKind.set(CompletionItemKind.EnumMember, Codicon.symbolEnumMember);\n\tbyKind.set(CompletionItemKind.Keyword, Codicon.symbolKeyword);\n\tbyKind.set(CompletionItemKind.Snippet, Codicon.symbolSnippet);\n\tbyKind.set(CompletionItemKind.Text, Codicon.symbolText);\n\tbyKind.set(CompletionItemKind.Color, Codicon.symbolColor);\n\tbyKind.set(CompletionItemKind.File, Codicon.symbolFile);\n\tbyKind.set(CompletionItemKind.Reference, Codicon.symbolReference);\n\tbyKind.set(CompletionItemKind.Customcolor, Codicon.symbolCustomColor);\n\tbyKind.set(CompletionItemKind.Folder, Codicon.symbolFolder);\n\tbyKind.set(CompletionItemKind.TypeParameter, Codicon.symbolTypeParameter);\n\tbyKind.set(CompletionItemKind.User, Codicon.account);\n\tbyKind.set(CompletionItemKind.Issue, Codicon.issues);\n\tbyKind.set(CompletionItemKind.Tool, Codicon.tools);\n\n\t/**\n\t * @internal\n\t */\n\texport function toIcon(kind: CompletionItemKind): ThemeIcon {\n\t\tlet codicon = byKind.get(kind);\n\t\tif (!codicon) {\n\t\t\tconsole.info('No codicon found for CompletionItemKind ' + kind);\n\t\t\tcodicon = Codicon.symbolProperty;\n\t\t}\n\t\treturn codicon;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\texport function toLabel(kind: CompletionItemKind): string {\n\t\tswitch (kind) {\n\t\t\tcase CompletionItemKind.Method: return localize('suggestWidget.kind.method', 'Method');\n\t\t\tcase CompletionItemKind.Function: return localize('suggestWidget.kind.function', 'Function');\n\t\t\tcase CompletionItemKind.Constructor: return localize('suggestWidget.kind.constructor', 'Constructor');\n\t\t\tcase CompletionItemKind.Field: return localize('suggestWidget.kind.field', 'Field');\n\t\t\tcase CompletionItemKind.Variable: return localize('suggestWidget.kind.variable', 'Variable');\n\t\t\tcase CompletionItemKind.Class: return localize('suggestWidget.kind.class', 'Class');\n\t\t\tcase CompletionItemKind.Struct: return localize('suggestWidget.kind.struct', 'Struct');\n\t\t\tcase CompletionItemKind.Interface: return localize('suggestWidget.kind.interface', 'Interface');\n\t\t\tcase CompletionItemKind.Module: return localize('suggestWidget.kind.module', 'Module');\n\t\t\tcase CompletionItemKind.Property: return localize('suggestWidget.kind.property', 'Property');\n\t\t\tcase CompletionItemKind.Event: return localize('suggestWidget.kind.event', 'Event');\n\t\t\tcase CompletionItemKind.Operator: return localize('suggestWidget.kind.operator', 'Operator');\n\t\t\tcase CompletionItemKind.Unit: return localize('suggestWidget.kind.unit', 'Unit');\n\t\t\tcase CompletionItemKind.Value: return localize('suggestWidget.kind.value', 'Value');\n\t\t\tcase CompletionItemKind.Constant: return localize('suggestWidget.kind.constant', 'Constant');\n\t\t\tcase CompletionItemKind.Enum: return localize('suggestWidget.kind.enum', 'Enum');\n\t\t\tcase CompletionItemKind.EnumMember: return localize('suggestWidget.kind.enumMember', 'Enum Member');\n\t\t\tcase CompletionItemKind.Keyword: return localize('suggestWidget.kind.keyword', 'Keyword');\n\t\t\tcase CompletionItemKind.Text: return localize('suggestWidget.kind.text', 'Text');\n\t\t\tcase CompletionItemKind.Color: return localize('suggestWidget.kind.color', 'Color');\n\t\t\tcase CompletionItemKind.File: return localize('suggestWidget.kind.file', 'File');\n\t\t\tcase CompletionItemKind.Reference: return localize('suggestWidget.kind.reference', 'Reference');\n\t\t\tcase CompletionItemKind.Customcolor: return localize('suggestWidget.kind.customcolor', 'Custom Color');\n\t\t\tcase CompletionItemKind.Folder: return localize('suggestWidget.kind.folder', 'Folder');\n\t\t\tcase CompletionItemKind.TypeParameter: return localize('suggestWidget.kind.typeParameter', 'Type Parameter');\n\t\t\tcase CompletionItemKind.User: return localize('suggestWidget.kind.user', 'User');\n\t\t\tcase CompletionItemKind.Issue: return localize('suggestWidget.kind.issue', 'Issue');\n\t\t\tcase CompletionItemKind.Tool: return localize('suggestWidget.kind.tool', 'Tool');\n\t\t\tcase CompletionItemKind.Snippet: return localize('suggestWidget.kind.snippet', 'Snippet');\n\t\t\tdefault: return '';\n\t\t}\n\t}\n\n\tconst data = new Map<string, CompletionItemKind>();\n\tdata.set('method', CompletionItemKind.Method);\n\tdata.set('function', CompletionItemKind.Function);\n\tdata.set('constructor', <any>CompletionItemKind.Constructor);\n\tdata.set('field', CompletionItemKind.Field);\n\tdata.set('variable', CompletionItemKind.Variable);\n\tdata.set('class', CompletionItemKind.Class);\n\tdata.set('struct', CompletionItemKind.Struct);\n\tdata.set('interface', CompletionItemKind.Interface);\n\tdata.set('module', CompletionItemKind.Module);\n\tdata.set('property', CompletionItemKind.Property);\n\tdata.set('event', CompletionItemKind.Event);\n\tdata.set('operator', CompletionItemKind.Operator);\n\tdata.set('unit', CompletionItemKind.Unit);\n\tdata.set('value', CompletionItemKind.Value);\n\tdata.set('constant', CompletionItemKind.Constant);\n\tdata.set('enum', CompletionItemKind.Enum);\n\tdata.set('enum-member', CompletionItemKind.EnumMember);\n\tdata.set('enumMember', CompletionItemKind.EnumMember);\n\tdata.set('keyword', CompletionItemKind.Keyword);\n\tdata.set('snippet', CompletionItemKind.Snippet);\n\tdata.set('text', CompletionItemKind.Text);\n\tdata.set('color', CompletionItemKind.Color);\n\tdata.set('file', CompletionItemKind.File);\n\tdata.set('reference', CompletionItemKind.Reference);\n\tdata.set('customcolor', CompletionItemKind.Customcolor);\n\tdata.set('folder', CompletionItemKind.Folder);\n\tdata.set('type-parameter', CompletionItemKind.TypeParameter);\n\tdata.set('typeParameter', CompletionItemKind.TypeParameter);\n\tdata.set('account', CompletionItemKind.User);\n\tdata.set('issue', CompletionItemKind.Issue);\n\tdata.set('tool', CompletionItemKind.Tool);\n\n\t/**\n\t * @internal\n\t */\n\texport function fromString(value: string): CompletionItemKind;\n\t/**\n\t * @internal\n\t */\n\texport function fromString(value: string, strict: true): CompletionItemKind | undefined;\n\t/**\n\t * @internal\n\t */\n\texport function fromString(value: string, strict?: boolean): CompletionItemKind | undefined {\n\t\tlet res = data.get(value);\n\t\tif (typeof res === 'undefined' && !strict) {\n\t\t\tres = CompletionItemKind.Property;\n\t\t}\n\t\treturn res;\n\t}\n}\n\nexport interface CompletionItemLabel {\n\tlabel: string;\n\tdetail?: string;\n\tdescription?: string;\n}\n\nexport const enum CompletionItemTag {\n\tDeprecated = 1\n}\n\nexport const enum CompletionItemInsertTextRule {\n\tNone = 0,\n\n\t/**\n\t * Adjust whitespace/indentation of multiline insert texts to\n\t * match the current line indentation.\n\t */\n\tKeepWhitespace = 0b001,\n\n\t/**\n\t * `insertText` is a snippet.\n\t */\n\tInsertAsSnippet = 0b100,\n}\n\nexport interface CompletionItemRanges {\n\tinsert: IRange;\n\treplace: IRange;\n}\n\n/**\n * A completion item represents a text snippet that is\n * proposed to complete text that is being typed.\n */\nexport interface CompletionItem {\n\t/**\n\t * The label of this completion item. By default\n\t * this is also the text that is inserted when selecting\n\t * this completion.\n\t */\n\tlabel: string | CompletionItemLabel;\n\t/**\n\t * The kind of this completion item. Based on the kind\n\t * an icon is chosen by the editor.\n\t */\n\tkind: CompletionItemKind;\n\t/**\n\t * A modifier to the `kind` which affect how the item\n\t * is rendered, e.g. Deprecated is rendered with a strikeout\n\t */\n\ttags?: ReadonlyArray<CompletionItemTag>;\n\t/**\n\t * A human-readable string with additional information\n\t * about this item, like type or symbol information.\n\t */\n\tdetail?: string;\n\t/**\n\t * A human-readable string that represents a doc-comment.\n\t */\n\tdocumentation?: string | IMarkdownString;\n\t/**\n\t * A string that should be used when comparing this item\n\t * with other items. When `falsy` the {@link CompletionItem.label label}\n\t * is used.\n\t */\n\tsortText?: string;\n\t/**\n\t * A string that should be used when filtering a set of\n\t * completion items. When `falsy` the {@link CompletionItem.label label}\n\t * is used.\n\t */\n\tfilterText?: string;\n\t/**\n\t * Select this item when showing. *Note* that only one completion item can be selected and\n\t * that the editor decides which item that is. The rule is that the *first* item of those\n\t * that match best is selected.\n\t */\n\tpreselect?: boolean;\n\t/**\n\t * A string or snippet that should be inserted in a document when selecting\n\t * this completion.\n\t */\n\tinsertText: string;\n\t/**\n\t * Additional rules (as bitmask) that should be applied when inserting\n\t * this completion.\n\t */\n\tinsertTextRules?: CompletionItemInsertTextRule;\n\t/**\n\t * A range of text that should be replaced by this completion item.\n\t *\n\t * *Note:* The range must be a {@link Range.isSingleLine single line} and it must\n\t * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.\n\t */\n\trange: IRange | CompletionItemRanges;\n\t/**\n\t * An optional set of characters that when pressed while this completion is active will accept it first and\n\t * then type that character. *Note* that all commit characters should have `length=1` and that superfluous\n\t * characters will be ignored.\n\t */\n\tcommitCharacters?: string[];\n\t/**\n\t * An optional array of additional text edits that are applied when\n\t * selecting this completion. Edits must not overlap with the main edit\n\t * nor with themselves.\n\t */\n\tadditionalTextEdits?: ISingleEditOperation[];\n\t/**\n\t * A command that should be run upon acceptance of this item.\n\t */\n\tcommand?: Command;\n\t/**\n\t * A command that should be run upon acceptance of this item.\n\t */\n\taction?: Command;\n\t/**\n\t * @internal\n\t */\n\textensionId?: ExtensionIdentifier;\n\n\t/**\n\t * @internal\n\t */\n\t_id?: [number, number];\n}\n\nexport interface CompletionList {\n\tsuggestions: CompletionItem[];\n\tincomplete?: boolean;\n\tdispose?(): void;\n\n\t/**\n\t * @internal\n\t */\n\tduration?: number;\n}\n\n/**\n * Info provided on partial acceptance.\n */\nexport interface PartialAcceptInfo {\n\tkind: PartialAcceptTriggerKind;\n\tacceptedLength: number;\n}\n\n/**\n * How a partial acceptance was triggered.\n */\nexport const enum PartialAcceptTriggerKind {\n\tWord = 0,\n\tLine = 1,\n\tSuggest = 2,\n}\n\n/**\n * How a suggest provider was triggered.\n */\nexport const enum CompletionTriggerKind {\n\tInvoke = 0,\n\tTriggerCharacter = 1,\n\tTriggerForIncompleteCompletions = 2\n}\n/**\n * Contains additional information about the context in which\n * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.\n */\nexport interface CompletionContext {\n\t/**\n\t * How the completion was triggered.\n\t */\n\ttriggerKind: CompletionTriggerKind;\n\t/**\n\t * Character that triggered the completion item provider.\n\t *\n\t * `undefined` if provider was not triggered by a character.\n\t */\n\ttriggerCharacter?: string;\n}\n/**\n * The completion item provider interface defines the contract between extensions and\n * the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).\n *\n * When computing *complete* completion items is expensive, providers can optionally implement\n * the `resolveCompletionItem`-function. In that case it is enough to return completion\n * items with a {@link CompletionItem.label label} from the\n * {@link CompletionItemProvider.provideCompletionItems provideCompletionItems}-function. Subsequently,\n * when a completion item is shown in the UI and gains focus this provider is asked to resolve\n * the item, like adding {@link CompletionItem.documentation doc-comment} or {@link CompletionItem.detail details}.\n */\nexport interface CompletionItemProvider {\n\n\t/**\n\t * Used to identify completions in the (debug) UI and telemetry. This isn't the extension identifier because extensions\n\t * often contribute multiple completion item providers.\n\t *\n\t * @internal\n\t */\n\t_debugDisplayName: string;\n\n\ttriggerCharacters?: string[];\n\t/**\n\t * Provide completion items for the given position and document.\n\t */\n\tprovideCompletionItems(model: model.ITextModel, position: Position, context: CompletionContext, token: CancellationToken): ProviderResult<CompletionList>;\n\n\t/**\n\t * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}\n\t * or {@link CompletionItem.detail details}.\n\t *\n\t * The editor will only resolve a completion item once.\n\t */\n\tresolveCompletionItem?(item: CompletionItem, token: CancellationToken): ProviderResult<CompletionItem>;\n}\n\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport enum InlineCompletionTriggerKind {\n\t/**\n\t * Completion was triggered automatically while editing.\n\t * It is sufficient to return a single completion item in this case.\n\t */\n\tAutomatic = 0,\n\n\t/**\n\t * Completion was triggered explicitly by a user gesture.\n\t * Return multiple completion items to enable cycling through them.\n\t */\n\tExplicit = 1,\n}\n\nexport interface InlineCompletionContext {\n\n\t/**\n\t * How the completion was triggered.\n\t */\n\treadonly triggerKind: InlineCompletionTriggerKind;\n\treadonly selectedSuggestionInfo: SelectedSuggestionInfo | undefined;\n\t/**\n\t * @experimental\n\t * @internal\n\t*/\n\treadonly userPrompt?: string | undefined;\n\t/**\n\t * @experimental\n\t * @internal\n\t*/\n\treadonly requestUuid: string;\n\n\treadonly includeInlineEdits: boolean;\n\treadonly includeInlineCompletions: boolean;\n\treadonly requestIssuedDateTime: number;\n\treadonly earliestShownDateTime: number;\n}\n\nexport class SelectedSuggestionInfo {\n\tconstructor(\n\t\tpublic readonly range: IRange,\n\t\tpublic readonly text: string,\n\t\tpublic readonly completionKind: CompletionItemKind,\n\t\tpublic readonly isSnippetText: boolean,\n\t) {\n\t}\n\n\tpublic equals(other: SelectedSuggestionInfo) {\n\t\treturn Range.lift(this.range).equalsRange(other.range)\n\t\t\t&& this.text === other.text\n\t\t\t&& this.completionKind === other.completionKind\n\t\t\t&& this.isSnippetText === other.isSnippetText;\n\t}\n}\n\nexport interface InlineCompletion {\n\t/**\n\t * The text to insert.\n\t * If the text contains a line break, the range must end at the end of a line.\n\t * If existing text should be replaced, the existing text must be a prefix of the text to insert.\n\t *\n\t * The text can also be a snippet. In that case, a preview with default parameters is shown.\n\t * When accepting the suggestion, the full snippet is inserted.\n\t*/\n\treadonly insertText: string | { snippet: string };\n\n\t/**\n\t * A text that is used to decide if this inline completion should be shown.\n\t * An inline completion is shown if the text to replace is a subword of the filter text.\n\t */\n\treadonly filterText?: string;\n\n\t/**\n\t * An optional array of additional text edits that are applied when\n\t * selecting this completion. Edits must not overlap with the main edit\n\t * nor with themselves.\n\t */\n\treadonly additionalTextEdits?: ISingleEditOperation[];\n\n\t/**\n\t * The range to replace.\n\t * Must begin and end on the same line.\n\t*/\n\treadonly range?: IRange;\n\n\treadonly command?: Command;\n\n\treadonly action?: Command;\n\n\t/**\n\t * Is called the first time an inline completion is shown.\n\t * @deprecated. Use `onDidShow` of the provider instead.\n\t*/\n\treadonly shownCommand?: Command;\n\n\t/**\n\t * If set to `true`, unopened closing brackets are removed and unclosed opening brackets are closed.\n\t * Defaults to `false`.\n\t*/\n\treadonly completeBracketPairs?: boolean;\n\n\treadonly isInlineEdit?: boolean;\n\treadonly showInlineEditMenu?: boolean;\n\n\treadonly showRange?: IRange;\n\n\treadonly warning?: InlineCompletionWarning;\n\n\treadonly displayLocation?: InlineCompletionDisplayLocation;\n\n\t/**\n\t * Used for telemetry.\n\t */\n\treadonly correlationId?: string | undefined;\n}\n\nexport interface InlineCompletionWarning {\n\tmessage: IMarkdownString | string;\n\ticon?: IconPath;\n}\n\nexport enum InlineCompletionDisplayLocationKind {\n\tCode = 1,\n\tLabel = 2\n}\n\nexport interface InlineCompletionDisplayLocation {\n\trange: IRange;\n\tkind: InlineCompletionDisplayLocationKind;\n\tlabel: string;\n}\n\n/**\n * TODO: add `| URI | { light: URI; dark: URI }`.\n*/\nexport type IconPath = ThemeIcon;\n\nexport interface InlineCompletions<TItem extends InlineCompletion = InlineCompletion> {\n\treadonly items: readonly TItem[];\n\t/**\n\t * A list of commands associated with the inline completions of this list.\n\t */\n\treadonly commands?: InlineCompletionCommand[];\n\n\treadonly suppressSuggestions?: boolean | undefined;\n\n\t/**\n\t * When set and the user types a suggestion without derivating from it, the inline suggestion is not updated.\n\t */\n\treadonly enableForwardStability?: boolean | undefined;\n}\n\nexport type InlineCompletionCommand = { command: Command; icon?: ThemeIcon };\n\nexport type InlineCompletionProviderGroupId = string;\n\nexport interface InlineCompletionsProvider<T extends InlineCompletions = InlineCompletions> {\n\tprovideInlineCompletions(model: model.ITextModel, position: Position, context: InlineCompletionContext, token: CancellationToken): ProviderResult<T>;\n\n\t/**\n\t * Will be called when an item is shown.\n\t * @param updatedInsertText Is useful to understand bracket completion.\n\t*/\n\thandleItemDidShow?(completions: T, item: T['items'][number], updatedInsertText: string, editDeltaInfo: EditDeltaInfo): void;\n\n\t/**\n\t * Will be called when an item is partially accepted. TODO: also handle full acceptance here!\n\t * @param acceptedCharacters Deprecated. Use `info.acceptedCharacters` instead.\n\t */\n\thandlePartialAccept?(completions: T, item: T['items'][number], acceptedCharacters: number, info: PartialAcceptInfo): void;\n\n\t/**\n\t * @deprecated Use `handleEndOfLifetime` instead.\n\t*/\n\thandleRejection?(completions: T, item: T['items'][number]): void;\n\n\t/**\n\t * Is called when an inline completion item is no longer being used.\n\t * Provides a reason of why it is not used anymore.\n\t*/\n\thandleEndOfLifetime?(completions: T, item: T['items'][number], reason: InlineCompletionEndOfLifeReason<T['items'][number]>, lifetimeSummary: LifetimeSummary): void;\n\n\t/**\n\t * Will be called when a completions list is no longer in use and can be garbage-collected.\n\t*/\n\tdisposeInlineCompletions(completions: T, reason: InlineCompletionsDisposeReason): void;\n\n\tonDidChangeInlineCompletions?: Event<void>;\n\n\t/**\n\t * Only used for {@link yieldsToGroupIds}.\n\t * Multiple providers can have the same group id.\n\t */\n\tgroupId?: InlineCompletionProviderGroupId;\n\n\t/** @internal */\n\tproviderId?: ProviderId;\n\n\t/**\n\t * Returns a list of preferred provider {@link groupId}s.\n\t * The current provider is only requested for completions if no provider with a preferred group id returned a result.\n\t */\n\tyieldsToGroupIds?: InlineCompletionProviderGroupId[];\n\n\texcludesGroupIds?: InlineCompletionProviderGroupId[];\n\n\tdisplayName?: string;\n\n\tdebounceDelayMs?: number;\n\n\ttoString?(): string;\n}\n\n\n/** @internal */\nexport class ProviderId {\n\tpublic static fromExtensionId(extensionId: string | undefined): ProviderId {\n\t\treturn new ProviderId(extensionId, undefined, undefined);\n\t}\n\n\tconstructor(\n\t\tpublic readonly extensionId: string | undefined,\n\t\tpublic readonly extensionVersion: string | undefined,\n\t\tpublic readonly providerId: string | undefined\n\t) {\n\t}\n\n\ttoString(): string {\n\t\tlet result = '';\n\t\tif (this.extensionId) {\n\t\t\tresult += this.extensionId;\n\t\t}\n\t\tif (this.extensionVersion) {\n\t\t\tresult += `@${this.extensionVersion}`;\n\t\t}\n\t\tif (this.providerId) {\n\t\t\tresult += `:${this.providerId}`;\n\t\t}\n\t\tif (result.length === 0) {\n\t\t\tresult = 'unknown';\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/** @internal */\nexport class VersionedExtensionId {\n\tpublic static tryCreate(extensionId: string | undefined, version: string | undefined): VersionedExtensionId | undefined {\n\t\tif (!extensionId || !version) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new VersionedExtensionId(extensionId, version);\n\t}\n\n\tconstructor(\n\t\tpublic readonly extensionId: string,\n\t\tpublic readonly version: string,\n\t) { }\n\n\ttoString(): string {\n\t\treturn `${this.extensionId}@${this.version}`;\n\t}\n}\n\nexport type InlineCompletionsDisposeReason = { kind: 'lostRace' | 'tokenCancellation' | 'other' | 'empty' | 'notTaken' };\n\nexport enum InlineCompletionEndOfLifeReasonKind {\n\tAccepted = 0,\n\tRejected = 1,\n\tIgnored = 2,\n}\n\nexport type InlineCompletionEndOfLifeReason<TInlineCompletion = InlineCompletion> = {\n\tkind: InlineCompletionEndOfLifeReasonKind.Accepted; // User did an explicit action to accept\n} | {\n\tkind: InlineCompletionEndOfLifeReasonKind.Rejected; // User did an explicit action to reject\n} | {\n\tkind: InlineCompletionEndOfLifeReasonKind.Ignored;\n\tsupersededBy?: TInlineCompletion;\n\tuserTypingDisagreed: boolean;\n};\n\nexport type LifetimeSummary = {\n\trequestUuid: string;\n\tcorrelationId: string | undefined;\n\tpartiallyAccepted: number;\n\tpartiallyAcceptedCountSinceOriginal: number;\n\tpartiallyAcceptedRatioSinceOriginal: number;\n\tpartiallyAcceptedCharactersSinceOriginal: number;\n\tshown: boolean;\n\tshownDuration: number;\n\tshownDurationUncollapsed: number;\n\ttimeUntilShown: number | undefined;\n\ttimeUntilProviderRequest: number;\n\ttimeUntilProviderResponse: number;\n\tnotShownReason: string | undefined;\n\teditorType: string;\n\tviewKind: string | undefined;\n\terror: string | undefined;\n\tpreceeded: boolean;\n\tlanguageId: string;\n\trequestReason: string;\n\tcursorColumnDistance?: number;\n\tcursorLineDistance?: number;\n\tlineCountOriginal?: number;\n\tlineCountModified?: number;\n\tcharacterCountOriginal?: number;\n\tcharacterCountModified?: number;\n\tdisjointReplacements?: number;\n\tsameShapeReplacements?: boolean;\n\ttypingInterval: number;\n\ttypingIntervalCharacterCount: number;\n\tselectedSuggestionInfo: boolean;\n\tavailableProviders: string;\n};\n\nexport interface CodeAction {\n\ttitle: string;\n\tcommand?: Command;\n\tedit?: WorkspaceEdit;\n\tdiagnostics?: IMarkerData[];\n\tkind?: string;\n\tisPreferred?: boolean;\n\tisAI?: boolean;\n\tdisabled?: string;\n\tranges?: IRange[];\n}\n\nexport const enum CodeActionTriggerType {\n\tInvoke = 1,\n\tAuto = 2,\n}\n\n/**\n * @internal\n */\nexport interface CodeActionContext {\n\tonly?: string;\n\ttrigger: CodeActionTriggerType;\n}\n\nexport interface CodeActionList extends IDisposable {\n\treadonly actions: ReadonlyArray<CodeAction>;\n}\n\n/**\n * The code action interface defines the contract between extensions and\n * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.\n * @internal\n */\nexport interface CodeActionProvider {\n\n\tdisplayName?: string;\n\n\textensionId?: string;\n\n\t/**\n\t * Provide commands for the given document and range.\n\t */\n\tprovideCodeActions(model: model.ITextModel, range: Range | Selection, context: CodeActionContext, token: CancellationToken): ProviderResult<CodeActionList>;\n\n\t/**\n\t * Given a code action fill in the edit. Will only invoked when missing.\n\t */\n\tresolveCodeAction?(codeAction: CodeAction, token: CancellationToken): ProviderResult<CodeAction>;\n\n\t/**\n\t * Optional list of CodeActionKinds that this provider returns.\n\t */\n\treadonly providedCodeActionKinds?: ReadonlyArray<string>;\n\n\treadonly documentation?: ReadonlyArray<{ readonly kind: string; readonly command: Command }>;\n\n\t/**\n\t * @internal\n\t */\n\t_getAdditionalMenuItems?(context: CodeActionContext, actions: readonly CodeAction[]): Command[];\n}\n\n/**\n * @internal\n */\nexport interface DocumentPasteEdit {\n\treadonly title: string;\n\treadonly kind: HierarchicalKind;\n\treadonly handledMimeType?: string;\n\tyieldTo?: readonly DropYieldTo[];\n\tinsertText: string | { readonly snippet: string };\n\tadditionalEdit?: WorkspaceEdit;\n}\n\n/**\n * @internal\n */\nexport enum DocumentPasteTriggerKind {\n\tAutomatic = 0,\n\tPasteAs = 1,\n}\n\n/**\n * @internal\n */\nexport interface DocumentPasteContext {\n\treadonly only?: HierarchicalKind;\n\treadonly triggerKind: DocumentPasteTriggerKind;\n}\n\n/**\n * @internal\n */\nexport interface DocumentPasteEditsSession {\n\tedits: readonly DocumentPasteEdit[];\n\tdispose(): void;\n}\n\n/**\n * @internal\n */\nexport interface DocumentPasteEditProvider {\n\treadonly id?: string;\n\treadonly copyMimeTypes: readonly string[];\n\treadonly pasteMimeTypes: readonly string[];\n\treadonly providedPasteEditKinds: readonly HierarchicalKind[];\n\n\tprepareDocumentPaste?(model: model.ITextModel, ranges: readonly IRange[], dataTransfer: IReadonlyVSDataTransfer, token: CancellationToken): Promise<undefined | IReadonlyVSDataTransfer>;\n\n\tprovideDocumentPasteEdits?(model: model.ITextModel, ranges: readonly IRange[], dataTransfer: IReadonlyVSDataTransfer, context: DocumentPasteContext, token: CancellationToken): Promise<DocumentPasteEditsSession | undefined>;\n\n\tresolveDocumentPasteEdit?(edit: DocumentPasteEdit, token: CancellationToken): Promise<DocumentPasteEdit>;\n}\n\n/**\n * Represents a parameter of a callable-signature. A parameter can\n * have a label and a doc-comment.\n */\nexport interface ParameterInformation {\n\t/**\n\t * The label of this signature. Will be shown in\n\t * the UI.\n\t */\n\tlabel: string | [number, number];\n\t/**\n\t * The human-readable doc-comment of this signature. Will be shown\n\t * in the UI but can be omitted.\n\t */\n\tdocumentation?: string | IMarkdownString;\n}\n/**\n * Represents the signature of something callable. A signature\n * can have a label, like a function-name, a doc-comment, and\n * a set of parameters.\n */\nexport interface SignatureInformation {\n\t/**\n\t * The label of this signature. Will be shown in\n\t * the UI.\n\t */\n\tlabel: string;\n\t/**\n\t * The human-readable doc-comment of this signature. Will be shown\n\t * in the UI but can be omitted.\n\t */\n\tdocumentation?: string | IMarkdownString;\n\t/**\n\t * The parameters of this signature.\n\t */\n\tparameters: ParameterInformation[];\n\t/**\n\t * Index of the active parameter.\n\t *\n\t * If provided, this is used in place of `SignatureHelp.activeSignature`.\n\t */\n\tactiveParameter?: number;\n}\n/**\n * Signature help represents the signature of something\n * callable. There can be multiple signatures but only one\n * active and only one active parameter.\n */\nexport interface SignatureHelp {\n\t/**\n\t * One or more signatures.\n\t */\n\tsignatures: SignatureInformation[];\n\t/**\n\t * The active signature.\n\t */\n\tactiveSignature: number;\n\t/**\n\t * The active parameter of the active signature.\n\t */\n\tactiveParameter: number;\n}\n\nexport interface SignatureHelpResult extends IDisposable {\n\tvalue: SignatureHelp;\n}\n\nexport enum SignatureHelpTriggerKind {\n\tInvoke = 1,\n\tTriggerCharacter = 2,\n\tContentChange = 3,\n}\n\nexport interface SignatureHelpContext {\n\treadonly triggerKind: SignatureHelpTriggerKind;\n\treadonly triggerCharacter?: string;\n\treadonly isRetrigger: boolean;\n\treadonly activeSignatureHelp?: SignatureHelp;\n}\n\n/**\n * The signature help provider interface defines the contract between extensions and\n * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.\n */\nexport interface SignatureHelpProvider {\n\n\treadonly signatureHelpTriggerCharacters?: ReadonlyArray<string>;\n\treadonly signatureHelpRetriggerCharacters?: ReadonlyArray<string>;\n\n\t/**\n\t * Provide help for the signature at the given position and document.\n\t */\n\tprovideSignatureHelp(model: model.ITextModel, position: Position, token: CancellationToken, context: SignatureHelpContext): ProviderResult<SignatureHelpResult>;\n}\n\n/**\n * A document highlight kind.\n */\nexport enum DocumentHighlightKind {\n\t/**\n\t * A textual occurrence.\n\t */\n\tText,\n\t/**\n\t * Read-access of a symbol, like reading a variable.\n\t */\n\tRead,\n\t/**\n\t * Write-access of a symbol, like writing to a variable.\n\t */\n\tWrite\n}\n/**\n * A document highlight is a range inside a text document which deserves\n * special attention. Usually a document highlight is visualized by changing\n * the background color of its range.\n */\nexport interface DocumentHighlight {\n\t/**\n\t * The range this highlight applies to.\n\t */\n\trange: IRange;\n\t/**\n\t * The highlight kind, default is {@link DocumentHighlightKind.Text text}.\n\t */\n\tkind?: DocumentHighlightKind;\n}\n\n/**\n * Represents a set of document highlights for a specific URI.\n */\nexport interface MultiDocumentHighlight {\n\t/**\n\t * The URI of the document that the highlights belong to.\n\t */\n\turi: URI;\n\n\t/**\n\t * The set of highlights for the document.\n\t */\n\thighlights: DocumentHighlight[];\n}\n\n/**\n * The document highlight provider interface defines the contract between extensions and\n * the word-highlight-feature.\n */\nexport interface DocumentHighlightProvider {\n\t/**\n\t * Provide a set of document highlights, like all occurrences of a variable or\n\t * all exit-points of a function.\n\t */\n\tprovideDocumentHighlights(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<DocumentHighlight[]>;\n}\n\n/**\n * A provider that can provide document highlights across multiple documents.\n */\nexport interface MultiDocumentHighlightProvider {\n\treadonly selector: LanguageSelector;\n\n\t/**\n\t * Provide a Map of URI --> document highlights, like all occurrences of a variable or\n\t * all exit-points of a function.\n\t *\n\t * Used in cases such as split view, notebooks, etc. where there can be multiple documents\n\t * with shared symbols.\n\t *\n\t * @param primaryModel The primary text model.\n\t * @param position The position at which to provide document highlights.\n\t * @param otherModels The other text models to search for document highlights.\n\t * @param token A cancellation token.\n\t * @returns A map of URI to document highlights.\n\t */\n\tprovideMultiDocumentHighlights(primaryModel: model.ITextModel, position: Position, otherModels: model.ITextModel[], token: CancellationToken): ProviderResult<Map<URI, DocumentHighlight[]>>;\n}\n\n/**\n * The linked editing range provider interface defines the contract between extensions and\n * the linked editing feature.\n */\nexport interface LinkedEditingRangeProvider {\n\n\t/**\n\t * Provide a list of ranges that can be edited together.\n\t */\n\tprovideLinkedEditingRanges(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<LinkedEditingRanges>;\n}\n\n/**\n * Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.\n */\nexport interface LinkedEditingRanges {\n\t/**\n\t * A list of ranges that can be edited together. The ranges must have\n\t * identical length and text content. The ranges cannot overlap\n\t */\n\tranges: IRange[];\n\n\t/**\n\t * An optional word pattern that describes valid contents for the given ranges.\n\t * If no pattern is provided, the language configuration's word pattern will be used.\n\t */\n\twordPattern?: RegExp;\n}\n\n/**\n * Value-object that contains additional information when\n * requesting references.\n */\nexport interface ReferenceContext {\n\t/**\n\t * Include the declaration of the current symbol.\n\t */\n\tincludeDeclaration: boolean;\n}\n/**\n * The reference provider interface defines the contract between extensions and\n * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.\n */\nexport interface ReferenceProvider {\n\t/**\n\t * Provide a set of project-wide references for the given position and document.\n\t */\n\tprovideReferences(model: model.ITextModel, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;\n}\n\n/**\n * Represents a location inside a resource, such as a line\n * inside a text file.\n */\nexport interface Location {\n\t/**\n\t * The resource identifier of this location.\n\t */\n\turi: URI;\n\t/**\n\t * The document range of this locations.\n\t */\n\trange: IRange;\n}\n\nexport interface LocationLink {\n\t/**\n\t * A range to select where this link originates from.\n\t */\n\toriginSelectionRange?: IRange;\n\n\t/**\n\t * The target uri this link points to.\n\t */\n\turi: URI;\n\n\t/**\n\t * The full range this link points to.\n\t */\n\trange: IRange;\n\n\t/**\n\t * A range to select this link points to. Must be contained\n\t * in `LocationLink.range`.\n\t */\n\ttargetSelectionRange?: IRange;\n}\n\n/**\n * @internal\n */\nexport function isLocationLink(thing: any): thing is LocationLink {\n\treturn thing\n\t\t&& URI.isUri((thing as LocationLink).uri)\n\t\t&& Range.isIRange((thing as LocationLink).range)\n\t\t&& (Range.isIRange((thing as LocationLink).originSelectionRange) || Range.isIRange((thing as LocationLink).targetSelectionRange));\n}\n\n/**\n * @internal\n */\nexport function isLocation(thing: any): thing is Location {\n\treturn thing\n\t\t&& URI.isUri((thing as Location).uri)\n\t\t&& Range.isIRange((thing as Location).range);\n}\n\n\nexport type Definition = Location | Location[] | LocationLink[];\n\n/**\n * The definition provider interface defines the contract between extensions and\n * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)\n * and peek definition features.\n */\nexport interface DefinitionProvider {\n\t/**\n\t * Provide the definition of the symbol at the given position and document.\n\t */\n\tprovideDefinition(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;\n}\n\n/**\n * The definition provider interface defines the contract between extensions and\n * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)\n * and peek definition features.\n */\nexport interface DeclarationProvider {\n\t/**\n\t * Provide the declaration of the symbol at the given position and document.\n\t */\n\tprovideDeclaration(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;\n}\n\n/**\n * The implementation provider interface defines the contract between extensions and\n * the go to implementation feature.\n */\nexport interface ImplementationProvider {\n\t/**\n\t * Provide the implementation of the symbol at the given position and document.\n\t */\n\tprovideImplementation(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;\n}\n\n/**\n * The type definition provider interface defines the contract between extensions and\n * the go to type definition feature.\n */\nexport interface TypeDefinitionProvider {\n\t/**\n\t * Provide the type definition of the symbol at the given position and document.\n\t */\n\tprovideTypeDefinition(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;\n}\n\n/**\n * A symbol kind.\n */\nexport const enum SymbolKind {\n\tFile = 0,\n\tModule = 1,\n\tNamespace = 2,\n\tPackage = 3,\n\tClass = 4,\n\tMethod = 5,\n\tProperty = 6,\n\tField = 7,\n\tConstructor = 8,\n\tEnum = 9,\n\tInterface = 10,\n\tFunction = 11,\n\tVariable = 12,\n\tConstant = 13,\n\tString = 14,\n\tNumber = 15,\n\tBoolean = 16,\n\tArray = 17,\n\tObject = 18,\n\tKey = 19,\n\tNull = 20,\n\tEnumMember = 21,\n\tStruct = 22,\n\tEvent = 23,\n\tOperator = 24,\n\tTypeParameter = 25\n}\n\n/**\n * @internal\n */\nexport const symbolKindNames: { [symbol: number]: string } = {\n\t[SymbolKind.Array]: localize('Array', \"array\"),\n\t[SymbolKind.Boolean]: localize('Boolean', \"boolean\"),\n\t[SymbolKind.Class]: localize('Class', \"class\"),\n\t[SymbolKind.Constant]: localize('Constant', \"constant\"),\n\t[SymbolKind.Constructor]: localize('Constructor', \"constructor\"),\n\t[SymbolKind.Enum]: localize('Enum', \"enumeration\"),\n\t[SymbolKind.EnumMember]: localize('EnumMember', \"enumeration member\"),\n\t[SymbolKind.Event]: localize('Event', \"event\"),\n\t[SymbolKind.Field]: localize('Field', \"field\"),\n\t[SymbolKind.File]: localize('File', \"file\"),\n\t[SymbolKind.Function]: localize('Function', \"function\"),\n\t[SymbolKind.Interface]: localize('Interface', \"interface\"),\n\t[SymbolKind.Key]: localize('Key', \"key\"),\n\t[SymbolKind.Method]: localize('Method', \"method\"),\n\t[SymbolKind.Module]: localize('Module', \"module\"),\n\t[SymbolKind.Namespace]: localize('Namespace', \"namespace\"),\n\t[SymbolKind.Null]: localize('Null', \"null\"),\n\t[SymbolKind.Number]: localize('Number', \"number\"),\n\t[SymbolKind.Object]: localize('Object', \"object\"),\n\t[SymbolKind.Operator]: localize('Operator', \"operator\"),\n\t[SymbolKind.Package]: localize('Package', \"package\"),\n\t[SymbolKind.Property]: localize('Property', \"property\"),\n\t[SymbolKind.String]: localize('String', \"string\"),\n\t[SymbolKind.Struct]: localize('Struct', \"struct\"),\n\t[SymbolKind.TypeParameter]: localize('TypeParameter', \"type parameter\"),\n\t[SymbolKind.Variable]: localize('Variable', \"variable\"),\n};\n\n/**\n * @internal\n */\nexport function getAriaLabelForSymbol(symbolName: string, kind: SymbolKind): string {\n\treturn localize('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);\n}\n\nexport const enum SymbolTag {\n\tDeprecated = 1,\n}\n\n/**\n * @internal\n */\nexport namespace SymbolKinds {\n\n\tconst byKind = new Map<SymbolKind, ThemeIcon>();\n\tbyKind.set(SymbolKind.File, Codicon.symbolFile);\n\tbyKind.set(SymbolKind.Module, Codicon.symbolModule);\n\tbyKind.set(SymbolKind.Namespace, Codicon.symbolNamespace);\n\tbyKind.set(SymbolKind.Package, Codicon.symbolPackage);\n\tbyKind.set(SymbolKind.Class, Codicon.symbolClass);\n\tbyKind.set(SymbolKind.Method, Codicon.symbolMethod);\n\tbyKind.set(SymbolKind.Property, Codicon.symbolProperty);\n\tbyKind.set(SymbolKind.Field, Codicon.symbolField);\n\tbyKind.set(SymbolKind.Constructor, Codicon.symbolConstructor);\n\tbyKind.set(SymbolKind.Enum, Codicon.symbolEnum);\n\tbyKind.set(SymbolKind.Interface, Codicon.symbolInterface);\n\tbyKind.set(SymbolKind.Function, Codicon.symbolFunction);\n\tbyKind.set(SymbolKind.Variable, Codicon.symbolVariable);\n\tbyKind.set(SymbolKind.Constant, Codicon.symbolConstant);\n\tbyKind.set(SymbolKind.String, Codicon.symbolString);\n\tbyKind.set(SymbolKind.Number, Codicon.symbolNumber);\n\tbyKind.set(SymbolKind.Boolean, Codicon.symbolBoolean);\n\tbyKind.set(SymbolKind.Array, Codicon.symbolArray);\n\tbyKind.set(SymbolKind.Object, Codicon.symbolObject);\n\tbyKind.set(SymbolKind.Key, Codicon.symbolKey);\n\tbyKind.set(SymbolKind.Null, Codicon.symbolNull);\n\tbyKind.set(SymbolKind.EnumMember, Codicon.symbolEnumMember);\n\tbyKind.set(SymbolKind.Struct, Codicon.symbolStruct);\n\tbyKind.set(SymbolKind.Event, Codicon.symbolEvent);\n\tbyKind.set(SymbolKind.Operator, Codicon.symbolOperator);\n\tbyKind.set(SymbolKind.TypeParameter, Codicon.symbolTypeParameter);\n\t/**\n\t * @internal\n\t */\n\texport function toIcon(kind: SymbolKind): ThemeIcon {\n\t\tlet icon = byKind.get(kind);\n\t\tif (!icon) {\n\t\t\tconsole.info('No codicon found for SymbolKind ' + kind);\n\t\t\ticon = Codicon.symbolProperty;\n\t\t}\n\t\treturn icon;\n\t}\n\n\tconst byCompletionKind = new Map<SymbolKind, CompletionItemKind>();\n\tbyCompletionKind.set(SymbolKind.File, CompletionItemKind.File);\n\tbyCompletionKind.set(SymbolKind.Module, CompletionItemKind.Module);\n\tbyCompletionKind.set(SymbolKind.Namespace, CompletionItemKind.Module);\n\tbyCompletionKind.set(SymbolKind.Package, CompletionItemKind.Module);\n\tbyCompletionKind.set(SymbolKind.Class, CompletionItemKind.Class);\n\tbyCompletionKind.set(SymbolKind.Method, CompletionItemKind.Method);\n\tbyCompletionKind.set(SymbolKind.Property, CompletionItemKind.Property);\n\tbyCompletionKind.set(SymbolKind.Field, CompletionItemKind.Field);\n\tbyCompletionKind.set(SymbolKind.Constructor, CompletionItemKind.Constructor);\n\tbyCompletionKind.set(SymbolKind.Enum, CompletionItemKind.Enum);\n\tbyCompletionKind.set(SymbolKind.Interface, CompletionItemKind.Interface);\n\tbyCompletionKind.set(SymbolKind.Function, CompletionItemKind.Function);\n\tbyCompletionKind.set(SymbolKind.Variable, CompletionItemKind.Variable);\n\tbyCompletionKind.set(SymbolKind.Constant, CompletionItemKind.Constant);\n\tbyCompletionKind.set(SymbolKind.String, CompletionItemKind.Text);\n\tbyCompletionKind.set(SymbolKind.Number, CompletionItemKind.Value);\n\tbyCompletionKind.set(SymbolKind.Boolean, CompletionItemKind.Value);\n\tbyCompletionKind.set(SymbolKind.Array, CompletionItemKind.Value);\n\tbyCompletionKind.set(SymbolKind.Object, CompletionItemKind.Value);\n\tbyCompletionKind.set(SymbolKind.Key, CompletionItemKind.Keyword);\n\tbyCompletionKind.set(SymbolKind.Null, CompletionItemKind.Value);\n\tbyCompletionKind.set(SymbolKind.EnumMember, CompletionItemKind.EnumMember);\n\tbyCompletionKind.set(SymbolKind.Struct, CompletionItemKind.Struct);\n\tbyCompletionKind.set(SymbolKind.Event, CompletionItemKind.Event);\n\tbyCompletionKind.set(SymbolKind.Operator, CompletionItemKind.Operator);\n\tbyCompletionKind.set(SymbolKind.TypeParameter, CompletionItemKind.TypeParameter);\n\t/**\n\t * @internal\n\t */\n\texport function toCompletionKind(kind: SymbolKind): CompletionItemKind {\n\t\tlet completionKind = byCompletionKind.get(kind);\n\t\tif (completionKind === undefined) {\n\t\t\tconsole.info('No completion kind found for SymbolKind ' + kind);\n\t\t\tcompletionKind = CompletionItemKind.File;\n\t\t}\n\t\treturn completionKind;\n\t}\n}\n\nexport interface DocumentSymbol {\n\tname: string;\n\tdetail: string;\n\tkind: SymbolKind;\n\ttags: ReadonlyArray<SymbolTag>;\n\tcontainerName?: string;\n\trange: IRange;\n\tselectionRange: IRange;\n\tchildren?: DocumentSymbol[];\n}\n\n/**\n * The document symbol provider interface defines the contract between extensions and\n * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.\n */\nexport interface DocumentSymbolProvider {\n\n\tdisplayName?: string;\n\n\t/**\n\t * Provide symbol information for the given document.\n\t */\n\tprovideDocumentSymbols(model: model.ITextModel, token: CancellationToken): ProviderResult<DocumentSymbol[]>;\n}\n\nexport interface TextEdit {\n\trange: IRange;\n\ttext: string;\n\teol?: model.EndOfLineSequence;\n}\n\n/** @internal */\nexport abstract class TextEdit {\n\tstatic asEditOperation(edit: TextEdit): ISingleEditOperation {\n\t\tconst range = Range.lift(edit.range);\n\t\treturn range.isEmpty()\n\t\t\t? EditOperation.insert(range.getStartPosition(), edit.text) // moves marker\n\t\t\t: EditOperation.replace(range, edit.text);\n\t}\n\tstatic isTextEdit(thing: any): thing is TextEdit {\n\t\tconst possibleTextEdit = thing as TextEdit;\n\t\treturn typeof possibleTextEdit.text === 'string' && Range.isIRange(possibleTextEdit.range);\n\t}\n}\n\n/**\n * Interface used to format a model\n */\nexport interface FormattingOptions {\n\t/**\n\t * Size of a tab in spaces.\n\t */\n\ttabSize: number;\n\t/**\n\t * Prefer spaces over tabs.\n\t */\n\tinsertSpaces: boolean;\n}\n/**\n * The document formatting provider interface defines the contract between extensions and\n * the formatting-feature.\n */\nexport interface DocumentFormattingEditProvider {\n\n\t/**\n\t * @internal\n\t */\n\treadonly extensionId?: ExtensionIdentifier;\n\n\treadonly displayName?: string;\n\n\t/**\n\t * Provide formatting edits for a whole document.\n\t */\n\tprovideDocumentFormattingEdits(model: model.ITextModel, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;\n}\n/**\n * The document formatting provider interface defines the contract between extensions and\n * the formatting-feature.\n */\nexport interface DocumentRangeFormattingEditProvider {\n\t/**\n\t * @internal\n\t */\n\treadonly extensionId?: ExtensionIdentifier;\n\n\treadonly displayName?: string;\n\n\t/**\n\t * Provide formatting edits for a range in a document.\n\t *\n\t * The given range is a hint and providers can decide to format a smaller\n\t * or larger range. Often this is done by adjusting the start and end\n\t * of the range to full syntax nodes.\n\t */\n\tprovideDocumentRangeFormattingEdits(model: model.ITextModel, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;\n\n\tprovideDocumentRangesFormattingEdits?(model: model.ITextModel, ranges: Range[], options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;\n}\n/**\n * The document formatting provider interface defines the contract between extensions and\n * the formatting-feature.\n */\nexport interface OnTypeFormattingEditProvider {\n\n\n\t/**\n\t * @internal\n\t */\n\treadonly extensionId?: ExtensionIdentifier;\n\n\tautoFormatTriggerCharacters: string[];\n\n\t/**\n\t * Provide formatting edits after a character has been typed.\n\t *\n\t * The given position and character should hint to the provider\n\t * what range the position to expand to, like find the matching `{`\n\t * when `}` has been entered.\n\t */\n\tprovideOnTypeFormattingEdits(model: model.ITextModel, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;\n}\n\n/**\n * @internal\n */\nexport interface IInplaceReplaceSupportResult {\n\tvalue: string;\n\trange: IRange;\n}\n\n/**\n * A link inside the editor.\n */\nexport interface ILink {\n\trange: IRange;\n\turl?: URI | string;\n\ttooltip?: string;\n}\n\nexport interface ILinksList {\n\tlinks: ILink[];\n\tdispose?(): void;\n}\n/**\n * A provider of links.\n */\nexport interface LinkProvider {\n\tprovideLinks(model: model.ITextModel, token: CancellationToken): ProviderResult<ILinksList>;\n\tresolveLink?: (link: ILink, token: CancellationToken) => ProviderResult<ILink>;\n}\n\n/**\n * A color in RGBA format.\n */\nexport interface IColor {\n\n\t/**\n\t * The red component in the range [0-1].\n\t */\n\treadonly red: number;\n\n\t/**\n\t * The green component in the range [0-1].\n\t */\n\treadonly green: number;\n\n\t/**\n\t * The blue component in the range [0-1].\n\t */\n\treadonly blue: number;\n\n\t/**\n\t * The alpha component in the range [0-1].\n\t */\n\treadonly alpha: number;\n}\n\n/**\n * String representations for a color\n */\nexport interface IColorPresentation {\n\t/**\n\t * The label of this color presentation. It will be shown on the color\n\t * picker header. By default this is also the text that is inserted when selecting\n\t * this color presentation.\n\t */\n\tlabel: string;\n\t/**\n\t * An {@link TextEdit edit} which is applied to a document when selecting\n\t * this presentation for the color.\n\t */\n\ttextEdit?: TextEdit;\n\t/**\n\t * An optional array of additional {@link TextEdit text edits} that are applied when\n\t * selecting this color presentation.\n\t */\n\tadditionalTextEdits?: TextEdit[];\n}\n\n/**\n * A color range is a range in a text model which represents a color.\n */\nexport interface IColorInformation {\n\n\t/**\n\t * The range within the model.\n\t */\n\trange: IRange;\n\n\t/**\n\t * The color represented in this range.\n\t */\n\tcolor: IColor;\n}\n\n/**\n * A provider of colors for editor models.\n */\nexport interface DocumentColorProvider {\n\t/**\n\t * Provides the color ranges for a specific model.\n\t */\n\tprovideDocumentColors(model: model.ITextModel, token: CancellationToken): ProviderResult<IColorInformation[]>;\n\t/**\n\t * Provide the string representations for a color.\n\t */\n\tprovideColorPresentations(model: model.ITextModel, colorInfo: IColorInformation, token: CancellationToken): ProviderResult<IColorPresentation[]>;\n}\n\nexport interface SelectionRange {\n\trange: IRange;\n}\n\nexport interface SelectionRangeProvider {\n\t/**\n\t * Provide ranges that should be selected from the given position.\n\t */\n\tprovideSelectionRanges(model: model.ITextModel, positions: Position[], token: CancellationToken): ProviderResult<SelectionRange[][]>;\n}\n\nexport interface FoldingContext {\n}\n/**\n * A provider of folding ranges for editor models.\n */\nexport interface FoldingRangeProvider {\n\n\t/**\n\t * @internal\n\t */\n\treadonly id?: string;\n\n\t/**\n\t * An optional event to signal that the folding ranges from this provider have changed.\n\t */\n\tonDidChange?: Event<this>;\n\n\t/**\n\t * Provides the folding ranges for a specific model.\n\t */\n\tprovideFoldingRanges(model: model.ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]>;\n}\n\nexport interface FoldingRange {\n\n\t/**\n\t * The one-based start line of the range to fold. The folded area starts after the line's last character.\n\t */\n\tstart: number;\n\n\t/**\n\t * The one-based end line of the range to fold. The folded area ends with the line's last character.\n\t */\n\tend: number;\n\n\t/**\n\t * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or\n\t * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands\n\t * like 'Fold all comments'. See\n\t * {@link FoldingRangeKind} for an enumeration of standardized kinds.\n\t */\n\tkind?: FoldingRangeKind;\n}\nexport class FoldingRangeKind {\n\t/**\n\t * Kind for folding range representing a comment. The value of the kind is 'comment'.\n\t */\n\tstatic readonly Comment = new FoldingRangeKind('comment');\n\t/**\n\t * Kind for folding range representing a import. The value of the kind is 'imports'.\n\t */\n\tstatic readonly Imports = new FoldingRangeKind('imports');\n\t/**\n\t * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n\t * The value of the kind is 'region'.\n\t */\n\tstatic readonly Region = new FoldingRangeKind('region');\n\n\t/**\n\t * Returns a {@link FoldingRangeKind} for the given value.\n\t *\n\t * @param value of the kind.\n\t */\n\tstatic fromValue(value: string) {\n\t\tswitch (value) {\n\t\t\tcase 'comment': return FoldingRangeKind.Comment;\n\t\t\tcase 'imports': return FoldingRangeKind.Imports;\n\t\t\tcase 'region': return FoldingRangeKind.Region;\n\t\t}\n\t\treturn new FoldingRangeKind(value);\n\t}\n\n\t/**\n\t * Creates a new {@link FoldingRangeKind}.\n\t *\n\t * @param value of the kind.\n\t */\n\tpublic constructor(public value: string) {\n\t}\n}\n\n\nexport interface WorkspaceEditMetadata {\n\tneedsConfirmation: boolean;\n\tlabel: string;\n\tdescription?: string;\n\t/**\n\t * @internal\n\t */\n\ticonPath?: ThemeIcon | URI | { light: URI; dark: URI };\n}\n\nexport interface WorkspaceFileEditOptions {\n\toverwrite?: boolean;\n\tignoreIfNotExists?: boolean;\n\tignoreIfExists?: boolean;\n\trecursive?: boolean;\n\tcopy?: boolean;\n\tfolder?: boolean;\n\tskipTrashBin?: boolean;\n\tmaxSize?: number;\n\n\t/**\n\t * @internal\n\t */\n\tcontents?: Promise<VSBuffer>;\n}\n\nexport interface IWorkspaceFileEdit {\n\toldResource?: URI;\n\tnewResource?: URI;\n\toptions?: WorkspaceFileEditOptions;\n\tmetadata?: WorkspaceEditMetadata;\n}\n\nexport interface IWorkspaceTextEdit {\n\tresource: URI;\n\ttextEdit: TextEdit & { insertAsSnippet?: boolean; keepWhitespace?: boolean };\n\tversionId: number | undefined;\n\tmetadata?: WorkspaceEditMetadata;\n}\n\nexport interface WorkspaceEdit {\n\tedits: Array<IWorkspaceTextEdit | IWorkspaceFileEdit | ICustomEdit>;\n}\n\nexport interface ICustomEdit {\n\treadonly resource: URI;\n\treadonly metadata?: WorkspaceEditMetadata;\n\tundo(): Promise<void> | void;\n\tredo(): Promise<void> | void;\n}\n\nexport interface Rejection {\n\trejectReason?: string;\n}\nexport interface RenameLocation {\n\trange: IRange;\n\ttext: string;\n}\n\nexport interface RenameProvider {\n\tprovideRenameEdits(model: model.ITextModel, position: Position, newName: string, token: CancellationToken): ProviderResult<WorkspaceEdit & Rejection>;\n\tresolveRenameLocation?(model: model.ITextModel, position: Position, token: CancellationToken): ProviderResult<RenameLocation & Rejection>;\n}\n\nexport enum NewSymbolNameTag {\n\tAIGenerated = 1\n}\n\nexport enum NewSymbolNameTriggerKind {\n\tInvoke = 0,\n\tAutomatic = 1,\n}\n\nexport interface NewSymbolName {\n\treadonly newSymbolName: string;\n\treadonly tags?: readonly NewSymbolNameTag[];\n}\n\nexport interface NewSymbolNamesProvider {\n\tsupportsAutomaticNewSymbolNamesTriggerKind?: Promise<boolean | undefined>;\n\tprovideNewSymbolNames(model: model.ITextModel, range: IRange, triggerKind: NewSymbolNameTriggerKind, token: CancellationToken): ProviderResult<NewSymbolName[]>;\n}\n\nexport interface Command {\n\tid: string;\n\ttitle: string;\n\ttooltip?: string;\n\targuments?: any[];\n}\n\n/**\n * @internal\n */\nexport namespace Command {\n\n\t/**\n\t * @internal\n\t */\n\texport function is(obj: any): obj is Command {\n\t\tif (!obj || typeof obj !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<Command>obj).id === 'string' &&\n\t\t\ttypeof (<Command>obj).title === 'string';\n\t}\n}\n\n/**\n * @internal\n */\nexport interface CommentThreadTemplate {\n\tcontrollerHandle: number;\n\tlabel: string;\n\tacceptInputCommand?: Command;\n\tadditionalCommands?: Command[];\n\tdeleteCommand?: Command;\n}\n\n/**\n * @internal\n */\nexport interface CommentInfo<T = IRange> {\n\textensionId?: string;\n\tthreads: CommentThread<T>[];\n\tpendingCommentThreads?: PendingCommentThread[];\n\tcommentingRanges: CommentingRanges;\n}\n\n\n/**\n * @internal\n */\nexport interface CommentingRangeResourceHint {\n\tschemes: readonly string[];\n}\n\n/**\n * @internal\n */\nexport enum CommentThreadCollapsibleState {\n\t/**\n\t * Determines an item is collapsed\n\t */\n\tCollapsed = 0,\n\t/**\n\t * Determines an item is expanded\n\t */\n\tExpanded = 1\n}\n\n/**\n * @internal\n */\nexport enum CommentThreadState {\n\tUnresolved = 0,\n\tResolved = 1\n}\n\n/**\n * @internal\n */\nexport enum CommentThreadApplicability {\n\tCurrent = 0,\n\tOutdated = 1\n}\n\n/**\n * @internal\n */\nexport interface CommentWidget {\n\tcommentThread: CommentThread;\n\tcomment?: Comment;\n\tinput: string;\n\tonDidChangeInput: Event<string>;\n}\n\n/**\n * @internal\n */\nexport interface CommentInput {\n\tvalue: string;\n\turi: URI;\n}\n\nexport interface CommentThreadRevealOptions {\n\tpreserveFocus: boolean;\n\tfocusReply: boolean;\n}\n\n/**\n * @internal\n */\nexport interface CommentThread<T = IRange> {\n\tisDocumentCommentThread(): this is CommentThread<IRange>;\n\tcommentThreadHandle: number;\n\tcontrollerHandle: number;\n\textensionId?: string;\n\tthreadId: string;\n\tresource: string | null;\n\trange: T | undefined;\n\tlabel: string | undefined;\n\tcontextValue: string | undefined;\n\tcomments: ReadonlyArray<Comment> | undefined;\n\tonDidChangeComments: Event<readonly Comment[] | undefined>;\n\tcollapsibleState?: CommentThreadCollapsibleState;\n\tinitialCollapsibleState?: CommentThreadCollapsibleState;\n\tonDidChangeInitialCollapsibleState: Event<CommentThreadCollapsibleState | undefined>;\n\tstate?: CommentThreadState;\n\tapplicability?: CommentThreadApplicability;\n\tcanReply: boolean | CommentAuthorInformation;\n\tinput?: CommentInput;\n\tonDidChangeInput: Event<CommentInput | undefined>;\n\tonDidChangeLabel: Event<string | undefined>;\n\tonDidChangeCollapsibleState: Event<CommentThreadCollapsibleState | undefined>;\n\tonDidChangeState: Event<CommentThreadState | undefined>;\n\tonDidChangeCanReply: Event<boolean>;\n\tisDisposed: boolean;\n\tisTemplate: boolean;\n}\n\n/**\n * @internal\n */\nexport interface AddedCommentThread<T = IRange> extends CommentThread<T> {\n\teditorId?: string;\n}\n\n/**\n * @internal\n */\n\nexport interface CommentingRanges {\n\treadonly resource: URI;\n\tranges: IRange[];\n\tfileComments: boolean;\n}\n\nexport interface CommentAuthorInformation {\n\tname: string;\n\ticonPath?: UriComponents;\n\n}\n\n/**\n * @internal\n */\nexport interface CommentReaction {\n\treadonly label?: string;\n\treadonly iconPath?: UriComponents;\n\treadonly count?: number;\n\treadonly hasReacted?: boolean;\n\treadonly canEdit?: boolean;\n\treadonly reactors?: readonly string[];\n}\n\n/**\n * @internal\n */\nexport interface CommentOptions {\n\t/**\n\t * An optional string to show on the comment input box when it's collapsed.\n\t */\n\tprompt?: string;\n\n\t/**\n\t * An optional string to show as placeholder in the comment input box when it's focused.\n\t */\n\tplaceHolder?: string;\n}\n\n/**\n * @internal\n */\nexport enum CommentMode {\n\tEditing = 0,\n\tPreview = 1\n}\n\n/**\n * @internal\n */\nexport enum CommentState {\n\tPublished = 0,\n\tDraft = 1\n}\n\n/**\n * @internal\n */\nexport interface Comment {\n\treadonly uniqueIdInThread: number;\n\treadonly body: string | IMarkdownString;\n\treadonly userName: string;\n\treadonly userIconPath?: UriComponents;\n\treadonly contextValue?: string;\n\treadonly commentReactions?: CommentReaction[];\n\treadonly label?: string;\n\treadonly mode?: CommentMode;\n\treadonly timestamp?: string;\n}\n\nexport interface PendingCommentThread {\n\trange: IRange | undefined;\n\turi: URI;\n\tuniqueOwner: string;\n\tisReply: boolean;\n\tcomment: PendingComment;\n}\n\nexport interface PendingComment {\n\tbody: string;\n\tcursor: IPosition;\n}\n\n/**\n * @internal\n */\nexport interface CommentThreadChangedEvent<T> {\n\t/**\n\t * Pending comment threads.\n\t */\n\treadonly pending: PendingCommentThread[];\n\n\t/**\n\t * Added comment threads.\n\t */\n\treadonly added: AddedCommentThread<T>[];\n\n\t/**\n\t * Removed comment threads.\n\t */\n\treadonly removed: CommentThread<T>[];\n\n\t/**\n\t * Changed comment threads.\n\t */\n\treadonly changed: CommentThread<T>[];\n}\n\nexport interface CodeLens {\n\trange: IRange;\n\tid?: string;\n\tcommand?: Command;\n}\n\nexport interface CodeLensList {\n\treadonly lenses: readonly CodeLens[];\n\tdispose?(): void;\n}\n\nexport interface CodeLensProvider {\n\tonDidChange?: Event<this>;\n\tprovideCodeLenses(model: model.ITextModel, token: CancellationToken): ProviderResult<CodeLensList>;\n\tresolveCodeLens?(model: model.ITextModel, codeLens: CodeLens, token: CancellationToken): ProviderResult<CodeLens>;\n}\n\n\nexport enum InlayHintKind {\n\tType = 1,\n\tParameter = 2,\n}\n\nexport interface InlayHintLabelPart {\n\tlabel: string;\n\ttooltip?: string | IMarkdownString;\n\t// collapsible?: boolean;\n\tcommand?: Command;\n\tlocation?: Location;\n}\n\nexport interface InlayHint {\n\tlabel: string | InlayHintLabelPart[];\n\ttooltip?: string | IMarkdownString;\n\ttextEdits?: TextEdit[];\n\tposition: IPosition;\n\tkind?: InlayHintKind;\n\tpaddingLeft?: boolean;\n\tpaddingRight?: boolean;\n}\n\nexport interface InlayHintList {\n\thints: InlayHint[];\n\tdispose(): void;\n}\n\nexport interface InlayHintsProvider {\n\tdisplayName?: string;\n\tonDidChangeInlayHints?: Event<void>;\n\tprovideInlayHints(model: model.ITextModel, range: Range, token: CancellationToken): ProviderResult<InlayHintList>;\n\tresolveInlayHint?(hint: InlayHint, token: CancellationToken): ProviderResult<InlayHint>;\n}\n\nexport interface SemanticTokensLegend {\n\treadonly tokenTypes: string[];\n\treadonly tokenModifiers: string[];\n}\n\nexport interface SemanticTokens {\n\treadonly resultId?: string;\n\treadonly data: Uint32Array;\n}\n\nexport interface SemanticTokensEdit {\n\treadonly start: number;\n\treadonly deleteCount: number;\n\treadonly data?: Uint32Array;\n}\n\nexport interface SemanticTokensEdits {\n\treadonly resultId?: string;\n\treadonly edits: SemanticTokensEdit[];\n}\n\nexport interface DocumentSemanticTokensProvider {\n\tonDidChange?: Event<void>;\n\tgetLegend(): SemanticTokensLegend;\n\tprovideDocumentSemanticTokens(model: model.ITextModel, lastResultId: string | null, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;\n\treleaseDocumentSemanticTokens(resultId: string | undefined): void;\n}\n\nexport interface DocumentRangeSemanticTokensProvider {\n\tgetLegend(): SemanticTokensLegend;\n\tprovideDocumentRangeSemanticTokens(model: model.ITextModel, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;\n}\n\n/**\n * @internal\n */\nexport interface ITokenizationSupportChangedEvent {\n\tchangedLanguages: string[];\n\tchangedColorMap: boolean;\n}\n\n/**\n * @internal\n */\nexport interface ILazyTokenizationSupport<TSupport> {\n\tget tokenizationSupport(): Promise<TSupport | null>;\n}\n\n/**\n * @internal\n */\nexport class LazyTokenizationSupport<TSupport = ITokenizationSupport> implements IDisposable, ILazyTokenizationSupport<TSupport> {\n\tprivate _tokenizationSupport: Promise<TSupport & IDisposable | null> | null = null;\n\n\tconstructor(private readonly createSupport: () => Promise<TSupport & IDisposable | null>) {\n\t}\n\n\tdispose(): void {\n\t\tif (this._tokenizationSupport) {\n\t\t\tthis._tokenizationSupport.then((support) => {\n\t\t\t\tif (support) {\n\t\t\t\t\tsupport.dispose();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget tokenizationSupport(): Promise<TSupport | null> {\n\t\tif (!this._tokenizationSupport) {\n\t\t\tthis._tokenizationSupport = this.createSupport();\n\t\t}\n\t\treturn this._tokenizationSupport;\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITokenizationRegistry<TSupport> {\n\n\t/**\n\t * An event triggered when:\n\t *  - a tokenization support is registered, unregistered or changed.\n\t *  - the color map is changed.\n\t */\n\tonDidChange: Event<ITokenizationSupportChangedEvent>;\n\n\t/**\n\t * Fire a change event for a language.\n\t * This is useful for languages that embed other languages.\n\t */\n\thandleChange(languageIds: string[]): void;\n\n\t/**\n\t * Register a tokenization support.\n\t */\n\tregister(languageId: string, support: TSupport): IDisposable;\n\n\t/**\n\t * Register a tokenization support factory.\n\t */\n\tregisterFactory(languageId: string, factory: ILazyTokenizationSupport<TSupport>): IDisposable;\n\n\t/**\n\t * Get or create the tokenization support for a language.\n\t * Returns `null` if not found.\n\t */\n\tgetOrCreate(languageId: string): Promise<TSupport | null>;\n\n\t/**\n\t * Get the tokenization support for a language.\n\t * Returns `null` if not found.\n\t */\n\tget(languageId: string): TSupport | null;\n\n\t/**\n\t * Returns false if a factory is still pending.\n\t */\n\tisResolved(languageId: string): boolean;\n\n\t/**\n\t * Set the new color map that all tokens will use in their ColorId binary encoded bits for foreground and background.\n\t */\n\tsetColorMap(colorMap: Color[]): void;\n\n\tgetColorMap(): Color[] | null;\n\n\tgetDefaultBackground(): Color | null;\n}\n\n/**\n * @internal\n */\nexport const TokenizationRegistry: ITokenizationRegistry<ITokenizationSupport> = new TokenizationRegistryImpl();\n\n/**\n * @internal\n */\nexport enum ExternalUriOpenerPriority {\n\tNone = 0,\n\tOption = 1,\n\tDefault = 2,\n\tPreferred = 3,\n}\n\n/**\n * @internal\n */\nexport type DropYieldTo = { readonly kind: HierarchicalKind } | { readonly mimeType: string };\n\n/**\n * @internal\n */\nexport interface DocumentDropEdit {\n\treadonly title: string;\n\treadonly kind: HierarchicalKind | undefined;\n\treadonly handledMimeType?: string;\n\treadonly yieldTo?: readonly DropYieldTo[];\n\tinsertText: string | { readonly snippet: string };\n\tadditionalEdit?: WorkspaceEdit;\n}\n\n/**\n * @internal\n */\nexport interface DocumentDropEditsSession {\n\tedits: readonly DocumentDropEdit[];\n\tdispose(): void;\n}\n\n/**\n * @internal\n */\nexport interface DocumentDropEditProvider {\n\treadonly id?: string;\n\treadonly dropMimeTypes?: readonly string[];\n\treadonly providedDropEditKinds?: readonly HierarchicalKind[];\n\n\tprovideDocumentDropEdits(model: model.ITextModel, position: IPosition, dataTransfer: IReadonlyVSDataTransfer, token: CancellationToken): ProviderResult<DocumentDropEditsSession>;\n\tresolveDocumentDropEdit?(edit: DocumentDropEdit, token: CancellationToken): Promise<DocumentDropEdit>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\n\n\nexport enum AccessibilitySupport {\n\t/**\n\t * This should be the browser case where it is not known if a screen reader is attached or no.\n\t */\n\tUnknown = 0,\n\tDisabled = 1,\n\tEnabled = 2\n}\n\nexport enum CodeActionTriggerType {\n\tInvoke = 1,\n\tAuto = 2\n}\n\nexport enum CompletionItemInsertTextRule {\n\tNone = 0,\n\t/**\n\t * Adjust whitespace/indentation of multiline insert texts to\n\t * match the current line indentation.\n\t */\n\tKeepWhitespace = 1,\n\t/**\n\t * `insertText` is a snippet.\n\t */\n\tInsertAsSnippet = 4\n}\n\nexport enum CompletionItemKind {\n\tMethod = 0,\n\tFunction = 1,\n\tConstructor = 2,\n\tField = 3,\n\tVariable = 4,\n\tClass = 5,\n\tStruct = 6,\n\tInterface = 7,\n\tModule = 8,\n\tProperty = 9,\n\tEvent = 10,\n\tOperator = 11,\n\tUnit = 12,\n\tValue = 13,\n\tConstant = 14,\n\tEnum = 15,\n\tEnumMember = 16,\n\tKeyword = 17,\n\tText = 18,\n\tColor = 19,\n\tFile = 20,\n\tReference = 21,\n\tCustomcolor = 22,\n\tFolder = 23,\n\tTypeParameter = 24,\n\tUser = 25,\n\tIssue = 26,\n\tTool = 27,\n\tSnippet = 28\n}\n\nexport enum CompletionItemTag {\n\tDeprecated = 1\n}\n\n/**\n * How a suggest provider was triggered.\n */\nexport enum CompletionTriggerKind {\n\tInvoke = 0,\n\tTriggerCharacter = 1,\n\tTriggerForIncompleteCompletions = 2\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT = 0,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE = 1,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW = 2\n}\n\n/**\n * Describes the reason the cursor has changed its position.\n */\nexport enum CursorChangeReason {\n\t/**\n\t * Unknown or not set.\n\t */\n\tNotSet = 0,\n\t/**\n\t * A `model.setValue()` was called.\n\t */\n\tContentFlush = 1,\n\t/**\n\t * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\n\t */\n\tRecoverFromMarkers = 2,\n\t/**\n\t * There was an explicit user gesture.\n\t */\n\tExplicit = 3,\n\t/**\n\t * There was a Paste.\n\t */\n\tPaste = 4,\n\t/**\n\t * There was an Undo.\n\t */\n\tUndo = 5,\n\t/**\n\t * There was a Redo.\n\t */\n\tRedo = 6\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * A document highlight kind.\n */\nexport enum DocumentHighlightKind {\n\t/**\n\t * A textual occurrence.\n\t */\n\tText = 0,\n\t/**\n\t * Read-access of a symbol, like reading a variable.\n\t */\n\tRead = 1,\n\t/**\n\t * Write-access of a symbol, like writing to a variable.\n\t */\n\tWrite = 2\n}\n\n/**\n * Configuration options for auto indentation in the editor\n */\nexport enum EditorAutoIndentStrategy {\n\tNone = 0,\n\tKeep = 1,\n\tBrackets = 2,\n\tAdvanced = 3,\n\tFull = 4\n}\n\nexport enum EditorOption {\n\tacceptSuggestionOnCommitCharacter = 0,\n\tacceptSuggestionOnEnter = 1,\n\taccessibilitySupport = 2,\n\taccessibilityPageSize = 3,\n\tallowOverflow = 4,\n\tallowVariableLineHeights = 5,\n\tallowVariableFonts = 6,\n\tallowVariableFontsInAccessibilityMode = 7,\n\tariaLabel = 8,\n\tariaRequired = 9,\n\tautoClosingBrackets = 10,\n\tautoClosingComments = 11,\n\tscreenReaderAnnounceInlineSuggestion = 12,\n\tautoClosingDelete = 13,\n\tautoClosingOvertype = 14,\n\tautoClosingQuotes = 15,\n\tautoIndent = 16,\n\tautoIndentOnPaste = 17,\n\tautoIndentOnPasteWithinString = 18,\n\tautomaticLayout = 19,\n\tautoSurround = 20,\n\tbracketPairColorization = 21,\n\tguides = 22,\n\tcodeLens = 23,\n\tcodeLensFontFamily = 24,\n\tcodeLensFontSize = 25,\n\tcolorDecorators = 26,\n\tcolorDecoratorsLimit = 27,\n\tcolumnSelection = 28,\n\tcomments = 29,\n\tcontextmenu = 30,\n\tcopyWithSyntaxHighlighting = 31,\n\tcursorBlinking = 32,\n\tcursorSmoothCaretAnimation = 33,\n\tcursorStyle = 34,\n\tcursorSurroundingLines = 35,\n\tcursorSurroundingLinesStyle = 36,\n\tcursorWidth = 37,\n\tcursorHeight = 38,\n\tdisableLayerHinting = 39,\n\tdisableMonospaceOptimizations = 40,\n\tdomReadOnly = 41,\n\tdragAndDrop = 42,\n\tdropIntoEditor = 43,\n\teditContext = 44,\n\temptySelectionClipboard = 45,\n\texperimentalGpuAcceleration = 46,\n\texperimentalWhitespaceRendering = 47,\n\textraEditorClassName = 48,\n\tfastScrollSensitivity = 49,\n\tfind = 50,\n\tfixedOverflowWidgets = 51,\n\tfolding = 52,\n\tfoldingStrategy = 53,\n\tfoldingHighlight = 54,\n\tfoldingImportsByDefault = 55,\n\tfoldingMaximumRegions = 56,\n\tunfoldOnClickAfterEndOfLine = 57,\n\tfontFamily = 58,\n\tfontInfo = 59,\n\tfontLigatures = 60,\n\tfontSize = 61,\n\tfontWeight = 62,\n\tfontVariations = 63,\n\tformatOnPaste = 64,\n\tformatOnType = 65,\n\tglyphMargin = 66,\n\tgotoLocation = 67,\n\thideCursorInOverviewRuler = 68,\n\thover = 69,\n\tinDiffEditor = 70,\n\tinlineSuggest = 71,\n\tletterSpacing = 72,\n\tlightbulb = 73,\n\tlineDecorationsWidth = 74,\n\tlineHeight = 75,\n\tlineNumbers = 76,\n\tlineNumbersMinChars = 77,\n\tlinkedEditing = 78,\n\tlinks = 79,\n\tmatchBrackets = 80,\n\tminimap = 81,\n\tmouseStyle = 82,\n\tmouseWheelScrollSensitivity = 83,\n\tmouseWheelZoom = 84,\n\tmultiCursorMergeOverlapping = 85,\n\tmultiCursorModifier = 86,\n\tmouseMiddleClickAction = 87,\n\tmultiCursorPaste = 88,\n\tmultiCursorLimit = 89,\n\toccurrencesHighlight = 90,\n\toccurrencesHighlightDelay = 91,\n\tovertypeCursorStyle = 92,\n\tovertypeOnPaste = 93,\n\toverviewRulerBorder = 94,\n\toverviewRulerLanes = 95,\n\tpadding = 96,\n\tpasteAs = 97,\n\tparameterHints = 98,\n\tpeekWidgetDefaultFocus = 99,\n\tplaceholder = 100,\n\tdefinitionLinkOpensInPeek = 101,\n\tquickSuggestions = 102,\n\tquickSuggestionsDelay = 103,\n\treadOnly = 104,\n\treadOnlyMessage = 105,\n\trenameOnType = 106,\n\trenderRichScreenReaderContent = 107,\n\trenderControlCharacters = 108,\n\trenderFinalNewline = 109,\n\trenderLineHighlight = 110,\n\trenderLineHighlightOnlyWhenFocus = 111,\n\trenderValidationDecorations = 112,\n\trenderWhitespace = 113,\n\trevealHorizontalRightPadding = 114,\n\troundedSelection = 115,\n\trulers = 116,\n\tscrollbar = 117,\n\tscrollBeyondLastColumn = 118,\n\tscrollBeyondLastLine = 119,\n\tscrollPredominantAxis = 120,\n\tselectionClipboard = 121,\n\tselectionHighlight = 122,\n\tselectionHighlightMaxLength = 123,\n\tselectionHighlightMultiline = 124,\n\tselectOnLineNumbers = 125,\n\tshowFoldingControls = 126,\n\tshowUnused = 127,\n\tsnippetSuggestions = 128,\n\tsmartSelect = 129,\n\tsmoothScrolling = 130,\n\tstickyScroll = 131,\n\tstickyTabStops = 132,\n\tstopRenderingLineAfter = 133,\n\tsuggest = 134,\n\tsuggestFontSize = 135,\n\tsuggestLineHeight = 136,\n\tsuggestOnTriggerCharacters = 137,\n\tsuggestSelection = 138,\n\ttabCompletion = 139,\n\ttabIndex = 140,\n\ttrimWhitespaceOnDelete = 141,\n\tunicodeHighlighting = 142,\n\tunusualLineTerminators = 143,\n\tuseShadowDOM = 144,\n\tuseTabStops = 145,\n\twordBreak = 146,\n\twordSegmenterLocales = 147,\n\twordSeparators = 148,\n\twordWrap = 149,\n\twordWrapBreakAfterCharacters = 150,\n\twordWrapBreakBeforeCharacters = 151,\n\twordWrapColumn = 152,\n\twordWrapOverride1 = 153,\n\twordWrapOverride2 = 154,\n\twrappingIndent = 155,\n\twrappingStrategy = 156,\n\tshowDeprecated = 157,\n\tinertialScroll = 158,\n\tinlayHints = 159,\n\twrapOnEscapedLineFeeds = 160,\n\teffectiveCursorStyle = 161,\n\teditorClassName = 162,\n\tpixelRatio = 163,\n\ttabFocusMode = 164,\n\tlayoutInfo = 165,\n\twrappingInfo = 166,\n\tdefaultColorDecorators = 167,\n\tcolorDecoratorsActivatedOn = 168,\n\tinlineCompletionsAccessibilityVerbose = 169,\n\teffectiveEditContext = 170,\n\tscrollOnMiddleClick = 171,\n\teffectiveAllowVariableFonts = 172\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3\n}\n\nexport enum HoverVerbosityAction {\n\t/**\n\t * Increase the verbosity of the hover\n\t */\n\tIncrease = 0,\n\t/**\n\t * Decrease the verbosity of the hover\n\t */\n\tDecrease = 1\n}\n\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport enum IndentAction {\n\t/**\n\t * Insert new line and copy the previous line's indentation.\n\t */\n\tNone = 0,\n\t/**\n\t * Insert new line and indent once (relative to the previous line's indentation).\n\t */\n\tIndent = 1,\n\t/**\n\t * Insert two new lines:\n\t *  - the first one indented which will hold the cursor\n\t *  - the second one at the same indentation level\n\t */\n\tIndentOutdent = 2,\n\t/**\n\t * Insert new line and outdent once (relative to the previous line's indentation).\n\t */\n\tOutdent = 3\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth = 0,\n\tRight = 1,\n\tLeft = 2,\n\tNone = 3\n}\n\nexport enum InlayHintKind {\n\tType = 1,\n\tParameter = 2\n}\n\nexport enum InlineCompletionDisplayLocationKind {\n\tCode = 1,\n\tLabel = 2\n}\n\nexport enum InlineCompletionEndOfLifeReasonKind {\n\tAccepted = 0,\n\tRejected = 1,\n\tIgnored = 2\n}\n\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport enum InlineCompletionTriggerKind {\n\t/**\n\t * Completion was triggered automatically while editing.\n\t * It is sufficient to return a single completion item in this case.\n\t */\n\tAutomatic = 0,\n\t/**\n\t * Completion was triggered explicitly by a user gesture.\n\t * Return multiple completion items to enable cycling through them.\n\t */\n\tExplicit = 1\n}\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport enum KeyCode {\n\tDependsOnKbLayout = -1,\n\t/**\n\t * Placed first to cover the 0 value of the enum.\n\t */\n\tUnknown = 0,\n\tBackspace = 1,\n\tTab = 2,\n\tEnter = 3,\n\tShift = 4,\n\tCtrl = 5,\n\tAlt = 6,\n\tPauseBreak = 7,\n\tCapsLock = 8,\n\tEscape = 9,\n\tSpace = 10,\n\tPageUp = 11,\n\tPageDown = 12,\n\tEnd = 13,\n\tHome = 14,\n\tLeftArrow = 15,\n\tUpArrow = 16,\n\tRightArrow = 17,\n\tDownArrow = 18,\n\tInsert = 19,\n\tDelete = 20,\n\tDigit0 = 21,\n\tDigit1 = 22,\n\tDigit2 = 23,\n\tDigit3 = 24,\n\tDigit4 = 25,\n\tDigit5 = 26,\n\tDigit6 = 27,\n\tDigit7 = 28,\n\tDigit8 = 29,\n\tDigit9 = 30,\n\tKeyA = 31,\n\tKeyB = 32,\n\tKeyC = 33,\n\tKeyD = 34,\n\tKeyE = 35,\n\tKeyF = 36,\n\tKeyG = 37,\n\tKeyH = 38,\n\tKeyI = 39,\n\tKeyJ = 40,\n\tKeyK = 41,\n\tKeyL = 42,\n\tKeyM = 43,\n\tKeyN = 44,\n\tKeyO = 45,\n\tKeyP = 46,\n\tKeyQ = 47,\n\tKeyR = 48,\n\tKeyS = 49,\n\tKeyT = 50,\n\tKeyU = 51,\n\tKeyV = 52,\n\tKeyW = 53,\n\tKeyX = 54,\n\tKeyY = 55,\n\tKeyZ = 56,\n\tMeta = 57,\n\tContextMenu = 58,\n\tF1 = 59,\n\tF2 = 60,\n\tF3 = 61,\n\tF4 = 62,\n\tF5 = 63,\n\tF6 = 64,\n\tF7 = 65,\n\tF8 = 66,\n\tF9 = 67,\n\tF10 = 68,\n\tF11 = 69,\n\tF12 = 70,\n\tF13 = 71,\n\tF14 = 72,\n\tF15 = 73,\n\tF16 = 74,\n\tF17 = 75,\n\tF18 = 76,\n\tF19 = 77,\n\tF20 = 78,\n\tF21 = 79,\n\tF22 = 80,\n\tF23 = 81,\n\tF24 = 82,\n\tNumLock = 83,\n\tScrollLock = 84,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ';:' key\n\t */\n\tSemicolon = 85,\n\t/**\n\t * For any country/region, the '+' key\n\t * For the US standard keyboard, the '=+' key\n\t */\n\tEqual = 86,\n\t/**\n\t * For any country/region, the ',' key\n\t * For the US standard keyboard, the ',<' key\n\t */\n\tComma = 87,\n\t/**\n\t * For any country/region, the '-' key\n\t * For the US standard keyboard, the '-_' key\n\t */\n\tMinus = 88,\n\t/**\n\t * For any country/region, the '.' key\n\t * For the US standard keyboard, the '.>' key\n\t */\n\tPeriod = 89,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '/?' key\n\t */\n\tSlash = 90,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '`~' key\n\t */\n\tBackquote = 91,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '[{' key\n\t */\n\tBracketLeft = 92,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '\\|' key\n\t */\n\tBackslash = 93,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ']}' key\n\t */\n\tBracketRight = 94,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ''\"' key\n\t */\n\tQuote = 95,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t */\n\tOEM_8 = 96,\n\t/**\n\t * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n\t */\n\tIntlBackslash = 97,\n\tNumpad0 = 98,// VK_NUMPAD0, 0x60, Numeric keypad 0 key\n\tNumpad1 = 99,// VK_NUMPAD1, 0x61, Numeric keypad 1 key\n\tNumpad2 = 100,// VK_NUMPAD2, 0x62, Numeric keypad 2 key\n\tNumpad3 = 101,// VK_NUMPAD3, 0x63, Numeric keypad 3 key\n\tNumpad4 = 102,// VK_NUMPAD4, 0x64, Numeric keypad 4 key\n\tNumpad5 = 103,// VK_NUMPAD5, 0x65, Numeric keypad 5 key\n\tNumpad6 = 104,// VK_NUMPAD6, 0x66, Numeric keypad 6 key\n\tNumpad7 = 105,// VK_NUMPAD7, 0x67, Numeric keypad 7 key\n\tNumpad8 = 106,// VK_NUMPAD8, 0x68, Numeric keypad 8 key\n\tNumpad9 = 107,// VK_NUMPAD9, 0x69, Numeric keypad 9 key\n\tNumpadMultiply = 108,// VK_MULTIPLY, 0x6A, Multiply key\n\tNumpadAdd = 109,// VK_ADD, 0x6B, Add key\n\tNUMPAD_SEPARATOR = 110,// VK_SEPARATOR, 0x6C, Separator key\n\tNumpadSubtract = 111,// VK_SUBTRACT, 0x6D, Subtract key\n\tNumpadDecimal = 112,// VK_DECIMAL, 0x6E, Decimal key\n\tNumpadDivide = 113,// VK_DIVIDE, 0x6F,\n\t/**\n\t * Cover all key codes when IME is processing input.\n\t */\n\tKEY_IN_COMPOSITION = 114,\n\tABNT_C1 = 115,// Brazilian (ABNT) Keyboard\n\tABNT_C2 = 116,// Brazilian (ABNT) Keyboard\n\tAudioVolumeMute = 117,\n\tAudioVolumeUp = 118,\n\tAudioVolumeDown = 119,\n\tBrowserSearch = 120,\n\tBrowserHome = 121,\n\tBrowserBack = 122,\n\tBrowserForward = 123,\n\tMediaTrackNext = 124,\n\tMediaTrackPrevious = 125,\n\tMediaStop = 126,\n\tMediaPlayPause = 127,\n\tLaunchMediaPlayer = 128,\n\tLaunchMail = 129,\n\tLaunchApp2 = 130,\n\t/**\n\t * VK_CLEAR, 0x0C, CLEAR key\n\t */\n\tClear = 131,\n\t/**\n\t * Placed last to cover the length of the enum.\n\t * Please do not depend on this value!\n\t */\n\tMAX_VALUE = 132\n}\n\nexport enum MarkerSeverity {\n\tHint = 1,\n\tInfo = 2,\n\tWarning = 4,\n\tError = 8\n}\n\nexport enum MarkerTag {\n\tUnnecessary = 1,\n\tDeprecated = 2\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN = 0,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA = 1,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN = 2,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS = 3,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS = 4,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE = 5,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT = 6,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY = 7,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE = 8,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET = 9,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER = 10,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR = 11,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET = 12,\n\t/**\n\t * Mouse is outside of the editor.\n\t */\n\tOUTSIDE_EDITOR = 13\n}\n\nexport enum NewSymbolNameTag {\n\tAIGenerated = 1\n}\n\nexport enum NewSymbolNameTriggerKind {\n\tInvoke = 0,\n\tAutomatic = 1\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER = 0,\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER = 1,\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER = 2\n}\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * How a partial acceptance was triggered.\n */\nexport enum PartialAcceptTriggerKind {\n\tWord = 0,\n\tLine = 1,\n\tSuggest = 2\n}\n\nexport enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4\n}\n\nexport enum RenderLineNumbersType {\n\tOff = 0,\n\tOn = 1,\n\tRelative = 2,\n\tInterval = 3,\n\tCustom = 4\n}\n\nexport enum RenderMinimap {\n\tNone = 0,\n\tText = 1,\n\tBlocks = 2\n}\n\nexport enum ScrollType {\n\tSmooth = 0,\n\tImmediate = 1\n}\n\nexport enum ScrollbarVisibility {\n\tAuto = 1,\n\tHidden = 2,\n\tVisible = 3\n}\n\n/**\n * The direction of a selection.\n */\nexport enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR = 0,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL = 1\n}\n\nexport enum ShowLightbulbIconMode {\n\tOff = 'off',\n\tOnCode = 'onCode',\n\tOn = 'on'\n}\n\nexport enum SignatureHelpTriggerKind {\n\tInvoke = 1,\n\tTriggerCharacter = 2,\n\tContentChange = 3\n}\n\n/**\n * A symbol kind.\n */\nexport enum SymbolKind {\n\tFile = 0,\n\tModule = 1,\n\tNamespace = 2,\n\tPackage = 3,\n\tClass = 4,\n\tMethod = 5,\n\tProperty = 6,\n\tField = 7,\n\tConstructor = 8,\n\tEnum = 9,\n\tInterface = 10,\n\tFunction = 11,\n\tVariable = 12,\n\tConstant = 13,\n\tString = 14,\n\tNumber = 15,\n\tBoolean = 16,\n\tArray = 17,\n\tObject = 18,\n\tKey = 19,\n\tNull = 20,\n\tEnumMember = 21,\n\tStruct = 22,\n\tEvent = 23,\n\tOperator = 24,\n\tTypeParameter = 25\n}\n\nexport enum SymbolTag {\n\tDeprecated = 1\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\tRTL = 1\n}\n\n/**\n * The kind of animation in which the editor's cursor should be rendered.\n */\nexport enum TextEditorCursorBlinkingStyle {\n\t/**\n\t * Hidden\n\t */\n\tHidden = 0,\n\t/**\n\t * Blinking\n\t */\n\tBlink = 1,\n\t/**\n\t * Blinking with smooth fading\n\t */\n\tSmooth = 2,\n\t/**\n\t * Blinking with prolonged filled state and smooth fading\n\t */\n\tPhase = 3,\n\t/**\n\t * Expand collapse animation on the y axis\n\t */\n\tExpand = 4,\n\t/**\n\t * No-Blinking\n\t */\n\tSolid = 5\n}\n\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport enum TextEditorCursorStyle {\n\t/**\n\t * As a vertical line (sitting between two characters).\n\t */\n\tLine = 1,\n\t/**\n\t * As a block (sitting on top of a character).\n\t */\n\tBlock = 2,\n\t/**\n\t * As a horizontal line (sitting under a character).\n\t */\n\tUnderline = 3,\n\t/**\n\t * As a thin vertical line (sitting between two characters).\n\t */\n\tLineThin = 4,\n\t/**\n\t * As an outlined block (sitting on top of a character).\n\t */\n\tBlockOutline = 5,\n\t/**\n\t * As a thin horizontal line (sitting under a character).\n\t */\n\tUnderlineThin = 6\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3\n}\n\n/**\n * Describes how to indent wrapped lines.\n */\nexport enum WrappingIndent {\n\t/**\n\t * No indentation => wrapped lines begin at column 1.\n\t */\n\tNone = 0,\n\t/**\n\t * Same => wrapped lines get the same indentation as the parent.\n\t */\n\tSame = 1,\n\t/**\n\t * Indent => wrapped lines get +1 indentation toward the parent.\n\t */\n\tIndent = 2,\n\t/**\n\t * DeepIndent => wrapped lines get +2 indentation toward the parent.\n\t */\n\tDeepIndent = 3\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\n\n\nexport enum AccessibilitySupport {\n\t/**\n\t * This should be the browser case where it is not known if a screen reader is attached or no.\n\t */\n\tUnknown = 0,\n\tDisabled = 1,\n\tEnabled = 2\n}\n\nexport enum CodeActionTriggerType {\n\tInvoke = 1,\n\tAuto = 2\n}\n\nexport enum CompletionItemInsertTextRule {\n\tNone = 0,\n\t/**\n\t * Adjust whitespace/indentation of multiline insert texts to\n\t * match the current line indentation.\n\t */\n\tKeepWhitespace = 1,\n\t/**\n\t * `insertText` is a snippet.\n\t */\n\tInsertAsSnippet = 4\n}\n\nexport enum CompletionItemKind {\n\tMethod = 0,\n\tFunction = 1,\n\tConstructor = 2,\n\tField = 3,\n\tVariable = 4,\n\tClass = 5,\n\tStruct = 6,\n\tInterface = 7,\n\tModule = 8,\n\tProperty = 9,\n\tEvent = 10,\n\tOperator = 11,\n\tUnit = 12,\n\tValue = 13,\n\tConstant = 14,\n\tEnum = 15,\n\tEnumMember = 16,\n\tKeyword = 17,\n\tText = 18,\n\tColor = 19,\n\tFile = 20,\n\tReference = 21,\n\tCustomcolor = 22,\n\tFolder = 23,\n\tTypeParameter = 24,\n\tUser = 25,\n\tIssue = 26,\n\tTool = 27,\n\tSnippet = 28\n}\n\nexport enum CompletionItemTag {\n\tDeprecated = 1\n}\n\n/**\n * How a suggest provider was triggered.\n */\nexport enum CompletionTriggerKind {\n\tInvoke = 0,\n\tTriggerCharacter = 1,\n\tTriggerForIncompleteCompletions = 2\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT = 0,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE = 1,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW = 2\n}\n\n/**\n * Describes the reason the cursor has changed its position.\n */\nexport enum CursorChangeReason {\n\t/**\n\t * Unknown or not set.\n\t */\n\tNotSet = 0,\n\t/**\n\t * A `model.setValue()` was called.\n\t */\n\tContentFlush = 1,\n\t/**\n\t * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\n\t */\n\tRecoverFromMarkers = 2,\n\t/**\n\t * There was an explicit user gesture.\n\t */\n\tExplicit = 3,\n\t/**\n\t * There was a Paste.\n\t */\n\tPaste = 4,\n\t/**\n\t * There was an Undo.\n\t */\n\tUndo = 5,\n\t/**\n\t * There was a Redo.\n\t */\n\tRedo = 6\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * A document highlight kind.\n */\nexport enum DocumentHighlightKind {\n\t/**\n\t * A textual occurrence.\n\t */\n\tText = 0,\n\t/**\n\t * Read-access of a symbol, like reading a variable.\n\t */\n\tRead = 1,\n\t/**\n\t * Write-access of a symbol, like writing to a variable.\n\t */\n\tWrite = 2\n}\n\n/**\n * Configuration options for auto indentation in the editor\n */\nexport enum EditorAutoIndentStrategy {\n\tNone = 0,\n\tKeep = 1,\n\tBrackets = 2,\n\tAdvanced = 3,\n\tFull = 4\n}\n\nexport enum EditorOption {\n\tacceptSuggestionOnCommitCharacter = 0,\n\tacceptSuggestionOnEnter = 1,\n\taccessibilitySupport = 2,\n\taccessibilityPageSize = 3,\n\tallowOverflow = 4,\n\tallowVariableLineHeights = 5,\n\tallowVariableFonts = 6,\n\tallowVariableFontsInAccessibilityMode = 7,\n\tariaLabel = 8,\n\tariaRequired = 9,\n\tautoClosingBrackets = 10,\n\tautoClosingComments = 11,\n\tscreenReaderAnnounceInlineSuggestion = 12,\n\tautoClosingDelete = 13,\n\tautoClosingOvertype = 14,\n\tautoClosingQuotes = 15,\n\tautoIndent = 16,\n\tautoIndentOnPaste = 17,\n\tautoIndentOnPasteWithinString = 18,\n\tautomaticLayout = 19,\n\tautoSurround = 20,\n\tbracketPairColorization = 21,\n\tguides = 22,\n\tcodeLens = 23,\n\tcodeLensFontFamily = 24,\n\tcodeLensFontSize = 25,\n\tcolorDecorators = 26,\n\tcolorDecoratorsLimit = 27,\n\tcolumnSelection = 28,\n\tcomments = 29,\n\tcontextmenu = 30,\n\tcopyWithSyntaxHighlighting = 31,\n\tcursorBlinking = 32,\n\tcursorSmoothCaretAnimation = 33,\n\tcursorStyle = 34,\n\tcursorSurroundingLines = 35,\n\tcursorSurroundingLinesStyle = 36,\n\tcursorWidth = 37,\n\tcursorHeight = 38,\n\tdisableLayerHinting = 39,\n\tdisableMonospaceOptimizations = 40,\n\tdomReadOnly = 41,\n\tdragAndDrop = 42,\n\tdropIntoEditor = 43,\n\teditContext = 44,\n\temptySelectionClipboard = 45,\n\texperimentalGpuAcceleration = 46,\n\texperimentalWhitespaceRendering = 47,\n\textraEditorClassName = 48,\n\tfastScrollSensitivity = 49,\n\tfind = 50,\n\tfixedOverflowWidgets = 51,\n\tfolding = 52,\n\tfoldingStrategy = 53,\n\tfoldingHighlight = 54,\n\tfoldingImportsByDefault = 55,\n\tfoldingMaximumRegions = 56,\n\tunfoldOnClickAfterEndOfLine = 57,\n\tfontFamily = 58,\n\tfontInfo = 59,\n\tfontLigatures = 60,\n\tfontSize = 61,\n\tfontWeight = 62,\n\tfontVariations = 63,\n\tformatOnPaste = 64,\n\tformatOnType = 65,\n\tglyphMargin = 66,\n\tgotoLocation = 67,\n\thideCursorInOverviewRuler = 68,\n\thover = 69,\n\tinDiffEditor = 70,\n\tinlineSuggest = 71,\n\tletterSpacing = 72,\n\tlightbulb = 73,\n\tlineDecorationsWidth = 74,\n\tlineHeight = 75,\n\tlineNumbers = 76,\n\tlineNumbersMinChars = 77,\n\tlinkedEditing = 78,\n\tlinks = 79,\n\tmatchBrackets = 80,\n\tminimap = 81,\n\tmouseStyle = 82,\n\tmouseWheelScrollSensitivity = 83,\n\tmouseWheelZoom = 84,\n\tmultiCursorMergeOverlapping = 85,\n\tmultiCursorModifier = 86,\n\tmouseMiddleClickAction = 87,\n\tmultiCursorPaste = 88,\n\tmultiCursorLimit = 89,\n\toccurrencesHighlight = 90,\n\toccurrencesHighlightDelay = 91,\n\tovertypeCursorStyle = 92,\n\tovertypeOnPaste = 93,\n\toverviewRulerBorder = 94,\n\toverviewRulerLanes = 95,\n\tpadding = 96,\n\tpasteAs = 97,\n\tparameterHints = 98,\n\tpeekWidgetDefaultFocus = 99,\n\tplaceholder = 100,\n\tdefinitionLinkOpensInPeek = 101,\n\tquickSuggestions = 102,\n\tquickSuggestionsDelay = 103,\n\treadOnly = 104,\n\treadOnlyMessage = 105,\n\trenameOnType = 106,\n\trenderRichScreenReaderContent = 107,\n\trenderControlCharacters = 108,\n\trenderFinalNewline = 109,\n\trenderLineHighlight = 110,\n\trenderLineHighlightOnlyWhenFocus = 111,\n\trenderValidationDecorations = 112,\n\trenderWhitespace = 113,\n\trevealHorizontalRightPadding = 114,\n\troundedSelection = 115,\n\trulers = 116,\n\tscrollbar = 117,\n\tscrollBeyondLastColumn = 118,\n\tscrollBeyondLastLine = 119,\n\tscrollPredominantAxis = 120,\n\tselectionClipboard = 121,\n\tselectionHighlight = 122,\n\tselectionHighlightMaxLength = 123,\n\tselectionHighlightMultiline = 124,\n\tselectOnLineNumbers = 125,\n\tshowFoldingControls = 126,\n\tshowUnused = 127,\n\tsnippetSuggestions = 128,\n\tsmartSelect = 129,\n\tsmoothScrolling = 130,\n\tstickyScroll = 131,\n\tstickyTabStops = 132,\n\tstopRenderingLineAfter = 133,\n\tsuggest = 134,\n\tsuggestFontSize = 135,\n\tsuggestLineHeight = 136,\n\tsuggestOnTriggerCharacters = 137,\n\tsuggestSelection = 138,\n\ttabCompletion = 139,\n\ttabIndex = 140,\n\ttrimWhitespaceOnDelete = 141,\n\tunicodeHighlighting = 142,\n\tunusualLineTerminators = 143,\n\tuseShadowDOM = 144,\n\tuseTabStops = 145,\n\twordBreak = 146,\n\twordSegmenterLocales = 147,\n\twordSeparators = 148,\n\twordWrap = 149,\n\twordWrapBreakAfterCharacters = 150,\n\twordWrapBreakBeforeCharacters = 151,\n\twordWrapColumn = 152,\n\twordWrapOverride1 = 153,\n\twordWrapOverride2 = 154,\n\twrappingIndent = 155,\n\twrappingStrategy = 156,\n\tshowDeprecated = 157,\n\tinertialScroll = 158,\n\tinlayHints = 159,\n\twrapOnEscapedLineFeeds = 160,\n\teffectiveCursorStyle = 161,\n\teditorClassName = 162,\n\tpixelRatio = 163,\n\ttabFocusMode = 164,\n\tlayoutInfo = 165,\n\twrappingInfo = 166,\n\tdefaultColorDecorators = 167,\n\tcolorDecoratorsActivatedOn = 168,\n\tinlineCompletionsAccessibilityVerbose = 169,\n\teffectiveEditContext = 170,\n\tscrollOnMiddleClick = 171,\n\teffectiveAllowVariableFonts = 172\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3\n}\n\nexport enum HoverVerbosityAction {\n\t/**\n\t * Increase the verbosity of the hover\n\t */\n\tIncrease = 0,\n\t/**\n\t * Decrease the verbosity of the hover\n\t */\n\tDecrease = 1\n}\n\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport enum IndentAction {\n\t/**\n\t * Insert new line and copy the previous line's indentation.\n\t */\n\tNone = 0,\n\t/**\n\t * Insert new line and indent once (relative to the previous line's indentation).\n\t */\n\tIndent = 1,\n\t/**\n\t * Insert two new lines:\n\t *  - the first one indented which will hold the cursor\n\t *  - the second one at the same indentation level\n\t */\n\tIndentOutdent = 2,\n\t/**\n\t * Insert new line and outdent once (relative to the previous line's indentation).\n\t */\n\tOutdent = 3\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth = 0,\n\tRight = 1,\n\tLeft = 2,\n\tNone = 3\n}\n\nexport enum InlayHintKind {\n\tType = 1,\n\tParameter = 2\n}\n\nexport enum InlineCompletionDisplayLocationKind {\n\tCode = 1,\n\tLabel = 2\n}\n\nexport enum InlineCompletionEndOfLifeReasonKind {\n\tAccepted = 0,\n\tRejected = 1,\n\tIgnored = 2\n}\n\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport enum InlineCompletionTriggerKind {\n\t/**\n\t * Completion was triggered automatically while editing.\n\t * It is sufficient to return a single completion item in this case.\n\t */\n\tAutomatic = 0,\n\t/**\n\t * Completion was triggered explicitly by a user gesture.\n\t * Return multiple completion items to enable cycling through them.\n\t */\n\tExplicit = 1\n}\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport enum KeyCode {\n\tDependsOnKbLayout = -1,\n\t/**\n\t * Placed first to cover the 0 value of the enum.\n\t */\n\tUnknown = 0,\n\tBackspace = 1,\n\tTab = 2,\n\tEnter = 3,\n\tShift = 4,\n\tCtrl = 5,\n\tAlt = 6,\n\tPauseBreak = 7,\n\tCapsLock = 8,\n\tEscape = 9,\n\tSpace = 10,\n\tPageUp = 11,\n\tPageDown = 12,\n\tEnd = 13,\n\tHome = 14,\n\tLeftArrow = 15,\n\tUpArrow = 16,\n\tRightArrow = 17,\n\tDownArrow = 18,\n\tInsert = 19,\n\tDelete = 20,\n\tDigit0 = 21,\n\tDigit1 = 22,\n\tDigit2 = 23,\n\tDigit3 = 24,\n\tDigit4 = 25,\n\tDigit5 = 26,\n\tDigit6 = 27,\n\tDigit7 = 28,\n\tDigit8 = 29,\n\tDigit9 = 30,\n\tKeyA = 31,\n\tKeyB = 32,\n\tKeyC = 33,\n\tKeyD = 34,\n\tKeyE = 35,\n\tKeyF = 36,\n\tKeyG = 37,\n\tKeyH = 38,\n\tKeyI = 39,\n\tKeyJ = 40,\n\tKeyK = 41,\n\tKeyL = 42,\n\tKeyM = 43,\n\tKeyN = 44,\n\tKeyO = 45,\n\tKeyP = 46,\n\tKeyQ = 47,\n\tKeyR = 48,\n\tKeyS = 49,\n\tKeyT = 50,\n\tKeyU = 51,\n\tKeyV = 52,\n\tKeyW = 53,\n\tKeyX = 54,\n\tKeyY = 55,\n\tKeyZ = 56,\n\tMeta = 57,\n\tContextMenu = 58,\n\tF1 = 59,\n\tF2 = 60,\n\tF3 = 61,\n\tF4 = 62,\n\tF5 = 63,\n\tF6 = 64,\n\tF7 = 65,\n\tF8 = 66,\n\tF9 = 67,\n\tF10 = 68,\n\tF11 = 69,\n\tF12 = 70,\n\tF13 = 71,\n\tF14 = 72,\n\tF15 = 73,\n\tF16 = 74,\n\tF17 = 75,\n\tF18 = 76,\n\tF19 = 77,\n\tF20 = 78,\n\tF21 = 79,\n\tF22 = 80,\n\tF23 = 81,\n\tF24 = 82,\n\tNumLock = 83,\n\tScrollLock = 84,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ';:' key\n\t */\n\tSemicolon = 85,\n\t/**\n\t * For any country/region, the '+' key\n\t * For the US standard keyboard, the '=+' key\n\t */\n\tEqual = 86,\n\t/**\n\t * For any country/region, the ',' key\n\t * For the US standard keyboard, the ',<' key\n\t */\n\tComma = 87,\n\t/**\n\t * For any country/region, the '-' key\n\t * For the US standard keyboard, the '-_' key\n\t */\n\tMinus = 88,\n\t/**\n\t * For any country/region, the '.' key\n\t * For the US standard keyboard, the '.>' key\n\t */\n\tPeriod = 89,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '/?' key\n\t */\n\tSlash = 90,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '`~' key\n\t */\n\tBackquote = 91,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '[{' key\n\t */\n\tBracketLeft = 92,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '\\|' key\n\t */\n\tBackslash = 93,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ']}' key\n\t */\n\tBracketRight = 94,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ''\"' key\n\t */\n\tQuote = 95,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t */\n\tOEM_8 = 96,\n\t/**\n\t * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n\t */\n\tIntlBackslash = 97,\n\tNumpad0 = 98,// VK_NUMPAD0, 0x60, Numeric keypad 0 key\n\tNumpad1 = 99,// VK_NUMPAD1, 0x61, Numeric keypad 1 key\n\tNumpad2 = 100,// VK_NUMPAD2, 0x62, Numeric keypad 2 key\n\tNumpad3 = 101,// VK_NUMPAD3, 0x63, Numeric keypad 3 key\n\tNumpad4 = 102,// VK_NUMPAD4, 0x64, Numeric keypad 4 key\n\tNumpad5 = 103,// VK_NUMPAD5, 0x65, Numeric keypad 5 key\n\tNumpad6 = 104,// VK_NUMPAD6, 0x66, Numeric keypad 6 key\n\tNumpad7 = 105,// VK_NUMPAD7, 0x67, Numeric keypad 7 key\n\tNumpad8 = 106,// VK_NUMPAD8, 0x68, Numeric keypad 8 key\n\tNumpad9 = 107,// VK_NUMPAD9, 0x69, Numeric keypad 9 key\n\tNumpadMultiply = 108,// VK_MULTIPLY, 0x6A, Multiply key\n\tNumpadAdd = 109,// VK_ADD, 0x6B, Add key\n\tNUMPAD_SEPARATOR = 110,// VK_SEPARATOR, 0x6C, Separator key\n\tNumpadSubtract = 111,// VK_SUBTRACT, 0x6D, Subtract key\n\tNumpadDecimal = 112,// VK_DECIMAL, 0x6E, Decimal key\n\tNumpadDivide = 113,// VK_DIVIDE, 0x6F,\n\t/**\n\t * Cover all key codes when IME is processing input.\n\t */\n\tKEY_IN_COMPOSITION = 114,\n\tABNT_C1 = 115,// Brazilian (ABNT) Keyboard\n\tABNT_C2 = 116,// Brazilian (ABNT) Keyboard\n\tAudioVolumeMute = 117,\n\tAudioVolumeUp = 118,\n\tAudioVolumeDown = 119,\n\tBrowserSearch = 120,\n\tBrowserHome = 121,\n\tBrowserBack = 122,\n\tBrowserForward = 123,\n\tMediaTrackNext = 124,\n\tMediaTrackPrevious = 125,\n\tMediaStop = 126,\n\tMediaPlayPause = 127,\n\tLaunchMediaPlayer = 128,\n\tLaunchMail = 129,\n\tLaunchApp2 = 130,\n\t/**\n\t * VK_CLEAR, 0x0C, CLEAR key\n\t */\n\tClear = 131,\n\t/**\n\t * Placed last to cover the length of the enum.\n\t * Please do not depend on this value!\n\t */\n\tMAX_VALUE = 132\n}\n\nexport enum MarkerSeverity {\n\tHint = 1,\n\tInfo = 2,\n\tWarning = 4,\n\tError = 8\n}\n\nexport enum MarkerTag {\n\tUnnecessary = 1,\n\tDeprecated = 2\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN = 0,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA = 1,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN = 2,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS = 3,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS = 4,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE = 5,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT = 6,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY = 7,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE = 8,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET = 9,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER = 10,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR = 11,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET = 12,\n\t/**\n\t * Mouse is outside of the editor.\n\t */\n\tOUTSIDE_EDITOR = 13\n}\n\nexport enum NewSymbolNameTag {\n\tAIGenerated = 1\n}\n\nexport enum NewSymbolNameTriggerKind {\n\tInvoke = 0,\n\tAutomatic = 1\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER = 0,\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER = 1,\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER = 2\n}\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * How a partial acceptance was triggered.\n */\nexport enum PartialAcceptTriggerKind {\n\tWord = 0,\n\tLine = 1,\n\tSuggest = 2\n}\n\nexport enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4\n}\n\nexport enum RenderLineNumbersType {\n\tOff = 0,\n\tOn = 1,\n\tRelative = 2,\n\tInterval = 3,\n\tCustom = 4\n}\n\nexport enum RenderMinimap {\n\tNone = 0,\n\tText = 1,\n\tBlocks = 2\n}\n\nexport enum ScrollType {\n\tSmooth = 0,\n\tImmediate = 1\n}\n\nexport enum ScrollbarVisibility {\n\tAuto = 1,\n\tHidden = 2,\n\tVisible = 3\n}\n\n/**\n * The direction of a selection.\n */\nexport enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR = 0,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL = 1\n}\n\nexport enum ShowLightbulbIconMode {\n\tOff = 'off',\n\tOnCode = 'onCode',\n\tOn = 'on'\n}\n\nexport enum SignatureHelpTriggerKind {\n\tInvoke = 1,\n\tTriggerCharacter = 2,\n\tContentChange = 3\n}\n\n/**\n * A symbol kind.\n */\nexport enum SymbolKind {\n\tFile = 0,\n\tModule = 1,\n\tNamespace = 2,\n\tPackage = 3,\n\tClass = 4,\n\tMethod = 5,\n\tProperty = 6,\n\tField = 7,\n\tConstructor = 8,\n\tEnum = 9,\n\tInterface = 10,\n\tFunction = 11,\n\tVariable = 12,\n\tConstant = 13,\n\tString = 14,\n\tNumber = 15,\n\tBoolean = 16,\n\tArray = 17,\n\tObject = 18,\n\tKey = 19,\n\tNull = 20,\n\tEnumMember = 21,\n\tStruct = 22,\n\tEvent = 23,\n\tOperator = 24,\n\tTypeParameter = 25\n}\n\nexport enum SymbolTag {\n\tDeprecated = 1\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\tRTL = 1\n}\n\n/**\n * The kind of animation in which the editor's cursor should be rendered.\n */\nexport enum TextEditorCursorBlinkingStyle {\n\t/**\n\t * Hidden\n\t */\n\tHidden = 0,\n\t/**\n\t * Blinking\n\t */\n\tBlink = 1,\n\t/**\n\t * Blinking with smooth fading\n\t */\n\tSmooth = 2,\n\t/**\n\t * Blinking with prolonged filled state and smooth fading\n\t */\n\tPhase = 3,\n\t/**\n\t * Expand collapse animation on the y axis\n\t */\n\tExpand = 4,\n\t/**\n\t * No-Blinking\n\t */\n\tSolid = 5\n}\n\n/**\n * The style in which the editor's cursor should be rendered.\n */\nexport enum TextEditorCursorStyle {\n\t/**\n\t * As a vertical line (sitting between two characters).\n\t */\n\tLine = 1,\n\t/**\n\t * As a block (sitting on top of a character).\n\t */\n\tBlock = 2,\n\t/**\n\t * As a horizontal line (sitting under a character).\n\t */\n\tUnderline = 3,\n\t/**\n\t * As a thin vertical line (sitting between two characters).\n\t */\n\tLineThin = 4,\n\t/**\n\t * As an outlined block (sitting on top of a character).\n\t */\n\tBlockOutline = 5,\n\t/**\n\t * As a thin horizontal line (sitting under a character).\n\t */\n\tUnderlineThin = 6\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3\n}\n\n/**\n * Describes how to indent wrapped lines.\n */\nexport enum WrappingIndent {\n\t/**\n\t * No indentation => wrapped lines begin at column 1.\n\t */\n\tNone = 0,\n\t/**\n\t * Same => wrapped lines get the same indentation as the parent.\n\t */\n\tSame = 1,\n\t/**\n\t * Indent => wrapped lines get +1 indentation toward the parent.\n\t */\n\tIndent = 2,\n\t/**\n\t * DeepIndent => wrapped lines get +2 indentation toward the parent.\n\t */\n\tDeepIndent = 3\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyChord, KeyMod as ConstKeyMod } from '../../../base/common/keyCodes.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Token } from '../languages.js';\nimport * as standaloneEnums from '../standalone/standaloneEnums.js';\n\nexport class KeyMod {\n\tpublic static readonly CtrlCmd: number = ConstKeyMod.CtrlCmd;\n\tpublic static readonly Shift: number = ConstKeyMod.Shift;\n\tpublic static readonly Alt: number = ConstKeyMod.Alt;\n\tpublic static readonly WinCtrl: number = ConstKeyMod.WinCtrl;\n\n\tpublic static chord(firstPart: number, secondPart: number): number {\n\t\treturn KeyChord(firstPart, secondPart);\n\t}\n}\n\nexport function createMonacoBaseAPI(): typeof monaco {\n\treturn {\n\t\teditor: undefined!, // undefined override expected here\n\t\tlanguages: undefined!, // undefined override expected here\n\t\tCancellationTokenSource: CancellationTokenSource,\n\t\tEmitter: Emitter,\n\t\tKeyCode: standaloneEnums.KeyCode,\n\t\tKeyMod: KeyMod,\n\t\tPosition: Position,\n\t\tRange: Range,\n\t\tSelection: <any>Selection,\n\t\tSelectionDirection: standaloneEnums.SelectionDirection,\n\t\tMarkerSeverity: standaloneEnums.MarkerSeverity,\n\t\tMarkerTag: standaloneEnums.MarkerTag,\n\t\tUri: <any>URI,\n\t\tToken: Token\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyChord, KeyMod as ConstKeyMod } from '../../../base/common/keyCodes.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Token } from '../languages.js';\nimport * as standaloneEnums from '../standalone/standaloneEnums.js';\n\nexport class KeyMod {\n\tpublic static readonly CtrlCmd: number = ConstKeyMod.CtrlCmd;\n\tpublic static readonly Shift: number = ConstKeyMod.Shift;\n\tpublic static readonly Alt: number = ConstKeyMod.Alt;\n\tpublic static readonly WinCtrl: number = ConstKeyMod.WinCtrl;\n\n\tpublic static chord(firstPart: number, secondPart: number): number {\n\t\treturn KeyChord(firstPart, secondPart);\n\t}\n}\n\nexport function createMonacoBaseAPI(): typeof monaco {\n\treturn {\n\t\teditor: undefined!, // undefined override expected here\n\t\tlanguages: undefined!, // undefined override expected here\n\t\tCancellationTokenSource: CancellationTokenSource,\n\t\tEmitter: Emitter,\n\t\tKeyCode: standaloneEnums.KeyCode,\n\t\tKeyMod: KeyMod,\n\t\tPosition: Position,\n\t\tRange: Range,\n\t\tSelection: <any>Selection,\n\t\tSelectionDirection: standaloneEnums.SelectionDirection,\n\t\tMarkerSeverity: standaloneEnums.MarkerSeverity,\n\t\tMarkerTag: standaloneEnums.MarkerTag,\n\t\tUri: <any>URI,\n\t\tToken: Token\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { localize } from '../../nls.js';\nimport { Lazy } from './lazy.js';\nimport { LANGUAGE_DEFAULT } from './platform.js';\n\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst month = day * 30;\nconst year = day * 365;\n\n/**\n * Create a localized difference of the time between now and the specified date.\n * @param date The date to generate the difference from.\n * @param appendAgoLabel Whether to append the \" ago\" to the end.\n * @param useFullTimeWords Whether to use full words (eg. seconds) instead of\n * shortened (eg. secs).\n * @param disallowNow Whether to disallow the string \"now\" when the difference\n * is less than 30 seconds.\n */\nexport function fromNow(date: number | Date, appendAgoLabel?: boolean, useFullTimeWords?: boolean, disallowNow?: boolean): string {\n\tif (typeof date !== 'number') {\n\t\tdate = date.getTime();\n\t}\n\n\tconst seconds = Math.round((new Date().getTime() - date) / 1000);\n\tif (seconds < -30) {\n\t\treturn localize('date.fromNow.in', 'in {0}', fromNow(new Date().getTime() + seconds * 1000, false));\n\t}\n\n\tif (!disallowNow && seconds < 30) {\n\t\treturn localize('date.fromNow.now', 'now');\n\t}\n\n\tlet value: number;\n\tif (seconds < minute) {\n\t\tvalue = seconds;\n\n\t\tif (appendAgoLabel) {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.seconds.singular.ago.fullWord', '{0} second ago', value)\n\t\t\t\t\t: localize('date.fromNow.seconds.singular.ago', '{0} sec ago', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.seconds.plural.ago.fullWord', '{0} seconds ago', value)\n\t\t\t\t\t: localize('date.fromNow.seconds.plural.ago', '{0} secs ago', value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.seconds.singular.fullWord', '{0} second', value)\n\t\t\t\t\t: localize('date.fromNow.seconds.singular', '{0} sec', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.seconds.plural.fullWord', '{0} seconds', value)\n\t\t\t\t\t: localize('date.fromNow.seconds.plural', '{0} secs', value);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (seconds < hour) {\n\t\tvalue = Math.floor(seconds / minute);\n\t\tif (appendAgoLabel) {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.minutes.singular.ago.fullWord', '{0} minute ago', value)\n\t\t\t\t\t: localize('date.fromNow.minutes.singular.ago', '{0} min ago', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.minutes.plural.ago.fullWord', '{0} minutes ago', value)\n\t\t\t\t\t: localize('date.fromNow.minutes.plural.ago', '{0} mins ago', value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.minutes.singular.fullWord', '{0} minute', value)\n\t\t\t\t\t: localize('date.fromNow.minutes.singular', '{0} min', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.minutes.plural.fullWord', '{0} minutes', value)\n\t\t\t\t\t: localize('date.fromNow.minutes.plural', '{0} mins', value);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (seconds < day) {\n\t\tvalue = Math.floor(seconds / hour);\n\t\tif (appendAgoLabel) {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.hours.singular.ago.fullWord', '{0} hour ago', value)\n\t\t\t\t\t: localize('date.fromNow.hours.singular.ago', '{0} hr ago', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.hours.plural.ago.fullWord', '{0} hours ago', value)\n\t\t\t\t\t: localize('date.fromNow.hours.plural.ago', '{0} hrs ago', value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.hours.singular.fullWord', '{0} hour', value)\n\t\t\t\t\t: localize('date.fromNow.hours.singular', '{0} hr', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.hours.plural.fullWord', '{0} hours', value)\n\t\t\t\t\t: localize('date.fromNow.hours.plural', '{0} hrs', value);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (seconds < week) {\n\t\tvalue = Math.floor(seconds / day);\n\t\tif (appendAgoLabel) {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.days.singular.ago', '{0} day ago', value)\n\t\t\t\t: localize('date.fromNow.days.plural.ago', '{0} days ago', value);\n\t\t} else {\n\t\t\treturn value === 1\n\t\t\t\t? localize('date.fromNow.days.singular', '{0} day', value)\n\t\t\t\t: localize('date.fromNow.days.plural', '{0} days', value);\n\t\t}\n\t}\n\n\tif (seconds < month) {\n\t\tvalue = Math.floor(seconds / week);\n\t\tif (appendAgoLabel) {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.weeks.singular.ago.fullWord', '{0} week ago', value)\n\t\t\t\t\t: localize('date.fromNow.weeks.singular.ago', '{0} wk ago', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.weeks.plural.ago.fullWord', '{0} weeks ago', value)\n\t\t\t\t\t: localize('date.fromNow.weeks.plural.ago', '{0} wks ago', value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.weeks.singular.fullWord', '{0} week', value)\n\t\t\t\t\t: localize('date.fromNow.weeks.singular', '{0} wk', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.weeks.plural.fullWord', '{0} weeks', value)\n\t\t\t\t\t: localize('date.fromNow.weeks.plural', '{0} wks', value);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (seconds < year) {\n\t\tvalue = Math.floor(seconds / month);\n\t\tif (appendAgoLabel) {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.months.singular.ago.fullWord', '{0} month ago', value)\n\t\t\t\t\t: localize('date.fromNow.months.singular.ago', '{0} mo ago', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.months.plural.ago.fullWord', '{0} months ago', value)\n\t\t\t\t\t: localize('date.fromNow.months.plural.ago', '{0} mos ago', value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === 1) {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.months.singular.fullWord', '{0} month', value)\n\t\t\t\t\t: localize('date.fromNow.months.singular', '{0} mo', value);\n\t\t\t} else {\n\t\t\t\treturn useFullTimeWords\n\t\t\t\t\t? localize('date.fromNow.months.plural.fullWord', '{0} months', value)\n\t\t\t\t\t: localize('date.fromNow.months.plural', '{0} mos', value);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalue = Math.floor(seconds / year);\n\tif (appendAgoLabel) {\n\t\tif (value === 1) {\n\t\t\treturn useFullTimeWords\n\t\t\t\t? localize('date.fromNow.years.singular.ago.fullWord', '{0} year ago', value)\n\t\t\t\t: localize('date.fromNow.years.singular.ago', '{0} yr ago', value);\n\t\t} else {\n\t\t\treturn useFullTimeWords\n\t\t\t\t? localize('date.fromNow.years.plural.ago.fullWord', '{0} years ago', value)\n\t\t\t\t: localize('date.fromNow.years.plural.ago', '{0} yrs ago', value);\n\t\t}\n\t} else {\n\t\tif (value === 1) {\n\t\t\treturn useFullTimeWords\n\t\t\t\t? localize('date.fromNow.years.singular.fullWord', '{0} year', value)\n\t\t\t\t: localize('date.fromNow.years.singular', '{0} yr', value);\n\t\t} else {\n\t\t\treturn useFullTimeWords\n\t\t\t\t? localize('date.fromNow.years.plural.fullWord', '{0} years', value)\n\t\t\t\t: localize('date.fromNow.years.plural', '{0} yrs', value);\n\t\t}\n\t}\n}\n\nexport function fromNowByDay(date: number | Date, appendAgoLabel?: boolean, useFullTimeWords?: boolean): string {\n\tif (typeof date !== 'number') {\n\t\tdate = date.getTime();\n\t}\n\n\tconst todayMidnightTime = new Date();\n\ttodayMidnightTime.setHours(0, 0, 0, 0);\n\tconst yesterdayMidnightTime = new Date(todayMidnightTime.getTime());\n\tyesterdayMidnightTime.setDate(yesterdayMidnightTime.getDate() - 1);\n\n\tif (date > todayMidnightTime.getTime()) {\n\t\treturn localize('today', 'Today');\n\t}\n\n\tif (date > yesterdayMidnightTime.getTime()) {\n\t\treturn localize('yesterday', 'Yesterday');\n\t}\n\n\treturn fromNow(date, appendAgoLabel, useFullTimeWords);\n}\n\n/**\n * Gets a readable duration with intelligent/lossy precision. For example \"40ms\" or \"3.040s\")\n * @param ms The duration to get in milliseconds.\n * @param useFullTimeWords Whether to use full words (eg. seconds) instead of\n * shortened (eg. secs).\n */\nexport function getDurationString(ms: number, useFullTimeWords?: boolean) {\n\tconst seconds = Math.abs(ms / 1000);\n\tif (seconds < 1) {\n\t\treturn useFullTimeWords\n\t\t\t? localize('duration.ms.full', '{0} milliseconds', ms)\n\t\t\t: localize('duration.ms', '{0}ms', ms);\n\t}\n\tif (seconds < minute) {\n\t\treturn useFullTimeWords\n\t\t\t? localize('duration.s.full', '{0} seconds', Math.round(ms) / 1000)\n\t\t\t: localize('duration.s', '{0}s', Math.round(ms) / 1000);\n\t}\n\tif (seconds < hour) {\n\t\treturn useFullTimeWords\n\t\t\t? localize('duration.m.full', '{0} minutes', Math.round(ms / (1000 * minute)))\n\t\t\t: localize('duration.m', '{0} mins', Math.round(ms / (1000 * minute)));\n\t}\n\tif (seconds < day) {\n\t\treturn useFullTimeWords\n\t\t\t? localize('duration.h.full', '{0} hours', Math.round(ms / (1000 * hour)))\n\t\t\t: localize('duration.h', '{0} hrs', Math.round(ms / (1000 * hour)));\n\t}\n\treturn localize('duration.d', '{0} days', Math.round(ms / (1000 * day)));\n}\n\nexport function toLocalISOString(date: Date): string {\n\treturn date.getFullYear() +\n\t\t'-' + String(date.getMonth() + 1).padStart(2, '0') +\n\t\t'-' + String(date.getDate()).padStart(2, '0') +\n\t\t'T' + String(date.getHours()).padStart(2, '0') +\n\t\t':' + String(date.getMinutes()).padStart(2, '0') +\n\t\t':' + String(date.getSeconds()).padStart(2, '0') +\n\t\t'.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +\n\t\t'Z';\n}\n\nexport const safeIntl = {\n\tDateTimeFormat(locales?: Intl.LocalesArgument, options?: Intl.DateTimeFormatOptions): Lazy<Intl.DateTimeFormat> {\n\t\treturn new Lazy(() => {\n\t\t\ttry {\n\t\t\t\treturn new Intl.DateTimeFormat(locales, options);\n\t\t\t} catch {\n\t\t\t\treturn new Intl.DateTimeFormat(undefined, options);\n\t\t\t}\n\t\t});\n\t},\n\tCollator(locales?: Intl.LocalesArgument, options?: Intl.CollatorOptions): Lazy<Intl.Collator> {\n\t\treturn new Lazy(() => {\n\t\t\ttry {\n\t\t\t\treturn new Intl.Collator(locales, options);\n\t\t\t} catch {\n\t\t\t\treturn new Intl.Collator(undefined, options);\n\t\t\t}\n\t\t});\n\t},\n\tSegmenter(locales?: Intl.LocalesArgument, options?: Intl.SegmenterOptions): Lazy<Intl.Segmenter> {\n\t\treturn new Lazy(() => {\n\t\t\ttry {\n\t\t\t\treturn new Intl.Segmenter(locales, options);\n\t\t\t} catch {\n\t\t\t\treturn new Intl.Segmenter(undefined, options);\n\t\t\t}\n\t\t});\n\t},\n\tLocale(tag: Intl.Locale | string, options?: Intl.LocaleOptions): Lazy<Intl.Locale> {\n\t\treturn new Lazy(() => {\n\t\t\ttry {\n\t\t\t\treturn new Intl.Locale(tag, options);\n\t\t\t} catch {\n\t\t\t\treturn new Intl.Locale(LANGUAGE_DEFAULT, options);\n\t\t\t}\n\t\t});\n\t},\n\tNumberFormat(locales?: Intl.LocalesArgument, options?: Intl.NumberFormatOptions): Lazy<Intl.NumberFormat> {\n\t\treturn new Lazy(() => {\n\t\t\ttry {\n\t\t\t\treturn new Intl.NumberFormat(locales, options);\n\t\t\t} catch {\n\t\t\t\treturn new Intl.NumberFormat(undefined, options);\n\t\t\t}\n\t\t});\n\t}\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { safeIntl } from '../../../base/common/date.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\nexport const enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Lazy<Intl.Segmenter> | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(wordSeparators.charCodeAt(i), WordCharacterClass.WordSeparator);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(line: string, offset: number): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(lineContent: string, offset: number): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(segments: Intl.Segments): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(segment: Intl.SegmentData): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { safeIntl } from '../../../base/common/date.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\nexport const enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Lazy<Intl.Segmenter> | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(wordSeparators.charCodeAt(i), WordCharacterClass.WordSeparator);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(line: string, offset: number): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(lineContent: string, offset: number): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(segments: Intl.Segments): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(segment: Intl.SegmentData): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../base/common/event.js';\nimport { IMarkdownString } from '../../base/common/htmlContent.js';\nimport { IDisposable } from '../../base/common/lifecycle.js';\nimport { equals } from '../../base/common/objects.js';\nimport { ThemeColor } from '../../base/common/themables.js';\nimport { URI } from '../../base/common/uri.js';\nimport { ISingleEditOperation } from './core/editOperation.js';\nimport { IPosition, Position } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { TextChange } from './core/textChange.js';\nimport { WordCharacterClassifier } from './core/wordCharacterClassifier.js';\nimport { IWordAtPosition } from './core/wordHelper.js';\nimport { FormattingOptions } from './languages.js';\nimport { ILanguageSelection } from './languages/language.js';\nimport { IBracketPairsTextModelPart } from './textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelFontChangedEvent, ModelInjectedTextChangedEvent, ModelLineHeightChangedEvent } from './textModelEvents.js';\nimport { IModelContentChange } from './model/mirrorTextModel.js';\nimport { IGuidesTextModelPart } from './textModelGuides.js';\nimport { ITokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { UndoRedoGroup } from '../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from './tokens/lineTokens.js';\nimport { IEditorModel } from './editorCommon.js';\nimport { TextModelEditSource } from './textModelEditSource.js';\nimport { TextEdit } from './core/edits/textEdit.js';\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3,\n}\n\nexport interface IGlyphMarginLanesModel {\n\t/**\n\t * The number of lanes that should be rendered in the editor.\n\t */\n\treadonly requiredLanes: number;\n\n\t/**\n\t * Gets the lanes that should be rendered starting at a given line number.\n\t */\n\tgetLanesAtLine(lineNumber: number): GlyphMarginLane[];\n\n\t/**\n\t * Resets the model and ensures it can contain at least `maxLine` lines.\n\t */\n\treset(maxLine: number): void;\n\n\t/**\n\t * Registers that a lane should be visible at the Range in the model.\n\t * @param persist - if true, notes that the lane should always be visible,\n\t * even on lines where there's no specific request for that lane.\n\t */\n\tpush(lane: GlyphMarginLane, range: Range, persist?: boolean): void;\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport const enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport const enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\nexport interface IDecorationOptions {\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tcolor: string | ThemeColor | undefined;\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tdarkColor?: string | ThemeColor;\n}\n\nexport interface IModelDecorationGlyphMarginOptions {\n\t/**\n\t * The position in the glyph margin.\n\t */\n\tposition: GlyphMarginLane;\n\n\t/**\n\t * Whether the glyph margin lane in {@link position} should be rendered even\n\t * outside of this decoration's range.\n\t */\n\tpersistLane?: boolean;\n}\n\n/**\n * Options for rendering a model decoration in the overview ruler.\n */\nexport interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {\n\t/**\n\t * The position in the overview ruler.\n\t */\n\tposition: OverviewRulerLane;\n}\n\n/**\n * Options for rendering a model decoration in the minimap.\n */\nexport interface IModelDecorationMinimapOptions extends IDecorationOptions {\n\t/**\n\t * The position in the minimap.\n\t */\n\tposition: MinimapPosition;\n\t/**\n\t * If the decoration is for a section header, which header style.\n\t */\n\tsectionHeaderStyle?: MinimapSectionHeaderStyle | null;\n\t/**\n\t * If the decoration is for a section header, the header text.\n\t */\n\tsectionHeaderText?: string | null;\n}\n\n/**\n * Options for a model decoration.\n */\nexport interface IModelDecorationOptions {\n\t/**\n\t * A debug description that can be used for inspecting model decorations.\n\t * @internal\n\t */\n\tdescription: string;\n\t/**\n\t * Customize the growing behavior of the decoration when typing at the edges of the decoration.\n\t * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t */\n\tstickiness?: TrackedRangeStickiness;\n\t/**\n\t * CSS class name describing the decoration.\n\t */\n\tclassName?: string | null;\n\t/**\n\t * Indicates whether the decoration should span across the entire line when it continues onto the next line.\n\t */\n\tshouldFillLineOnLineBreak?: boolean | null;\n\tblockClassName?: string | null;\n\t/**\n\t * Indicates if this block should be rendered after the last line.\n\t * In this case, the range must be empty and set to the last line.\n\t */\n\tblockIsAfterEnd?: boolean | null;\n\tblockDoesNotCollapse?: boolean | null;\n\tblockPadding?: [top: number, right: number, bottom: number, left: number] | null;\n\n\t/**\n\t * Message to be rendered when hovering over the glyph margin decoration.\n\t */\n\tglyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the decoration message.\n\t */\n\thoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the line number message.\n\t */\n\tlineNumberHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Should the decoration expand to encompass a whole line.\n\t */\n\tisWholeLine?: boolean;\n\t/**\n\t * Always render the decoration (even when the range it encompasses is collapsed).\n\t */\n\tshowIfCollapsed?: boolean;\n\t/**\n\t * Collapse the decoration if its entire range is being replaced via an edit.\n\t * @internal\n\t */\n\tcollapseOnReplaceEdit?: boolean;\n\t/**\n\t * Specifies the stack order of a decoration.\n\t * A decoration with greater stack order is always in front of a decoration with\n\t * a lower stack order when the decorations are on the same line.\n\t */\n\tzIndex?: number;\n\t/**\n\t * If set, render this decoration in the overview ruler.\n\t */\n\toverviewRuler?: IModelDecorationOverviewRulerOptions | null;\n\t/**\n\t * If set, render this decoration in the minimap.\n\t */\n\tminimap?: IModelDecorationMinimapOptions | null;\n\t/**\n\t * If set, the decoration will be rendered in the glyph margin with this CSS class name.\n\t */\n\tglyphMarginClassName?: string | null;\n\t/**\n\t * If set and the decoration has {@link glyphMarginClassName} set, render this decoration\n\t * with the specified {@link IModelDecorationGlyphMarginOptions} in the glyph margin.\n\t */\n\tglyphMargin?: IModelDecorationGlyphMarginOptions | null;\n\t/**\n\t * If set, the decoration will override the line height of the lines it spans. Maximum value is 300px.\n\t */\n\tlineHeight?: number | null;\n\t/**\n\t * Font family\n\t */\n\tfontFamily?: string | null;\n\t/**\n\t * Font size\n\t */\n\tfontSize?: string | null;\n\t/**\n\t * Font weight\n\t */\n\tfontWeight?: string | null;\n\t/**\n\t * Font style\n\t */\n\tfontStyle?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name.\n\t */\n\tlinesDecorationsClassName?: string | null;\n\t/**\n\t * Controls the tooltip text of the line decoration.\n\t */\n\tlinesDecorationsTooltip?: string | null;\n\t/**\n\t * If set, the decoration will be rendered on the line number.\n\t */\n\tlineNumberClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.\n\t */\n\tfirstLineDecorationClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.\n\t */\n\tmarginClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t * Please use this only for CSS rules that must impact the text. For example, use `className`\n\t * to have a background color decoration.\n\t */\n\tinlineClassName?: string | null;\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\tinlineClassNameAffectsLetterSpacing?: boolean;\n\t/**\n\t * If set, the decoration will be rendered before the text with this CSS class name.\n\t */\n\tbeforeContentClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered after the text with this CSS class name.\n\t */\n\tafterContentClassName?: string | null;\n\t/**\n\t * If set, text will be injected in the view after the range.\n\t */\n\tafter?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, text will be injected in the view before the range.\n\t */\n\tbefore?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for comment tokens.\n\t * @internal\n\t*/\n\thideInCommentTokens?: boolean | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for string tokens.\n\t * @internal\n\t*/\n\thideInStringTokens?: boolean | null;\n\n\t/**\n\t * Whether the decoration affects the font.\n\t * @internal\n\t */\n\taffectsFont?: boolean | null;\n\n\t/**\n\t * The text direction of the decoration.\n\t */\n\ttextDirection?: TextDirection | null;\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\n\tRTL = 1,\n}\n\n/**\n * Configures text that is injected into the view without changing the underlying document.\n*/\nexport interface InjectedTextOptions {\n\t/**\n\t * Sets the text to inject. Must be a single line.\n\t */\n\treadonly content: string;\n\n\t/**\n\t * @internal\n\t*/\n\treadonly tokens?: TokenArray | null;\n\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t */\n\treadonly inlineClassName?: string | null;\n\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\treadonly inlineClassNameAffectsLetterSpacing?: boolean;\n\n\t/**\n\t * This field allows to attach data to this injected text.\n\t * The data can be read when injected texts at a given position are queried.\n\t */\n\treadonly attachedData?: unknown;\n\n\t/**\n\t * Configures cursor stops around injected text.\n\t * Defaults to {@link InjectedTextCursorStops.Both}.\n\t*/\n\treadonly cursorStops?: InjectedTextCursorStops | null;\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth,\n\tRight,\n\tLeft,\n\tNone\n}\n\n/**\n * New model decorations.\n */\nexport interface IModelDeltaDecoration {\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * A decoration in the model.\n */\nexport interface IModelDecoration {\n\t/**\n\t * Identifier for a decoration.\n\t */\n\treadonly id: string;\n\t/**\n\t * Identifier for a decoration's owner.\n\t */\n\treadonly ownerId: number;\n\t/**\n\t * Range that this decoration covers.\n\t */\n\treadonly range: Range;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\treadonly options: IModelDecorationOptions;\n}\n\n/**\n * An accessor that can add, change or remove model decorations.\n * @internal\n */\nexport interface IModelDecorationsChangeAccessor {\n\t/**\n\t * Add a new decoration.\n\t * @param range Range that this decoration covers.\n\t * @param options Options associated with this decoration.\n\t * @return An unique identifier associated with this decoration.\n\t */\n\taddDecoration(range: IRange, options: IModelDecorationOptions): string;\n\t/**\n\t * Change the range that an existing decoration covers.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newRange The new range that this decoration covers.\n\t */\n\tchangeDecoration(id: string, newRange: IRange): void;\n\t/**\n\t * Change the options associated with an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newOptions The new options associated with this decoration.\n\t */\n\tchangeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;\n\t/**\n\t * Remove an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t */\n\tremoveDecoration(id: string): void;\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: readonly string[], newDecorations: readonly IModelDeltaDecoration[]): string[];\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport const enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * An identifier for a single edit operation.\n * @internal\n */\nexport interface ISingleEditOperationIdentifier {\n\t/**\n\t * Identifier major\n\t */\n\tmajor: number;\n\t/**\n\t * Identifier minor\n\t */\n\tminor: number;\n}\n\n/**\n * A single edit operation, that has an identifier.\n */\nexport interface IIdentifiedSingleEditOperation extends ISingleEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier?: ISingleEditOperationIdentifier | null;\n\t/**\n\t * This indicates that this operation is inserting automatic whitespace\n\t * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.\n\t * @internal\n\t */\n\tisAutoWhitespaceEdit?: boolean;\n\t/**\n\t * This indicates that this operation is in a set of operations that are tracked and should not be \"simplified\".\n\t * @internal\n\t */\n\t_isTracked?: boolean;\n}\n\nexport interface IValidEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier: ISingleEditOperationIdentifier | null;\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: Range;\n\t/**\n\t * The text to replace with. This can be empty to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * @internal\n\t */\n\ttextChange: TextChange;\n}\n\n/**\n * A callback that can compute the cursor state after applying a series of edit operations.\n */\nexport interface ICursorStateComputer {\n\t/**\n\t * A callback that can compute the resulting cursors state after some edit operations have been executed.\n\t */\n\t(inverseEditOperations: IValidEditOperation[]): Selection[] | null;\n}\n\nexport class TextModelResolvedOptions {\n\t_textModelResolvedOptionsBrand: void = undefined;\n\n\treadonly tabSize: number;\n\treadonly indentSize: number;\n\tprivate readonly _indentSizeIsTabSize: boolean;\n\treadonly insertSpaces: boolean;\n\treadonly defaultEOL: DefaultEndOfLine;\n\treadonly trimAutoWhitespace: boolean;\n\treadonly bracketPairColorizationOptions: BracketPairColorizationOptions;\n\n\tpublic get originalIndentSize(): number | 'tabSize' {\n\t\treturn this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(src: {\n\t\ttabSize: number;\n\t\tindentSize: number | 'tabSize';\n\t\tinsertSpaces: boolean;\n\t\tdefaultEOL: DefaultEndOfLine;\n\t\ttrimAutoWhitespace: boolean;\n\t\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n\t}) {\n\t\tthis.tabSize = Math.max(1, src.tabSize | 0);\n\t\tif (src.indentSize === 'tabSize') {\n\t\t\tthis.indentSize = this.tabSize;\n\t\t\tthis._indentSizeIsTabSize = true;\n\t\t} else {\n\t\t\tthis.indentSize = Math.max(1, src.indentSize | 0);\n\t\t\tthis._indentSizeIsTabSize = false;\n\t\t}\n\t\tthis.insertSpaces = Boolean(src.insertSpaces);\n\t\tthis.defaultEOL = src.defaultEOL | 0;\n\t\tthis.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n\t\tthis.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic equals(other: TextModelResolvedOptions): boolean {\n\t\treturn (\n\t\t\tthis.tabSize === other.tabSize\n\t\t\t&& this._indentSizeIsTabSize === other._indentSizeIsTabSize\n\t\t\t&& this.indentSize === other.indentSize\n\t\t\t&& this.insertSpaces === other.insertSpaces\n\t\t\t&& this.defaultEOL === other.defaultEOL\n\t\t\t&& this.trimAutoWhitespace === other.trimAutoWhitespace\n\t\t\t&& equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions)\n\t\t);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent {\n\t\treturn {\n\t\t\ttabSize: this.tabSize !== newOpts.tabSize,\n\t\t\tindentSize: this.indentSize !== newOpts.indentSize,\n\t\t\tinsertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n\t\t\ttrimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n\t\t};\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextModelCreationOptions {\n\ttabSize: number;\n\tindentSize: number | 'tabSize';\n\tinsertSpaces: boolean;\n\tdetectIndentation: boolean;\n\ttrimAutoWhitespace: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n\tisForSimpleWidget: boolean;\n\tlargeFileOptimizations: boolean;\n\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n}\n\nexport interface BracketPairColorizationOptions {\n\tenabled: boolean;\n\tindependentColorPoolPerBracketType: boolean;\n}\n\nexport interface ITextModelUpdateOptions {\n\ttabSize?: number;\n\tindentSize?: number | 'tabSize';\n\tinsertSpaces?: boolean;\n\ttrimAutoWhitespace?: boolean;\n\tbracketColorizationOptions?: BracketPairColorizationOptions;\n}\n\nexport class FindMatch {\n\t_findMatchBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly matches: string[] | null;\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(range: Range, matches: string[] | null) {\n\t\tthis.range = range;\n\t\tthis.matches = matches;\n\t}\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport const enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3,\n}\n\n/**\n * Text snapshot that works like an iterator.\n * Will try to return chunks of roughly ~64KB size.\n * Will return null when finished.\n */\nexport interface ITextSnapshot {\n\tread(): string | null;\n}\n\n/**\n * @internal\n */\nexport function isITextSnapshot(obj: any): obj is ITextSnapshot {\n\treturn (obj && typeof obj.read === 'function');\n}\n\n/**\n * A model.\n */\nexport interface ITextModel {\n\n\t/**\n\t * Gets the resource associated with this editor model.\n\t */\n\treadonly uri: URI;\n\n\t/**\n\t * A unique identifier associated with this model.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * This model is constructed for a simple widget code editor.\n\t * @internal\n\t */\n\treadonly isForSimpleWidget: boolean;\n\n\t/**\n\t * If true, the text model might contain RTL.\n\t * If false, the text model **contains only** contain LTR.\n\t * @internal\n\t */\n\tmightContainRTL(): boolean;\n\n\t/**\n\t * If true, the text model might contain LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).\n\t * If false, the text model definitely does not contain these.\n\t * @internal\n\t */\n\tmightContainUnusualLineTerminators(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\tremoveUnusualLineTerminators(selections?: Selection[]): void;\n\n\t/**\n\t * If true, the text model might contain non basic ASCII.\n\t * If false, the text model **contains only** basic ASCII.\n\t * @internal\n\t */\n\tmightContainNonBasicASCII(): boolean;\n\n\t/**\n\t * Get the resolved options for this model.\n\t */\n\tgetOptions(): TextModelResolvedOptions;\n\n\t/**\n\t * Get the formatting options for this model.\n\t * @internal\n\t */\n\tgetFormattingOptions(): FormattingOptions;\n\n\t/**\n\t * Get the current version id of the model.\n\t * Anytime a change happens to the model (even undo/redo),\n\t * the version id is incremented.\n\t */\n\tgetVersionId(): number;\n\n\t/**\n\t * Get the alternative version id of the model.\n\t * This alternative version id is not always incremented,\n\t * it will return the same values in the case of undo-redo.\n\t */\n\tgetAlternativeVersionId(): number;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t */\n\tsetValue(newValue: string | ITextSnapshot): void;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text.\n\t */\n\tgetValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text snapshot (it is safe to consume it asynchronously).\n\t */\n\tcreateSnapshot(preserveBOM?: boolean): ITextSnapshot;\n\n\t/**\n\t * Get the length of the text stored in this model.\n\t */\n\tgetValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;\n\n\t/**\n\t * Check if the raw text stored in this model equals another raw text.\n\t * @internal\n\t */\n\tequalsTextBuffer(other: ITextBuffer): boolean;\n\n\t/**\n\t * Get the underling text buffer.\n\t * @internal\n\t */\n\tgetTextBuffer(): ITextBuffer;\n\n\t/**\n\t * Get the text in a certain range.\n\t * @param range The range describing what text to get.\n\t * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @return The text.\n\t */\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n\n\t/**\n\t * Get the length of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t * @return The text length.\n\t */\n\tgetValueLengthInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Get the character count of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t */\n\tgetCharacterCountInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Splits characters in two buckets. First bucket (A) is of characters that\n\t * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of\n\t * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.\n\t * If count(B) > count(A) return true. Returns false otherwise.\n\t * @internal\n\t */\n\tisDominatedByLongLines(): boolean;\n\n\t/**\n\t * Get the number of lines in the model.\n\t */\n\tgetLineCount(): number;\n\n\t/**\n\t * Get the text for a certain line.\n\t */\n\tgetLineContent(lineNumber: number): string;\n\n\t/**\n\t * Get the text length for a certain line.\n\t */\n\tgetLineLength(lineNumber: number): number;\n\n\t/**\n\t * Get the text for all lines.\n\t */\n\tgetLinesContent(): string[];\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t * @return EOL char sequence (e.g.: '\\n' or '\\r\\n').\n\t */\n\tgetEOL(): string;\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t */\n\tgetEndOfLineSequence(): EndOfLineSequence;\n\n\t/**\n\t * Get the minimum legal column for line at `lineNumber`\n\t */\n\tgetLineMinColumn(lineNumber: number): number;\n\n\t/**\n\t * Get the maximum legal column for line at `lineNumber`\n\t */\n\tgetLineMaxColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column before the first non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column after the last non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Create a valid position.\n\t */\n\tvalidatePosition(position: IPosition): Position;\n\n\t/**\n\t * Advances the given position by the given offset (negative offsets are also accepted)\n\t * and returns it as a new valid position.\n\t *\n\t * If the offset and position are such that their combination goes beyond the beginning or\n\t * end of the model, throws an exception.\n\t *\n\t * If the offset is such that the new position would be in the middle of a multi-byte\n\t * line terminator, throws an exception.\n\t */\n\tmodifyPosition(position: IPosition, offset: number): Position;\n\n\t/**\n\t * Create a valid range.\n\t */\n\tvalidateRange(range: IRange): Range;\n\n\t/**\n\t * Verifies the range is valid.\n\t */\n\tisValidRange(range: IRange): boolean;\n\n\t/**\n\t * Converts the position to a zero-based offset.\n\t *\n\t * The position will be [adjusted](#TextDocument.validatePosition).\n\t *\n\t * @param position A position.\n\t * @return A valid zero-based offset.\n\t */\n\tgetOffsetAt(position: IPosition): number;\n\n\t/**\n\t * Converts a zero-based offset to a position.\n\t *\n\t * @param offset A zero-based offset.\n\t * @return A valid [position](#Position).\n\t */\n\tgetPositionAt(offset: number): Position;\n\n\t/**\n\t * Get a range covering the entire model.\n\t */\n\tgetFullModelRange(): Range;\n\n\t/**\n\t * Returns if the model was disposed or not.\n\t */\n\tisDisposed(): boolean;\n\n\t/**\n\t * This model is so large that it would not be a good idea to sync it over\n\t * to web workers or other places.\n\t * @internal\n\t */\n\tisTooLargeForSyncing(): boolean;\n\n\t/**\n\t * The file is so large, that even tokenization is disabled.\n\t * @internal\n\t */\n\tisTooLargeForTokenization(): boolean;\n\n\t/**\n\t * The file is so large, that operations on it might be too large for heap\n\t * and can lead to OOM crashes so they should be disabled.\n\t * @internal\n\t */\n\tisTooLargeForHeapOperation(): boolean;\n\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if not matches have been found.\n\t */\n\tfindMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchScope Limit the searching to only search inside these ranges.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if no matches have been found.\n\t */\n\tfindMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model for the next match. Loops to the beginning of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the next match is. It is null if no next match has been found.\n\t */\n\tfindNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\t/**\n\t * Search the model for the previous match. Loops to the end of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the previous match is. It is null if no previous match has been found.\n\t */\n\tfindPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\n\n\t/**\n\t * Get the language associated with this model.\n\t */\n\tgetLanguageId(): string;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageId The new language.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageId: string, source?: string): void;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageSelection The new language selection.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageSelection: ILanguageSelection, source?: string): void;\n\n\t/**\n\t * Returns the real (inner-most) language mode at a given position.\n\t * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\t/**\n\t * Get the word under or besides `position`.\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Might be null.\n\t */\n\tgetWordAtPosition(position: IPosition): IWordAtPosition | null;\n\n\t/**\n\t * Get the word under or besides `position` trimmed to `position`.column\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Will never be null.\n\t */\n\tgetWordUntilPosition(position: IPosition): IWordAtPosition;\n\n\t/**\n\t * Change the decorations. The callback will be called with a change accessor\n\t * that becomes invalid as soon as the callback finishes executing.\n\t * This allows for all events to be queued up until the change\n\t * is completed. Returns whatever the callback returns.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @internal\n\t */\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;\n\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];\n\n\t/**\n\t * Remove all decorations that have been added with this specific ownerId.\n\t * @param ownerId The owner id to search for.\n\t * @internal\n\t */\n\tremoveAllDecorationsWithOwnerId(ownerId: number): void;\n\n\t/**\n\t * Get the options associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration options or null if the decoration was not found.\n\t */\n\tgetDecorationOptions(id: string): IModelDecorationOptions | null;\n\n\t/**\n\t * Get the range associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration range or null if the decoration was not found.\n\t */\n\tgetDecorationRange(id: string): Range | null;\n\n\t/**\n\t * Gets all the decorations for the line `lineNumber` as an array.\n\t * @param lineNumber The line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the font decorations for the line `lineNumber` as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @internal\n\t */\n\tgetFontDecorationsInRange(range: IRange, ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.\n\t * So for now it returns all the decorations on the same line as `range`.\n\t * @param range The range to search in\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @param onlyMinimapDecorations If set, it will return only decorations that render in the minimap.\n\t * @param onlyMarginDecorations If set, it will return only decorations that render in the glyph margin.\n\t * @return An array with the decorations\n\t */\n\tgetDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean, onlyMinimapDecorations?: boolean, onlyMarginDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all decorations that render in the glyph margin as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetAllMarginDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that should be rendered in the overview ruler as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain injected text.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetInjectedTextDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain custom line heights.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetCustomLineHeightsDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * @internal\n\t */\n\t_getTrackedRange(id: string): Range | null;\n\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: TrackedRangeStickiness): null;\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: TrackedRangeStickiness): string;\n\n\t/**\n\t * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).\n\t */\n\tnormalizeIndentation(str: string): string;\n\n\t/**\n\t * Change the options of this model.\n\t */\n\tupdateOptions(newOpts: ITextModelUpdateOptions): void;\n\n\t/**\n\t * Detect the indentation options for this model from its content.\n\t */\n\tdetectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;\n\n\t/**\n\t * Close the current undo-redo element.\n\t * This offers a way to create an undo/redo stop point.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Open the current undo-redo element.\n\t * This offers a way to remove the current undo/redo stop point.\n\t */\n\tpopStackElement(): void;\n\n\t/**\n\t * @internal\n\t*/\n\tedit(edit: TextEdit, options?: { reason?: TextModelEditSource }): void;\n\n\t/**\n\t * Push edit operations, basically editing the model. This is the preferred way\n\t * of editing the model. The edit operations will land on the undo stack.\n\t * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when `undo` or `redo` are invoked.\n\t * @param editOperations The edit operations.\n\t * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.\n\t * @return The cursor state returned by the `cursorStateComputer`.\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;\n\t/**\n\t * @internal\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null;\n\n\t/**\n\t * Change the end of line sequence. This is the preferred way of\n\t * changing the eol sequence. This will land on the undo stack.\n\t */\n\tpushEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * Edit the model without adding the edits to the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.\n\t * @param operations The edit operations.\n\t * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.\n\t */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[]): void;\n\t/** @internal */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], reason: TextModelEditSource): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];\n\n\t/**\n\t * Change the end of line sequence without recording in the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.\n\t */\n\tsetEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyUndo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyRedo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * Undo edit operations until the previous undo/redo point.\n\t * The inverse edit operations will be pushed on the redo stack.\n\t */\n\tundo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the undo stack?\n\t */\n\tcanUndo(): boolean;\n\n\t/**\n\t * Redo edit operations until the next undo/redo point.\n\t * The inverse edit operations will be pushed on the undo stack.\n\t */\n\tredo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the redo stack?\n\t */\n\tcanRedo(): boolean;\n\n\t/**\n\t * @deprecated Please use `onDidChangeContent` instead.\n\t * An event emitted when the contents of the model have changed.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeContentOrInjectedText: Event<InternalModelContentChangeEvent | ModelInjectedTextChangedEvent>;\n\t/**\n\t * An event emitted when the contents of the model have changed.\n\t * @event\n\t */\n\tonDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when decorations of the model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when line heights from decorations changes.\n\t * This event is emitted only when adding, removing or changing a decoration\n\t * and not when doing edits in the model (i.e. when decoration ranges change)\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\t/**\n\t* An event emitted when the font from decorations changes.\n\t* This event is emitted only when adding, removing or changing a decoration\n\t* and not when doing edits in the model (i.e. when decoration ranges change)\n\t* @internal\n\t* @event\n\t*/\n\treadonly onDidChangeFont: Event<ModelFontChangedEvent>;\n\t/**\n\t * An event emitted when the model options have changed.\n\t * @event\n\t */\n\treadonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the language associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the tokens associated with the model have changed.\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the model has been attached to the first editor or detached from the last editor.\n\t * @event\n\t */\n\treadonly onDidChangeAttached: Event<void>;\n\t/**\n\t * An event emitted right before disposing the model.\n\t * @event\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * Destroy this model.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeAttached(): IAttachedView;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeDetached(view: IAttachedView): void;\n\n\t/**\n\t * Returns if this model is attached to an editor or not.\n\t */\n\tisAttachedToEditor(): boolean;\n\n\t/**\n\t * Returns the count of editors this model is attached to.\n\t * @internal\n\t */\n\tgetAttachedEditorCount(): number;\n\n\t/**\n\t * Among all positions that are projected to the same position in the underlying text model as\n\t * the given position, select a unique position as indicated by the affinity.\n\t *\n\t * PositionAffinity.Left:\n\t * The normalized position must be equal or left to the requested position.\n\t *\n\t * PositionAffinity.Right:\n\t * The normalized position must be equal or right to the requested position.\n\t *\n\t * @internal\n\t */\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns an object that can be used to query brackets.\n\t * @internal\n\t*/\n\treadonly bracketPairs: IBracketPairsTextModelPart;\n\n\t/**\n\t * Returns an object that can be used to query indent guides.\n\t * @internal\n\t*/\n\treadonly guides: IGuidesTextModelPart;\n\n\t/**\n\t * @internal\n\t */\n\treadonly tokenization: ITokenizationTextModelPart;\n}\n\n/**\n * @internal\n */\nexport function isITextModel(obj: IEditorModel): obj is ITextModel {\n\treturn Boolean(obj && (obj as ITextModel).uri);\n}\n\n/**\n * @internal\n */\nexport interface IAttachedView {\n\t/**\n\t * @param stabilized Indicates if the visible lines are probably going to change soon or can be considered stable.\n\t * Is true on reveal range and false on scroll.\n\t * Tokenizers should tokenize synchronously if stabilized is true.\n\t */\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void;\n}\n\nexport const enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4,\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferBuilder {\n\tacceptChunk(chunk: string): void;\n\tfinish(): ITextBufferFactory;\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferFactory {\n\tcreate(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable };\n\tgetFirstLineText(lengthLimit: number): string;\n}\n\n/**\n * @internal\n */\nexport const enum ModelConstants {\n\tFIRST_LINE_DETECTION_LENGTH_LIMIT = 1000\n}\n\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {\n\tconstructor(\n\t\tpublic readonly identifier: ISingleEditOperationIdentifier | null,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string | null,\n\t\tpublic readonly forceMoveMarkers: boolean,\n\t\tpublic readonly isAutoWhitespaceEdit: boolean,\n\t\tpublic readonly _isTracked: boolean,\n\t) { }\n}\n\n/**\n * @internal\n *\n * `lineNumber` is 1 based.\n */\nexport interface IReadonlyTextBuffer {\n\tonDidChangeContent: Event<void>;\n\tequals(other: ITextBuffer): boolean;\n\tmightContainRTL(): boolean;\n\tmightContainUnusualLineTerminators(): boolean;\n\tresetMightContainUnusualLineTerminators(): void;\n\tmightContainNonBasicASCII(): boolean;\n\tgetBOM(): string;\n\tgetEOL(): string;\n\n\tgetOffsetAt(lineNumber: number, column: number): number;\n\tgetPositionAt(offset: number): Position;\n\tgetRangeAt(offset: number, length: number): Range;\n\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tcreateSnapshot(preserveBOM: boolean): ITextSnapshot;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetLength(): number;\n\tgetLineCount(): number;\n\tgetLinesContent(): string[];\n\tgetLineContent(lineNumber: number): string;\n\tgetLineCharCode(lineNumber: number, index: number): number;\n\tgetCharCode(offset: number): number;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];\n\n\t/**\n\t * Get nearest chunk of text after `offset` in the text buffer.\n\t */\n\tgetNearestChunk(offset: number): string;\n}\n\n/**\n * @internal\n */\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextBuffer extends IReadonlyTextBuffer, IDisposable {\n\tsetEOL(newEOL: '\\r\\n' | '\\n'): void;\n\tapplyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;\n}\n\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n\n\tconstructor(\n\t\tpublic readonly reverseEdits: IValidEditOperation[] | null,\n\t\tpublic readonly changes: IInternalModelContentChange[],\n\t\tpublic readonly trimAutoWhitespaceLineNumbers: number[] | null\n\t) { }\n\n}\n\n/**\n * @internal\n */\nexport interface IInternalModelContentChange extends IModelContentChange {\n\trange: Range;\n\tforceMoveMarkers: boolean;\n}\n\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model: ITextModel): boolean {\n\treturn (\n\t\t!model.isTooLargeForSyncing() && !model.isForSimpleWidget\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from '../../base/common/event.js';\nimport { IMarkdownString } from '../../base/common/htmlContent.js';\nimport { IDisposable } from '../../base/common/lifecycle.js';\nimport { equals } from '../../base/common/objects.js';\nimport { ThemeColor } from '../../base/common/themables.js';\nimport { URI } from '../../base/common/uri.js';\nimport { ISingleEditOperation } from './core/editOperation.js';\nimport { IPosition, Position } from './core/position.js';\nimport { IRange, Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { TextChange } from './core/textChange.js';\nimport { WordCharacterClassifier } from './core/wordCharacterClassifier.js';\nimport { IWordAtPosition } from './core/wordHelper.js';\nimport { FormattingOptions } from './languages.js';\nimport { ILanguageSelection } from './languages/language.js';\nimport { IBracketPairsTextModelPart } from './textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelFontChangedEvent, ModelInjectedTextChangedEvent, ModelLineHeightChangedEvent } from './textModelEvents.js';\nimport { IModelContentChange } from './model/mirrorTextModel.js';\nimport { IGuidesTextModelPart } from './textModelGuides.js';\nimport { ITokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { UndoRedoGroup } from '../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from './tokens/lineTokens.js';\nimport { IEditorModel } from './editorCommon.js';\nimport { TextModelEditSource } from './textModelEditSource.js';\nimport { TextEdit } from './core/edits/textEdit.js';\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport enum GlyphMarginLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 3,\n}\n\nexport interface IGlyphMarginLanesModel {\n\t/**\n\t * The number of lanes that should be rendered in the editor.\n\t */\n\treadonly requiredLanes: number;\n\n\t/**\n\t * Gets the lanes that should be rendered starting at a given line number.\n\t */\n\tgetLanesAtLine(lineNumber: number): GlyphMarginLane[];\n\n\t/**\n\t * Resets the model and ensures it can contain at least `maxLine` lines.\n\t */\n\treset(maxLine: number): void;\n\n\t/**\n\t * Registers that a lane should be visible at the Range in the model.\n\t * @param persist - if true, notes that the lane should always be visible,\n\t * even on lines where there's no specific request for that lane.\n\t */\n\tpush(lane: GlyphMarginLane, range: Range, persist?: boolean): void;\n}\n\n/**\n * Position in the minimap to render the decoration.\n */\nexport const enum MinimapPosition {\n\tInline = 1,\n\tGutter = 2\n}\n\n/**\n * Section header style.\n */\nexport const enum MinimapSectionHeaderStyle {\n\tNormal = 1,\n\tUnderlined = 2\n}\n\nexport interface IDecorationOptions {\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tcolor: string | ThemeColor | undefined;\n\t/**\n\t * CSS color to render.\n\t * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry\n\t */\n\tdarkColor?: string | ThemeColor;\n}\n\nexport interface IModelDecorationGlyphMarginOptions {\n\t/**\n\t * The position in the glyph margin.\n\t */\n\tposition: GlyphMarginLane;\n\n\t/**\n\t * Whether the glyph margin lane in {@link position} should be rendered even\n\t * outside of this decoration's range.\n\t */\n\tpersistLane?: boolean;\n}\n\n/**\n * Options for rendering a model decoration in the overview ruler.\n */\nexport interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {\n\t/**\n\t * The position in the overview ruler.\n\t */\n\tposition: OverviewRulerLane;\n}\n\n/**\n * Options for rendering a model decoration in the minimap.\n */\nexport interface IModelDecorationMinimapOptions extends IDecorationOptions {\n\t/**\n\t * The position in the minimap.\n\t */\n\tposition: MinimapPosition;\n\t/**\n\t * If the decoration is for a section header, which header style.\n\t */\n\tsectionHeaderStyle?: MinimapSectionHeaderStyle | null;\n\t/**\n\t * If the decoration is for a section header, the header text.\n\t */\n\tsectionHeaderText?: string | null;\n}\n\n/**\n * Options for a model decoration.\n */\nexport interface IModelDecorationOptions {\n\t/**\n\t * A debug description that can be used for inspecting model decorations.\n\t * @internal\n\t */\n\tdescription: string;\n\t/**\n\t * Customize the growing behavior of the decoration when typing at the edges of the decoration.\n\t * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t */\n\tstickiness?: TrackedRangeStickiness;\n\t/**\n\t * CSS class name describing the decoration.\n\t */\n\tclassName?: string | null;\n\t/**\n\t * Indicates whether the decoration should span across the entire line when it continues onto the next line.\n\t */\n\tshouldFillLineOnLineBreak?: boolean | null;\n\tblockClassName?: string | null;\n\t/**\n\t * Indicates if this block should be rendered after the last line.\n\t * In this case, the range must be empty and set to the last line.\n\t */\n\tblockIsAfterEnd?: boolean | null;\n\tblockDoesNotCollapse?: boolean | null;\n\tblockPadding?: [top: number, right: number, bottom: number, left: number] | null;\n\n\t/**\n\t * Message to be rendered when hovering over the glyph margin decoration.\n\t */\n\tglyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the decoration message.\n\t */\n\thoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Array of MarkdownString to render as the line number message.\n\t */\n\tlineNumberHoverMessage?: IMarkdownString | IMarkdownString[] | null;\n\t/**\n\t * Should the decoration expand to encompass a whole line.\n\t */\n\tisWholeLine?: boolean;\n\t/**\n\t * Always render the decoration (even when the range it encompasses is collapsed).\n\t */\n\tshowIfCollapsed?: boolean;\n\t/**\n\t * Collapse the decoration if its entire range is being replaced via an edit.\n\t * @internal\n\t */\n\tcollapseOnReplaceEdit?: boolean;\n\t/**\n\t * Specifies the stack order of a decoration.\n\t * A decoration with greater stack order is always in front of a decoration with\n\t * a lower stack order when the decorations are on the same line.\n\t */\n\tzIndex?: number;\n\t/**\n\t * If set, render this decoration in the overview ruler.\n\t */\n\toverviewRuler?: IModelDecorationOverviewRulerOptions | null;\n\t/**\n\t * If set, render this decoration in the minimap.\n\t */\n\tminimap?: IModelDecorationMinimapOptions | null;\n\t/**\n\t * If set, the decoration will be rendered in the glyph margin with this CSS class name.\n\t */\n\tglyphMarginClassName?: string | null;\n\t/**\n\t * If set and the decoration has {@link glyphMarginClassName} set, render this decoration\n\t * with the specified {@link IModelDecorationGlyphMarginOptions} in the glyph margin.\n\t */\n\tglyphMargin?: IModelDecorationGlyphMarginOptions | null;\n\t/**\n\t * If set, the decoration will override the line height of the lines it spans. Maximum value is 300px.\n\t */\n\tlineHeight?: number | null;\n\t/**\n\t * Font family\n\t */\n\tfontFamily?: string | null;\n\t/**\n\t * Font size\n\t */\n\tfontSize?: string | null;\n\t/**\n\t * Font weight\n\t */\n\tfontWeight?: string | null;\n\t/**\n\t * Font style\n\t */\n\tfontStyle?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name.\n\t */\n\tlinesDecorationsClassName?: string | null;\n\t/**\n\t * Controls the tooltip text of the line decoration.\n\t */\n\tlinesDecorationsTooltip?: string | null;\n\t/**\n\t * If set, the decoration will be rendered on the line number.\n\t */\n\tlineNumberClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.\n\t */\n\tfirstLineDecorationClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.\n\t */\n\tmarginClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t * Please use this only for CSS rules that must impact the text. For example, use `className`\n\t * to have a background color decoration.\n\t */\n\tinlineClassName?: string | null;\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\tinlineClassNameAffectsLetterSpacing?: boolean;\n\t/**\n\t * If set, the decoration will be rendered before the text with this CSS class name.\n\t */\n\tbeforeContentClassName?: string | null;\n\t/**\n\t * If set, the decoration will be rendered after the text with this CSS class name.\n\t */\n\tafterContentClassName?: string | null;\n\t/**\n\t * If set, text will be injected in the view after the range.\n\t */\n\tafter?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, text will be injected in the view before the range.\n\t */\n\tbefore?: InjectedTextOptions | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for comment tokens.\n\t * @internal\n\t*/\n\thideInCommentTokens?: boolean | null;\n\n\t/**\n\t * If set, this decoration will not be rendered for string tokens.\n\t * @internal\n\t*/\n\thideInStringTokens?: boolean | null;\n\n\t/**\n\t * Whether the decoration affects the font.\n\t * @internal\n\t */\n\taffectsFont?: boolean | null;\n\n\t/**\n\t * The text direction of the decoration.\n\t */\n\ttextDirection?: TextDirection | null;\n}\n\n/**\n * Text Direction for a decoration.\n */\nexport enum TextDirection {\n\tLTR = 0,\n\n\tRTL = 1,\n}\n\n/**\n * Configures text that is injected into the view without changing the underlying document.\n*/\nexport interface InjectedTextOptions {\n\t/**\n\t * Sets the text to inject. Must be a single line.\n\t */\n\treadonly content: string;\n\n\t/**\n\t * @internal\n\t*/\n\treadonly tokens?: TokenArray | null;\n\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t */\n\treadonly inlineClassName?: string | null;\n\n\t/**\n\t * If there is an `inlineClassName` which affects letter spacing.\n\t */\n\treadonly inlineClassNameAffectsLetterSpacing?: boolean;\n\n\t/**\n\t * This field allows to attach data to this injected text.\n\t * The data can be read when injected texts at a given position are queried.\n\t */\n\treadonly attachedData?: unknown;\n\n\t/**\n\t * Configures cursor stops around injected text.\n\t * Defaults to {@link InjectedTextCursorStops.Both}.\n\t*/\n\treadonly cursorStops?: InjectedTextCursorStops | null;\n}\n\nexport enum InjectedTextCursorStops {\n\tBoth,\n\tRight,\n\tLeft,\n\tNone\n}\n\n/**\n * New model decorations.\n */\nexport interface IModelDeltaDecoration {\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * A decoration in the model.\n */\nexport interface IModelDecoration {\n\t/**\n\t * Identifier for a decoration.\n\t */\n\treadonly id: string;\n\t/**\n\t * Identifier for a decoration's owner.\n\t */\n\treadonly ownerId: number;\n\t/**\n\t * Range that this decoration covers.\n\t */\n\treadonly range: Range;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\treadonly options: IModelDecorationOptions;\n}\n\n/**\n * An accessor that can add, change or remove model decorations.\n * @internal\n */\nexport interface IModelDecorationsChangeAccessor {\n\t/**\n\t * Add a new decoration.\n\t * @param range Range that this decoration covers.\n\t * @param options Options associated with this decoration.\n\t * @return An unique identifier associated with this decoration.\n\t */\n\taddDecoration(range: IRange, options: IModelDecorationOptions): string;\n\t/**\n\t * Change the range that an existing decoration covers.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newRange The new range that this decoration covers.\n\t */\n\tchangeDecoration(id: string, newRange: IRange): void;\n\t/**\n\t * Change the options associated with an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newOptions The new options associated with this decoration.\n\t */\n\tchangeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;\n\t/**\n\t * Remove an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t */\n\tremoveDecoration(id: string): void;\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: readonly string[], newDecorations: readonly IModelDeltaDecoration[]): string[];\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport const enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport const enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * An identifier for a single edit operation.\n * @internal\n */\nexport interface ISingleEditOperationIdentifier {\n\t/**\n\t * Identifier major\n\t */\n\tmajor: number;\n\t/**\n\t * Identifier minor\n\t */\n\tminor: number;\n}\n\n/**\n * A single edit operation, that has an identifier.\n */\nexport interface IIdentifiedSingleEditOperation extends ISingleEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier?: ISingleEditOperationIdentifier | null;\n\t/**\n\t * This indicates that this operation is inserting automatic whitespace\n\t * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.\n\t * @internal\n\t */\n\tisAutoWhitespaceEdit?: boolean;\n\t/**\n\t * This indicates that this operation is in a set of operations that are tracked and should not be \"simplified\".\n\t * @internal\n\t */\n\t_isTracked?: boolean;\n}\n\nexport interface IValidEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t * @internal\n\t */\n\tidentifier: ISingleEditOperationIdentifier | null;\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: Range;\n\t/**\n\t * The text to replace with. This can be empty to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * @internal\n\t */\n\ttextChange: TextChange;\n}\n\n/**\n * A callback that can compute the cursor state after applying a series of edit operations.\n */\nexport interface ICursorStateComputer {\n\t/**\n\t * A callback that can compute the resulting cursors state after some edit operations have been executed.\n\t */\n\t(inverseEditOperations: IValidEditOperation[]): Selection[] | null;\n}\n\nexport class TextModelResolvedOptions {\n\t_textModelResolvedOptionsBrand: void = undefined;\n\n\treadonly tabSize: number;\n\treadonly indentSize: number;\n\tprivate readonly _indentSizeIsTabSize: boolean;\n\treadonly insertSpaces: boolean;\n\treadonly defaultEOL: DefaultEndOfLine;\n\treadonly trimAutoWhitespace: boolean;\n\treadonly bracketPairColorizationOptions: BracketPairColorizationOptions;\n\n\tpublic get originalIndentSize(): number | 'tabSize' {\n\t\treturn this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(src: {\n\t\ttabSize: number;\n\t\tindentSize: number | 'tabSize';\n\t\tinsertSpaces: boolean;\n\t\tdefaultEOL: DefaultEndOfLine;\n\t\ttrimAutoWhitespace: boolean;\n\t\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n\t}) {\n\t\tthis.tabSize = Math.max(1, src.tabSize | 0);\n\t\tif (src.indentSize === 'tabSize') {\n\t\t\tthis.indentSize = this.tabSize;\n\t\t\tthis._indentSizeIsTabSize = true;\n\t\t} else {\n\t\t\tthis.indentSize = Math.max(1, src.indentSize | 0);\n\t\t\tthis._indentSizeIsTabSize = false;\n\t\t}\n\t\tthis.insertSpaces = Boolean(src.insertSpaces);\n\t\tthis.defaultEOL = src.defaultEOL | 0;\n\t\tthis.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n\t\tthis.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic equals(other: TextModelResolvedOptions): boolean {\n\t\treturn (\n\t\t\tthis.tabSize === other.tabSize\n\t\t\t&& this._indentSizeIsTabSize === other._indentSizeIsTabSize\n\t\t\t&& this.indentSize === other.indentSize\n\t\t\t&& this.insertSpaces === other.insertSpaces\n\t\t\t&& this.defaultEOL === other.defaultEOL\n\t\t\t&& this.trimAutoWhitespace === other.trimAutoWhitespace\n\t\t\t&& equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions)\n\t\t);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent {\n\t\treturn {\n\t\t\ttabSize: this.tabSize !== newOpts.tabSize,\n\t\t\tindentSize: this.indentSize !== newOpts.indentSize,\n\t\t\tinsertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n\t\t\ttrimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n\t\t};\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextModelCreationOptions {\n\ttabSize: number;\n\tindentSize: number | 'tabSize';\n\tinsertSpaces: boolean;\n\tdetectIndentation: boolean;\n\ttrimAutoWhitespace: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n\tisForSimpleWidget: boolean;\n\tlargeFileOptimizations: boolean;\n\tbracketPairColorizationOptions: BracketPairColorizationOptions;\n}\n\nexport interface BracketPairColorizationOptions {\n\tenabled: boolean;\n\tindependentColorPoolPerBracketType: boolean;\n}\n\nexport interface ITextModelUpdateOptions {\n\ttabSize?: number;\n\tindentSize?: number | 'tabSize';\n\tinsertSpaces?: boolean;\n\ttrimAutoWhitespace?: boolean;\n\tbracketColorizationOptions?: BracketPairColorizationOptions;\n}\n\nexport class FindMatch {\n\t_findMatchBrand: void = undefined;\n\n\tpublic readonly range: Range;\n\tpublic readonly matches: string[] | null;\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(range: Range, matches: string[] | null) {\n\t\tthis.range = range;\n\t\tthis.matches = matches;\n\t}\n}\n\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nexport const enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3,\n}\n\n/**\n * Text snapshot that works like an iterator.\n * Will try to return chunks of roughly ~64KB size.\n * Will return null when finished.\n */\nexport interface ITextSnapshot {\n\tread(): string | null;\n}\n\n/**\n * @internal\n */\nexport function isITextSnapshot(obj: any): obj is ITextSnapshot {\n\treturn (obj && typeof obj.read === 'function');\n}\n\n/**\n * A model.\n */\nexport interface ITextModel {\n\n\t/**\n\t * Gets the resource associated with this editor model.\n\t */\n\treadonly uri: URI;\n\n\t/**\n\t * A unique identifier associated with this model.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * This model is constructed for a simple widget code editor.\n\t * @internal\n\t */\n\treadonly isForSimpleWidget: boolean;\n\n\t/**\n\t * If true, the text model might contain RTL.\n\t * If false, the text model **contains only** contain LTR.\n\t * @internal\n\t */\n\tmightContainRTL(): boolean;\n\n\t/**\n\t * If true, the text model might contain LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).\n\t * If false, the text model definitely does not contain these.\n\t * @internal\n\t */\n\tmightContainUnusualLineTerminators(): boolean;\n\n\t/**\n\t * @internal\n\t */\n\tremoveUnusualLineTerminators(selections?: Selection[]): void;\n\n\t/**\n\t * If true, the text model might contain non basic ASCII.\n\t * If false, the text model **contains only** basic ASCII.\n\t * @internal\n\t */\n\tmightContainNonBasicASCII(): boolean;\n\n\t/**\n\t * Get the resolved options for this model.\n\t */\n\tgetOptions(): TextModelResolvedOptions;\n\n\t/**\n\t * Get the formatting options for this model.\n\t * @internal\n\t */\n\tgetFormattingOptions(): FormattingOptions;\n\n\t/**\n\t * Get the current version id of the model.\n\t * Anytime a change happens to the model (even undo/redo),\n\t * the version id is incremented.\n\t */\n\tgetVersionId(): number;\n\n\t/**\n\t * Get the alternative version id of the model.\n\t * This alternative version id is not always incremented,\n\t * it will return the same values in the case of undo-redo.\n\t */\n\tgetAlternativeVersionId(): number;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t */\n\tsetValue(newValue: string | ITextSnapshot): void;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text.\n\t */\n\tgetValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text snapshot (it is safe to consume it asynchronously).\n\t */\n\tcreateSnapshot(preserveBOM?: boolean): ITextSnapshot;\n\n\t/**\n\t * Get the length of the text stored in this model.\n\t */\n\tgetValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;\n\n\t/**\n\t * Check if the raw text stored in this model equals another raw text.\n\t * @internal\n\t */\n\tequalsTextBuffer(other: ITextBuffer): boolean;\n\n\t/**\n\t * Get the underling text buffer.\n\t * @internal\n\t */\n\tgetTextBuffer(): ITextBuffer;\n\n\t/**\n\t * Get the text in a certain range.\n\t * @param range The range describing what text to get.\n\t * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @return The text.\n\t */\n\tgetValueInRange(range: IRange, eol?: EndOfLinePreference): string;\n\n\t/**\n\t * Get the length of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t * @return The text length.\n\t */\n\tgetValueLengthInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Get the character count of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t */\n\tgetCharacterCountInRange(range: IRange, eol?: EndOfLinePreference): number;\n\n\t/**\n\t * Splits characters in two buckets. First bucket (A) is of characters that\n\t * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of\n\t * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.\n\t * If count(B) > count(A) return true. Returns false otherwise.\n\t * @internal\n\t */\n\tisDominatedByLongLines(): boolean;\n\n\t/**\n\t * Get the number of lines in the model.\n\t */\n\tgetLineCount(): number;\n\n\t/**\n\t * Get the text for a certain line.\n\t */\n\tgetLineContent(lineNumber: number): string;\n\n\t/**\n\t * Get the text length for a certain line.\n\t */\n\tgetLineLength(lineNumber: number): number;\n\n\t/**\n\t * Get the text for all lines.\n\t */\n\tgetLinesContent(): string[];\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t * @return EOL char sequence (e.g.: '\\n' or '\\r\\n').\n\t */\n\tgetEOL(): string;\n\n\t/**\n\t * Get the end of line sequence predominantly used in the text buffer.\n\t */\n\tgetEndOfLineSequence(): EndOfLineSequence;\n\n\t/**\n\t * Get the minimum legal column for line at `lineNumber`\n\t */\n\tgetLineMinColumn(lineNumber: number): number;\n\n\t/**\n\t * Get the maximum legal column for line at `lineNumber`\n\t */\n\tgetLineMaxColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column before the first non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns the column after the last non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\n\t/**\n\t * Create a valid position.\n\t */\n\tvalidatePosition(position: IPosition): Position;\n\n\t/**\n\t * Advances the given position by the given offset (negative offsets are also accepted)\n\t * and returns it as a new valid position.\n\t *\n\t * If the offset and position are such that their combination goes beyond the beginning or\n\t * end of the model, throws an exception.\n\t *\n\t * If the offset is such that the new position would be in the middle of a multi-byte\n\t * line terminator, throws an exception.\n\t */\n\tmodifyPosition(position: IPosition, offset: number): Position;\n\n\t/**\n\t * Create a valid range.\n\t */\n\tvalidateRange(range: IRange): Range;\n\n\t/**\n\t * Verifies the range is valid.\n\t */\n\tisValidRange(range: IRange): boolean;\n\n\t/**\n\t * Converts the position to a zero-based offset.\n\t *\n\t * The position will be [adjusted](#TextDocument.validatePosition).\n\t *\n\t * @param position A position.\n\t * @return A valid zero-based offset.\n\t */\n\tgetOffsetAt(position: IPosition): number;\n\n\t/**\n\t * Converts a zero-based offset to a position.\n\t *\n\t * @param offset A zero-based offset.\n\t * @return A valid [position](#Position).\n\t */\n\tgetPositionAt(offset: number): Position;\n\n\t/**\n\t * Get a range covering the entire model.\n\t */\n\tgetFullModelRange(): Range;\n\n\t/**\n\t * Returns if the model was disposed or not.\n\t */\n\tisDisposed(): boolean;\n\n\t/**\n\t * This model is so large that it would not be a good idea to sync it over\n\t * to web workers or other places.\n\t * @internal\n\t */\n\tisTooLargeForSyncing(): boolean;\n\n\t/**\n\t * The file is so large, that even tokenization is disabled.\n\t * @internal\n\t */\n\tisTooLargeForTokenization(): boolean;\n\n\t/**\n\t * The file is so large, that operations on it might be too large for heap\n\t * and can lead to OOM crashes so they should be disabled.\n\t * @internal\n\t */\n\tisTooLargeForHeapOperation(): boolean;\n\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if not matches have been found.\n\t */\n\tfindMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchScope Limit the searching to only search inside these ranges.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if no matches have been found.\n\t */\n\tfindMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];\n\t/**\n\t * Search the model for the next match. Loops to the beginning of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the next match is. It is null if no next match has been found.\n\t */\n\tfindNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\t/**\n\t * Search the model for the previous match. Loops to the end of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.\n\t * @param captureMatches The result will contain the captured groups.\n\t * @return The range where the previous match is. It is null if no previous match has been found.\n\t */\n\tfindPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;\n\n\n\t/**\n\t * Get the language associated with this model.\n\t */\n\tgetLanguageId(): string;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageId The new language.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageId: string, source?: string): void;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t * @param languageSelection The new language selection.\n\t * @param source The source of the call that set the language.\n\t * @internal\n\t */\n\tsetLanguage(languageSelection: ILanguageSelection, source?: string): void;\n\n\t/**\n\t * Returns the real (inner-most) language mode at a given position.\n\t * The result might be inaccurate. Use `forceTokenization` to ensure accurate tokens.\n\t * @internal\n\t */\n\tgetLanguageIdAtPosition(lineNumber: number, column: number): string;\n\n\t/**\n\t * Get the word under or besides `position`.\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Might be null.\n\t */\n\tgetWordAtPosition(position: IPosition): IWordAtPosition | null;\n\n\t/**\n\t * Get the word under or besides `position` trimmed to `position`.column\n\t * @param position The position to look for a word.\n\t * @return The word under or besides `position`. Will never be null.\n\t */\n\tgetWordUntilPosition(position: IPosition): IWordAtPosition;\n\n\t/**\n\t * Change the decorations. The callback will be called with a change accessor\n\t * that becomes invalid as soon as the callback finishes executing.\n\t * This allows for all events to be queued up until the change\n\t * is completed. Returns whatever the callback returns.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @internal\n\t */\n\tchangeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;\n\n\t/**\n\t * Perform a minimum amount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];\n\n\t/**\n\t * Remove all decorations that have been added with this specific ownerId.\n\t * @param ownerId The owner id to search for.\n\t * @internal\n\t */\n\tremoveAllDecorationsWithOwnerId(ownerId: number): void;\n\n\t/**\n\t * Get the options associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration options or null if the decoration was not found.\n\t */\n\tgetDecorationOptions(id: string): IModelDecorationOptions | null;\n\n\t/**\n\t * Get the range associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration range or null if the decoration was not found.\n\t */\n\tgetDecorationRange(id: string): Range | null;\n\n\t/**\n\t * Gets all the decorations for the line `lineNumber` as an array.\n\t * @param lineNumber The line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the font decorations for the line `lineNumber` as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @internal\n\t */\n\tgetFontDecorationsInRange(range: IRange, ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @return An array with the decorations\n\t */\n\tgetLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.\n\t * So for now it returns all the decorations on the same line as `range`.\n\t * @param range The range to search in\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t * @param onlyMinimapDecorations If set, it will return only decorations that render in the minimap.\n\t * @param onlyMarginDecorations If set, it will return only decorations that render in the glyph margin.\n\t * @return An array with the decorations\n\t */\n\tgetDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean, onlyMinimapDecorations?: boolean, onlyMarginDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all decorations that render in the glyph margin as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetAllMarginDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that should be rendered in the overview ruler as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @param filterFontDecorations If set, it will ignore font decorations.\n\t */\n\tgetOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean, filterFontDecorations?: boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain injected text.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetInjectedTextDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations that contain custom line heights.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t */\n\tgetCustomLineHeightsDecorations(ownerId?: number): IModelDecoration[];\n\n\t/**\n\t * @internal\n\t */\n\t_getTrackedRange(id: string): Range | null;\n\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: TrackedRangeStickiness): null;\n\t/**\n\t * @internal\n\t */\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: TrackedRangeStickiness): string;\n\n\t/**\n\t * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).\n\t */\n\tnormalizeIndentation(str: string): string;\n\n\t/**\n\t * Change the options of this model.\n\t */\n\tupdateOptions(newOpts: ITextModelUpdateOptions): void;\n\n\t/**\n\t * Detect the indentation options for this model from its content.\n\t */\n\tdetectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;\n\n\t/**\n\t * Close the current undo-redo element.\n\t * This offers a way to create an undo/redo stop point.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Open the current undo-redo element.\n\t * This offers a way to remove the current undo/redo stop point.\n\t */\n\tpopStackElement(): void;\n\n\t/**\n\t * @internal\n\t*/\n\tedit(edit: TextEdit, options?: { reason?: TextModelEditSource }): void;\n\n\t/**\n\t * Push edit operations, basically editing the model. This is the preferred way\n\t * of editing the model. The edit operations will land on the undo stack.\n\t * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when `undo` or `redo` are invoked.\n\t * @param editOperations The edit operations.\n\t * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.\n\t * @return The cursor state returned by the `cursorStateComputer`.\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;\n\t/**\n\t * @internal\n\t */\n\tpushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null;\n\n\t/**\n\t * Change the end of line sequence. This is the preferred way of\n\t * changing the eol sequence. This will land on the undo stack.\n\t */\n\tpushEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * Edit the model without adding the edits to the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.\n\t * @param operations The edit operations.\n\t * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.\n\t */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[]): void;\n\t/** @internal */\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], reason: TextModelEditSource): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tapplyEdits(operations: readonly IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];\n\n\t/**\n\t * Change the end of line sequence without recording in the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.\n\t */\n\tsetEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyUndo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * @internal\n\t */\n\t_applyRedo(changes: TextChange[], eol: EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;\n\n\t/**\n\t * Undo edit operations until the previous undo/redo point.\n\t * The inverse edit operations will be pushed on the redo stack.\n\t */\n\tundo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the undo stack?\n\t */\n\tcanUndo(): boolean;\n\n\t/**\n\t * Redo edit operations until the next undo/redo point.\n\t * The inverse edit operations will be pushed on the undo stack.\n\t */\n\tredo(): void | Promise<void>;\n\n\t/**\n\t * Is there anything in the redo stack?\n\t */\n\tcanRedo(): boolean;\n\n\t/**\n\t * @deprecated Please use `onDidChangeContent` instead.\n\t * An event emitted when the contents of the model have changed.\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeContentOrInjectedText: Event<InternalModelContentChangeEvent | ModelInjectedTextChangedEvent>;\n\t/**\n\t * An event emitted when the contents of the model have changed.\n\t * @event\n\t */\n\tonDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;\n\t/**\n\t * An event emitted when decorations of the model have changed.\n\t * @event\n\t */\n\treadonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;\n\t/**\n\t * An event emitted when line heights from decorations changes.\n\t * This event is emitted only when adding, removing or changing a decoration\n\t * and not when doing edits in the model (i.e. when decoration ranges change)\n\t * @internal\n\t * @event\n\t */\n\treadonly onDidChangeLineHeight: Event<ModelLineHeightChangedEvent>;\n\t/**\n\t* An event emitted when the font from decorations changes.\n\t* This event is emitted only when adding, removing or changing a decoration\n\t* and not when doing edits in the model (i.e. when decoration ranges change)\n\t* @internal\n\t* @event\n\t*/\n\treadonly onDidChangeFont: Event<ModelFontChangedEvent>;\n\t/**\n\t * An event emitted when the model options have changed.\n\t * @event\n\t */\n\treadonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;\n\t/**\n\t * An event emitted when the language associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\t/**\n\t * An event emitted when the language configuration associated with the model has changed.\n\t * @event\n\t */\n\treadonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\t/**\n\t * An event emitted when the tokens associated with the model have changed.\n\t * @event\n\t * @internal\n\t */\n\treadonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\t/**\n\t * An event emitted when the model has been attached to the first editor or detached from the last editor.\n\t * @event\n\t */\n\treadonly onDidChangeAttached: Event<void>;\n\t/**\n\t * An event emitted right before disposing the model.\n\t * @event\n\t */\n\treadonly onWillDispose: Event<void>;\n\n\t/**\n\t * Destroy this model.\n\t */\n\tdispose(): void;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeAttached(): IAttachedView;\n\n\t/**\n\t * @internal\n\t */\n\tonBeforeDetached(view: IAttachedView): void;\n\n\t/**\n\t * Returns if this model is attached to an editor or not.\n\t */\n\tisAttachedToEditor(): boolean;\n\n\t/**\n\t * Returns the count of editors this model is attached to.\n\t * @internal\n\t */\n\tgetAttachedEditorCount(): number;\n\n\t/**\n\t * Among all positions that are projected to the same position in the underlying text model as\n\t * the given position, select a unique position as indicated by the affinity.\n\t *\n\t * PositionAffinity.Left:\n\t * The normalized position must be equal or left to the requested position.\n\t *\n\t * PositionAffinity.Right:\n\t * The normalized position must be equal or right to the requested position.\n\t *\n\t * @internal\n\t */\n\tnormalizePosition(position: Position, affinity: PositionAffinity): Position;\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tgetLineIndentColumn(lineNumber: number): number;\n\n\t/**\n\t * Returns an object that can be used to query brackets.\n\t * @internal\n\t*/\n\treadonly bracketPairs: IBracketPairsTextModelPart;\n\n\t/**\n\t * Returns an object that can be used to query indent guides.\n\t * @internal\n\t*/\n\treadonly guides: IGuidesTextModelPart;\n\n\t/**\n\t * @internal\n\t */\n\treadonly tokenization: ITokenizationTextModelPart;\n}\n\n/**\n * @internal\n */\nexport function isITextModel(obj: IEditorModel): obj is ITextModel {\n\treturn Boolean(obj && (obj as ITextModel).uri);\n}\n\n/**\n * @internal\n */\nexport interface IAttachedView {\n\t/**\n\t * @param stabilized Indicates if the visible lines are probably going to change soon or can be considered stable.\n\t * Is true on reveal range and false on scroll.\n\t * Tokenizers should tokenize synchronously if stabilized is true.\n\t */\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void;\n}\n\nexport const enum PositionAffinity {\n\t/**\n\t * Prefers the left most position.\n\t*/\n\tLeft = 0,\n\n\t/**\n\t * Prefers the right most position.\n\t*/\n\tRight = 1,\n\n\t/**\n\t * No preference.\n\t*/\n\tNone = 2,\n\n\t/**\n\t * If the given position is on injected text, prefers the position left of it.\n\t*/\n\tLeftOfInjectedText = 3,\n\n\t/**\n\t * If the given position is on injected text, prefers the position right of it.\n\t*/\n\tRightOfInjectedText = 4,\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferBuilder {\n\tacceptChunk(chunk: string): void;\n\tfinish(): ITextBufferFactory;\n}\n\n/**\n * @internal\n */\nexport interface ITextBufferFactory {\n\tcreate(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable };\n\tgetFirstLineText(lengthLimit: number): string;\n}\n\n/**\n * @internal\n */\nexport const enum ModelConstants {\n\tFIRST_LINE_DETECTION_LENGTH_LIMIT = 1000\n}\n\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {\n\tconstructor(\n\t\tpublic readonly identifier: ISingleEditOperationIdentifier | null,\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string | null,\n\t\tpublic readonly forceMoveMarkers: boolean,\n\t\tpublic readonly isAutoWhitespaceEdit: boolean,\n\t\tpublic readonly _isTracked: boolean,\n\t) { }\n}\n\n/**\n * @internal\n *\n * `lineNumber` is 1 based.\n */\nexport interface IReadonlyTextBuffer {\n\tonDidChangeContent: Event<void>;\n\tequals(other: ITextBuffer): boolean;\n\tmightContainRTL(): boolean;\n\tmightContainUnusualLineTerminators(): boolean;\n\tresetMightContainUnusualLineTerminators(): void;\n\tmightContainNonBasicASCII(): boolean;\n\tgetBOM(): string;\n\tgetEOL(): string;\n\n\tgetOffsetAt(lineNumber: number, column: number): number;\n\tgetPositionAt(offset: number): Position;\n\tgetRangeAt(offset: number, length: number): Range;\n\n\tgetValueInRange(range: Range, eol: EndOfLinePreference): string;\n\tcreateSnapshot(preserveBOM: boolean): ITextSnapshot;\n\tgetValueLengthInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;\n\tgetLength(): number;\n\tgetLineCount(): number;\n\tgetLinesContent(): string[];\n\tgetLineContent(lineNumber: number): string;\n\tgetLineCharCode(lineNumber: number, index: number): number;\n\tgetCharCode(offset: number): number;\n\tgetLineLength(lineNumber: number): number;\n\tgetLineMinColumn(lineNumber: number): number;\n\tgetLineMaxColumn(lineNumber: number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber: number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber: number): number;\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];\n\n\t/**\n\t * Get nearest chunk of text after `offset` in the text buffer.\n\t */\n\tgetNearestChunk(offset: number): string;\n}\n\n/**\n * @internal\n */\nexport class SearchData {\n\n\t/**\n\t * The regex to search for. Always defined.\n\t */\n\tpublic readonly regex: RegExp;\n\t/**\n\t * The word separator classifier.\n\t */\n\tpublic readonly wordSeparators: WordCharacterClassifier | null;\n\t/**\n\t * The simple string to search for (if possible).\n\t */\n\tpublic readonly simpleSearch: string | null;\n\n\tconstructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null) {\n\t\tthis.regex = regex;\n\t\tthis.wordSeparators = wordSeparators;\n\t\tthis.simpleSearch = simpleSearch;\n\t}\n}\n\n/**\n * @internal\n */\nexport interface ITextBuffer extends IReadonlyTextBuffer, IDisposable {\n\tsetEOL(newEOL: '\\r\\n' | '\\n'): void;\n\tapplyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;\n}\n\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n\n\tconstructor(\n\t\tpublic readonly reverseEdits: IValidEditOperation[] | null,\n\t\tpublic readonly changes: IInternalModelContentChange[],\n\t\tpublic readonly trimAutoWhitespaceLineNumbers: number[] | null\n\t) { }\n\n}\n\n/**\n * @internal\n */\nexport interface IInternalModelContentChange extends IModelContentChange {\n\trange: Range;\n\tforceMoveMarkers: boolean;\n}\n\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model: ITextModel): boolean {\n\treturn (\n\t\t!model.isTooLargeForSyncing() && !model.isForSimpleWidget\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { EndOfLinePreference, FindMatch, SearchData } from '../model.js';\nimport { TextModel } from './textModel.js';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tconst lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { EndOfLinePreference, FindMatch, SearchData } from '../model.js';\nimport { TextModel } from './textModel.js';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tconst lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function setDefaultGetWordAtTextConfig(value: IGetWordAtTextConfig) {\n\tconst rm = _defaultConfig.unshift(value);\n\treturn toDisposable(rm);\n}\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\t// Ensure the regex has the 'g' flag, otherwise this will loop forever\n\twordDefinition = ensureValidWordDefinition(wordDefinition);\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index,\n\t\t\tendColumn: textOffset + 1 + match.index + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function setDefaultGetWordAtTextConfig(value: IGetWordAtTextConfig) {\n\tconst rm = _defaultConfig.unshift(value);\n\treturn toDisposable(rm);\n}\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\t// Ensure the regex has the 'g' flag, otherwise this will loop forever\n\twordDefinition = ensureValidWordDefinition(wordDefinition);\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index,\n\t\t\tendColumn: textOffset + 1 + match.index + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IUnicodeHighlightsResult } from './editorWorker.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\n\nexport class UnicodeTextModelHighlighter {\n\tpublic static computeUnicodeHighlights(model: IUnicodeCharacterSearcherTarget, options: UnicodeHighlighterOptions, range?: IRange): IUnicodeHighlightsResult {\n\t\tconst startLine = range ? range.startLineNumber : 1;\n\t\tconst endLine = range ? range.endLineNumber : model.getLineCount();\n\n\t\tconst codePointHighlighter = new CodePointHighlighter(options);\n\n\t\tconst candidates = codePointHighlighter.getCandidateCodePoints();\n\t\tlet regex: RegExp;\n\t\tif (candidates === 'allNonBasicAscii') {\n\t\t\tregex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n\t\t} else {\n\t\t\tregex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n\t\t}\n\n\t\tconst searcher = new Searcher(null, regex);\n\t\tconst ranges: Range[] = [];\n\t\tlet hasMore = false;\n\t\tlet m: RegExpExecArray | null;\n\n\t\tlet ambiguousCharacterCount = 0;\n\t\tlet invisibleCharacterCount = 0;\n\t\tlet nonBasicAsciiCharacterCount = 0;\n\n\t\tforLoop:\n\t\tfor (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineLength = lineContent.length;\n\n\t\t\t// Reset regex to search from the beginning\n\t\t\tsearcher.reset(0);\n\t\t\tdo {\n\t\t\t\tm = searcher.next(lineContent);\n\t\t\t\tif (m) {\n\t\t\t\t\tlet startIndex = m.index;\n\t\t\t\t\tlet endIndex = m.index + m[0].length;\n\n\t\t\t\t\t// Extend range to entire code point\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n\t\t\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\t\t\tstartIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (endIndex + 1 < lineLength) {\n\t\t\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n\t\t\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\t\t\tendIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst str = lineContent.substring(startIndex, endIndex);\n\t\t\t\t\tlet word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n\t\t\t\t\tif (word && word.endColumn <= startIndex + 1) {\n\t\t\t\t\t\t// The word does not include the problematic character, ignore the word\n\t\t\t\t\t\tword = null;\n\t\t\t\t\t}\n\t\t\t\t\tconst highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n\n\t\t\t\t\tif (highlightReason !== SimpleHighlightReason.None) {\n\t\t\t\t\t\tif (highlightReason === SimpleHighlightReason.Ambiguous) {\n\t\t\t\t\t\t\tambiguousCharacterCount++;\n\t\t\t\t\t\t} else if (highlightReason === SimpleHighlightReason.Invisible) {\n\t\t\t\t\t\t\tinvisibleCharacterCount++;\n\t\t\t\t\t\t} else if (highlightReason === SimpleHighlightReason.NonBasicASCII) {\n\t\t\t\t\t\t\tnonBasicAsciiCharacterCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassertNever(highlightReason);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst MAX_RESULT_LENGTH = 1000;\n\t\t\t\t\t\tif (ranges.length >= MAX_RESULT_LENGTH) {\n\t\t\t\t\t\t\thasMore = true;\n\t\t\t\t\t\t\tbreak forLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (m);\n\t\t}\n\t\treturn {\n\t\t\tranges,\n\t\t\thasMore,\n\t\t\tambiguousCharacterCount,\n\t\t\tinvisibleCharacterCount,\n\t\t\tnonBasicAsciiCharacterCount\n\t\t};\n\t}\n\n\tpublic static computeUnicodeHighlightReason(char: string, options: UnicodeHighlighterOptions): UnicodeHighlighterReason | null {\n\t\tconst codePointHighlighter = new CodePointHighlighter(options);\n\n\t\tconst reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n\t\tswitch (reason) {\n\t\t\tcase SimpleHighlightReason.None:\n\t\t\t\treturn null;\n\t\t\tcase SimpleHighlightReason.Invisible:\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.Invisible };\n\n\t\t\tcase SimpleHighlightReason.Ambiguous: {\n\t\t\t\tconst codePoint = char.codePointAt(0)!;\n\t\t\t\tconst primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint)!;\n\t\t\t\tconst notAmbiguousInLocales =\n\t\t\t\t\tstrings.AmbiguousCharacters.getLocales().filter(\n\t\t\t\t\t\t(l) =>\n\t\t\t\t\t\t\t!strings.AmbiguousCharacters.getInstance(\n\t\t\t\t\t\t\t\tnew Set([...options.allowedLocales, l])\n\t\t\t\t\t\t\t).isAmbiguous(codePoint)\n\t\t\t\t\t);\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.Ambiguous, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n\t\t\t}\n\t\t\tcase SimpleHighlightReason.NonBasicASCII:\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.NonBasicAscii };\n\t\t}\n\t}\n}\n\nfunction buildRegExpCharClassExpr(codePoints: number[], flags?: string): string {\n\tconst src = `[${strings.escapeRegExpCharacters(\n\t\tcodePoints.map((i) => String.fromCodePoint(i)).join('')\n\t)}]`;\n\treturn src;\n}\n\nexport const enum UnicodeHighlighterReasonKind {\n\tAmbiguous, Invisible, NonBasicAscii\n}\n\nexport type UnicodeHighlighterReason = {\n\tkind: UnicodeHighlighterReasonKind.Ambiguous;\n\tconfusableWith: string;\n\tnotAmbiguousInLocales: string[];\n} | {\n\tkind: UnicodeHighlighterReasonKind.Invisible;\n} | {\n\tkind: UnicodeHighlighterReasonKind.NonBasicAscii;\n};\n\nclass CodePointHighlighter {\n\tprivate readonly allowedCodePoints: Set<number>;\n\tpublic readonly ambiguousCharacters: strings.AmbiguousCharacters;\n\tconstructor(private readonly options: UnicodeHighlighterOptions) {\n\t\tthis.allowedCodePoints = new Set(options.allowedCodePoints);\n\t\tthis.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n\t}\n\n\tpublic getCandidateCodePoints(): Set<number> | 'allNonBasicAscii' {\n\t\tif (this.options.nonBasicASCII) {\n\t\t\treturn 'allNonBasicAscii';\n\t\t}\n\n\t\tconst set = new Set<number>();\n\n\t\tif (this.options.invisibleCharacters) {\n\t\t\tfor (const cp of strings.InvisibleCharacters.codePoints) {\n\t\t\t\tif (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n\t\t\t\t\tset.add(cp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.options.ambiguousCharacters) {\n\t\t\tfor (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n\t\t\t\tset.add(cp);\n\t\t\t}\n\t\t}\n\n\t\tfor (const cp of this.allowedCodePoints) {\n\t\t\tset.delete(cp);\n\t\t}\n\n\t\treturn set;\n\t}\n\n\tpublic shouldHighlightNonBasicASCII(character: string, wordContext: string | null): SimpleHighlightReason {\n\t\tconst codePoint = character.codePointAt(0)!;\n\n\t\tif (this.allowedCodePoints.has(codePoint)) {\n\t\t\treturn SimpleHighlightReason.None;\n\t\t}\n\n\t\tif (this.options.nonBasicASCII) {\n\t\t\treturn SimpleHighlightReason.NonBasicASCII;\n\t\t}\n\n\t\tlet hasBasicASCIICharacters = false;\n\t\tlet hasNonConfusableNonBasicAsciiCharacter = false;\n\t\tif (wordContext) {\n\t\t\tfor (const char of wordContext) {\n\t\t\t\tconst codePoint = char.codePointAt(0)!;\n\t\t\t\tconst isBasicASCII = strings.isBasicASCII(char);\n\t\t\t\thasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n\n\t\t\t\tif (\n\t\t\t\t\t!isBasicASCII &&\n\t\t\t\t\t!this.ambiguousCharacters.isAmbiguous(codePoint) &&\n\t\t\t\t\t!strings.InvisibleCharacters.isInvisibleCharacter(codePoint)\n\t\t\t\t) {\n\t\t\t\t\thasNonConfusableNonBasicAsciiCharacter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t/* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n\t\t\t/* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter\n\t\t) {\n\t\t\treturn SimpleHighlightReason.None;\n\t\t}\n\n\t\tif (this.options.invisibleCharacters) {\n\t\t\t// TODO check for emojis\n\t\t\tif (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n\t\t\t\treturn SimpleHighlightReason.Invisible;\n\t\t\t}\n\t\t}\n\n\t\tif (this.options.ambiguousCharacters) {\n\t\t\tif (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n\t\t\t\treturn SimpleHighlightReason.Ambiguous;\n\t\t\t}\n\t\t}\n\n\t\treturn SimpleHighlightReason.None;\n\t}\n}\n\nfunction isAllowedInvisibleCharacter(character: string): boolean {\n\treturn character === ' ' || character === '\\n' || character === '\\t';\n}\n\nconst enum SimpleHighlightReason {\n\tNone,\n\tNonBasicASCII,\n\tInvisible,\n\tAmbiguous\n}\n\nexport interface IUnicodeCharacterSearcherTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface UnicodeHighlighterOptions {\n\tnonBasicASCII: boolean;\n\tambiguousCharacters: boolean;\n\tinvisibleCharacters: boolean;\n\tincludeComments: boolean;\n\tincludeStrings: boolean;\n\tallowedCodePoints: number[];\n\tallowedLocales: string[];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange, Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IUnicodeHighlightsResult } from './editorWorker.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\n\nexport class UnicodeTextModelHighlighter {\n\tpublic static computeUnicodeHighlights(model: IUnicodeCharacterSearcherTarget, options: UnicodeHighlighterOptions, range?: IRange): IUnicodeHighlightsResult {\n\t\tconst startLine = range ? range.startLineNumber : 1;\n\t\tconst endLine = range ? range.endLineNumber : model.getLineCount();\n\n\t\tconst codePointHighlighter = new CodePointHighlighter(options);\n\n\t\tconst candidates = codePointHighlighter.getCandidateCodePoints();\n\t\tlet regex: RegExp;\n\t\tif (candidates === 'allNonBasicAscii') {\n\t\t\tregex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n\t\t} else {\n\t\t\tregex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n\t\t}\n\n\t\tconst searcher = new Searcher(null, regex);\n\t\tconst ranges: Range[] = [];\n\t\tlet hasMore = false;\n\t\tlet m: RegExpExecArray | null;\n\n\t\tlet ambiguousCharacterCount = 0;\n\t\tlet invisibleCharacterCount = 0;\n\t\tlet nonBasicAsciiCharacterCount = 0;\n\n\t\tforLoop:\n\t\tfor (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst lineLength = lineContent.length;\n\n\t\t\t// Reset regex to search from the beginning\n\t\t\tsearcher.reset(0);\n\t\t\tdo {\n\t\t\t\tm = searcher.next(lineContent);\n\t\t\t\tif (m) {\n\t\t\t\t\tlet startIndex = m.index;\n\t\t\t\t\tlet endIndex = m.index + m[0].length;\n\n\t\t\t\t\t// Extend range to entire code point\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n\t\t\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\t\t\tstartIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (endIndex + 1 < lineLength) {\n\t\t\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n\t\t\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\t\t\tendIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst str = lineContent.substring(startIndex, endIndex);\n\t\t\t\t\tlet word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n\t\t\t\t\tif (word && word.endColumn <= startIndex + 1) {\n\t\t\t\t\t\t// The word does not include the problematic character, ignore the word\n\t\t\t\t\t\tword = null;\n\t\t\t\t\t}\n\t\t\t\t\tconst highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n\n\t\t\t\t\tif (highlightReason !== SimpleHighlightReason.None) {\n\t\t\t\t\t\tif (highlightReason === SimpleHighlightReason.Ambiguous) {\n\t\t\t\t\t\t\tambiguousCharacterCount++;\n\t\t\t\t\t\t} else if (highlightReason === SimpleHighlightReason.Invisible) {\n\t\t\t\t\t\t\tinvisibleCharacterCount++;\n\t\t\t\t\t\t} else if (highlightReason === SimpleHighlightReason.NonBasicASCII) {\n\t\t\t\t\t\t\tnonBasicAsciiCharacterCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassertNever(highlightReason);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst MAX_RESULT_LENGTH = 1000;\n\t\t\t\t\t\tif (ranges.length >= MAX_RESULT_LENGTH) {\n\t\t\t\t\t\t\thasMore = true;\n\t\t\t\t\t\t\tbreak forLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (m);\n\t\t}\n\t\treturn {\n\t\t\tranges,\n\t\t\thasMore,\n\t\t\tambiguousCharacterCount,\n\t\t\tinvisibleCharacterCount,\n\t\t\tnonBasicAsciiCharacterCount\n\t\t};\n\t}\n\n\tpublic static computeUnicodeHighlightReason(char: string, options: UnicodeHighlighterOptions): UnicodeHighlighterReason | null {\n\t\tconst codePointHighlighter = new CodePointHighlighter(options);\n\n\t\tconst reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n\t\tswitch (reason) {\n\t\t\tcase SimpleHighlightReason.None:\n\t\t\t\treturn null;\n\t\t\tcase SimpleHighlightReason.Invisible:\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.Invisible };\n\n\t\t\tcase SimpleHighlightReason.Ambiguous: {\n\t\t\t\tconst codePoint = char.codePointAt(0)!;\n\t\t\t\tconst primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint)!;\n\t\t\t\tconst notAmbiguousInLocales =\n\t\t\t\t\tstrings.AmbiguousCharacters.getLocales().filter(\n\t\t\t\t\t\t(l) =>\n\t\t\t\t\t\t\t!strings.AmbiguousCharacters.getInstance(\n\t\t\t\t\t\t\t\tnew Set([...options.allowedLocales, l])\n\t\t\t\t\t\t\t).isAmbiguous(codePoint)\n\t\t\t\t\t);\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.Ambiguous, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n\t\t\t}\n\t\t\tcase SimpleHighlightReason.NonBasicASCII:\n\t\t\t\treturn { kind: UnicodeHighlighterReasonKind.NonBasicAscii };\n\t\t}\n\t}\n}\n\nfunction buildRegExpCharClassExpr(codePoints: number[], flags?: string): string {\n\tconst src = `[${strings.escapeRegExpCharacters(\n\t\tcodePoints.map((i) => String.fromCodePoint(i)).join('')\n\t)}]`;\n\treturn src;\n}\n\nexport const enum UnicodeHighlighterReasonKind {\n\tAmbiguous, Invisible, NonBasicAscii\n}\n\nexport type UnicodeHighlighterReason = {\n\tkind: UnicodeHighlighterReasonKind.Ambiguous;\n\tconfusableWith: string;\n\tnotAmbiguousInLocales: string[];\n} | {\n\tkind: UnicodeHighlighterReasonKind.Invisible;\n} | {\n\tkind: UnicodeHighlighterReasonKind.NonBasicAscii;\n};\n\nclass CodePointHighlighter {\n\tprivate readonly allowedCodePoints: Set<number>;\n\tpublic readonly ambiguousCharacters: strings.AmbiguousCharacters;\n\tconstructor(private readonly options: UnicodeHighlighterOptions) {\n\t\tthis.allowedCodePoints = new Set(options.allowedCodePoints);\n\t\tthis.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n\t}\n\n\tpublic getCandidateCodePoints(): Set<number> | 'allNonBasicAscii' {\n\t\tif (this.options.nonBasicASCII) {\n\t\t\treturn 'allNonBasicAscii';\n\t\t}\n\n\t\tconst set = new Set<number>();\n\n\t\tif (this.options.invisibleCharacters) {\n\t\t\tfor (const cp of strings.InvisibleCharacters.codePoints) {\n\t\t\t\tif (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n\t\t\t\t\tset.add(cp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.options.ambiguousCharacters) {\n\t\t\tfor (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n\t\t\t\tset.add(cp);\n\t\t\t}\n\t\t}\n\n\t\tfor (const cp of this.allowedCodePoints) {\n\t\t\tset.delete(cp);\n\t\t}\n\n\t\treturn set;\n\t}\n\n\tpublic shouldHighlightNonBasicASCII(character: string, wordContext: string | null): SimpleHighlightReason {\n\t\tconst codePoint = character.codePointAt(0)!;\n\n\t\tif (this.allowedCodePoints.has(codePoint)) {\n\t\t\treturn SimpleHighlightReason.None;\n\t\t}\n\n\t\tif (this.options.nonBasicASCII) {\n\t\t\treturn SimpleHighlightReason.NonBasicASCII;\n\t\t}\n\n\t\tlet hasBasicASCIICharacters = false;\n\t\tlet hasNonConfusableNonBasicAsciiCharacter = false;\n\t\tif (wordContext) {\n\t\t\tfor (const char of wordContext) {\n\t\t\t\tconst codePoint = char.codePointAt(0)!;\n\t\t\t\tconst isBasicASCII = strings.isBasicASCII(char);\n\t\t\t\thasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n\n\t\t\t\tif (\n\t\t\t\t\t!isBasicASCII &&\n\t\t\t\t\t!this.ambiguousCharacters.isAmbiguous(codePoint) &&\n\t\t\t\t\t!strings.InvisibleCharacters.isInvisibleCharacter(codePoint)\n\t\t\t\t) {\n\t\t\t\t\thasNonConfusableNonBasicAsciiCharacter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t/* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n\t\t\t/* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter\n\t\t) {\n\t\t\treturn SimpleHighlightReason.None;\n\t\t}\n\n\t\tif (this.options.invisibleCharacters) {\n\t\t\t// TODO check for emojis\n\t\t\tif (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n\t\t\t\treturn SimpleHighlightReason.Invisible;\n\t\t\t}\n\t\t}\n\n\t\tif (this.options.ambiguousCharacters) {\n\t\t\tif (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n\t\t\t\treturn SimpleHighlightReason.Ambiguous;\n\t\t\t}\n\t\t}\n\n\t\treturn SimpleHighlightReason.None;\n\t}\n}\n\nfunction isAllowedInvisibleCharacter(character: string): boolean {\n\treturn character === ' ' || character === '\\n' || character === '\\t';\n}\n\nconst enum SimpleHighlightReason {\n\tNone,\n\tNonBasicASCII,\n\tInvisible,\n\tAmbiguous\n}\n\nexport interface IUnicodeCharacterSearcherTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface UnicodeHighlighterOptions {\n\tnonBasicASCII: boolean;\n\tambiguousCharacters: boolean;\n\tinvisibleCharacters: boolean;\n\tincludeComments: boolean;\n\tincludeStrings: boolean;\n\tallowedCodePoints: number[];\n\tallowedLocales: string[];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DetailedLineRangeMapping, LineRangeMapping } from './rangeMapping.js';\n\nexport interface ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff;\n}\n\nexport interface ILinesDiffComputerOptions {\n\treadonly ignoreTrimWhitespace: boolean;\n\treadonly maxComputationTimeMs: number;\n\treadonly computeMoves: boolean;\n\treadonly extendToSubwords?: boolean;\n}\n\nexport class LinesDiff {\n\tconstructor(\n\t\treadonly changes: readonly DetailedLineRangeMapping[],\n\n\t\t/**\n\t\t * Sorted by original line ranges.\n\t\t * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n\t\t */\n\t\treadonly moves: readonly MovedText[],\n\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\treadonly hitTimeout: boolean,\n\t) {\n\t}\n}\n\nexport class MovedText {\n\tpublic readonly lineRangeMapping: LineRangeMapping;\n\n\t/**\n\t * The diff from the original text to the moved text.\n\t * Must be contained in the original/modified line range.\n\t * Can be empty if the text didn't change (only moved).\n\t */\n\tpublic readonly changes: readonly DetailedLineRangeMapping[];\n\n\tconstructor(\n\t\tlineRangeMapping: LineRangeMapping,\n\t\tchanges: readonly DetailedLineRangeMapping[],\n\t) {\n\t\tthis.lineRangeMapping = lineRangeMapping;\n\t\tthis.changes = changes;\n\t}\n\n\tpublic flip(): MovedText {\n\t\treturn new MovedText(this.lineRangeMapping.flip(), this.changes.map(c => c.flip()));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DetailedLineRangeMapping, LineRangeMapping } from './rangeMapping.js';\n\nexport interface ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff;\n}\n\nexport interface ILinesDiffComputerOptions {\n\treadonly ignoreTrimWhitespace: boolean;\n\treadonly maxComputationTimeMs: number;\n\treadonly computeMoves: boolean;\n\treadonly extendToSubwords?: boolean;\n}\n\nexport class LinesDiff {\n\tconstructor(\n\t\treadonly changes: readonly DetailedLineRangeMapping[],\n\n\t\t/**\n\t\t * Sorted by original line ranges.\n\t\t * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n\t\t */\n\t\treadonly moves: readonly MovedText[],\n\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\treadonly hitTimeout: boolean,\n\t) {\n\t}\n}\n\nexport class MovedText {\n\tpublic readonly lineRangeMapping: LineRangeMapping;\n\n\t/**\n\t * The diff from the original text to the moved text.\n\t * Must be contained in the original/modified line range.\n\t * Can be empty if the text didn't change (only moved).\n\t */\n\tpublic readonly changes: readonly DetailedLineRangeMapping[];\n\n\tconstructor(\n\t\tlineRangeMapping: LineRangeMapping,\n\t\tchanges: readonly DetailedLineRangeMapping[],\n\t) {\n\t\tthis.lineRangeMapping = lineRangeMapping;\n\t\tthis.changes = changes;\n\t}\n\n\tpublic flip(): MovedText {\n\t\treturn new MovedText(this.lineRangeMapping.flip(), this.changes.map(c => c.flip()));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\n\nexport interface IOffsetRange {\n\treadonly start: number;\n\treadonly endExclusive: number;\n}\n\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange implements IOffsetRange {\n\tpublic static fromTo(start: number, endExclusive: number): OffsetRange {\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static addRange(range: OffsetRange, sortedRanges: OffsetRange[]): void {\n\t\tlet i = 0;\n\t\twhile (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tsortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n\t\t\tsortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic static tryCreate(start: number, endExclusive: number): OffsetRange | undefined {\n\t\tif (start > endExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static ofLength(length: number): OffsetRange {\n\t\treturn new OffsetRange(0, length);\n\t}\n\n\tpublic static ofStartAndLength(start: number, length: number): OffsetRange {\n\t\treturn new OffsetRange(start, start + length);\n\t}\n\n\tpublic static emptyAt(offset: number): OffsetRange {\n\t\treturn new OffsetRange(offset, offset);\n\t}\n\n\tconstructor(public readonly start: number, public readonly endExclusive: number) {\n\t\tif (start > endExclusive) {\n\t\t\tthrow new BugIndicatingError(`Invalid range: ${this.toString()}`);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.start === this.endExclusive;\n\t}\n\n\tpublic delta(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive + offset);\n\t}\n\n\tpublic deltaStart(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive);\n\t}\n\n\tpublic deltaEnd(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start, this.endExclusive + offset);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.endExclusive - this.start;\n\t}\n\n\tpublic toString() {\n\t\treturn `[${this.start}, ${this.endExclusive})`;\n\t}\n\n\tpublic equals(other: OffsetRange): boolean {\n\t\treturn this.start === other.start && this.endExclusive === other.endExclusive;\n\t}\n\n\tpublic containsRange(other: OffsetRange): boolean {\n\t\treturn this.start <= other.start && other.endExclusive <= this.endExclusive;\n\t}\n\n\tpublic contains(offset: number): boolean {\n\t\treturn this.start <= offset && offset < this.endExclusive;\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n\t * The joined range is the smallest range that contains both ranges.\n\t */\n\tpublic join(other: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n\t *\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: OffsetRange): OffsetRange | undefined {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\tif (start <= end) {\n\t\t\treturn new OffsetRange(start, end);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectionLength(range: OffsetRange): number {\n\t\tconst start = Math.max(this.start, range.start);\n\t\tconst end = Math.min(this.endExclusive, range.endExclusive);\n\t\treturn Math.max(0, end - start);\n\t}\n\n\tpublic intersects(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start < end;\n\t}\n\n\tpublic intersectsOrTouches(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start <= end;\n\t}\n\n\tpublic isBefore(other: OffsetRange): boolean {\n\t\treturn this.endExclusive <= other.start;\n\t}\n\n\tpublic isAfter(other: OffsetRange): boolean {\n\t\treturn this.start >= other.endExclusive;\n\t}\n\n\tpublic slice<T>(arr: readonly T[]): T[] {\n\t\treturn arr.slice(this.start, this.endExclusive);\n\t}\n\n\tpublic substring(str: string): string {\n\t\treturn str.substring(this.start, this.endExclusive);\n\t}\n\n\t/**\n\t * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n\t * The range must not be empty.\n\t */\n\tpublic clip(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\treturn Math.max(this.start, Math.min(this.endExclusive - 1, value));\n\t}\n\n\t/**\n\t * Returns `r := value + k * length` such that `r` is contained in this range.\n\t * The range must not be empty.\n\t *\n\t * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n\t */\n\tpublic clipCyclic(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\tif (value < this.start) {\n\t\t\treturn this.endExclusive - ((this.start - value) % this.length);\n\t\t}\n\t\tif (value >= this.endExclusive) {\n\t\t\treturn this.start + ((value - this.start) % this.length);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic map<T>(f: (offset: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tresult.push(f(i));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (offset: number) => void): void {\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tf(i);\n\t\t}\n\t}\n\n\t/**\n\t * this: [ 5, 10), range: [10, 15) => [5, 15)]\n\t * Throws if the ranges are not touching.\n\t*/\n\tpublic joinRightTouching(range: OffsetRange): OffsetRange {\n\t\tif (this.endExclusive !== range.start) {\n\t\t\tthrow new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);\n\t\t}\n\t\treturn new OffsetRange(this.start, range.endExclusive);\n\t}\n}\n\nexport class OffsetRangeSet {\n\tprivate readonly _sortedRanges: OffsetRange[] = [];\n\n\tpublic get ranges(): OffsetRange[] {\n\t\treturn [...this._sortedRanges];\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tthis._sortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n\t\t\tthis._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._sortedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\t/**\n\t * Returns of there is a value that is contained in this instance and the given range.\n\t */\n\tpublic intersectsStrict(other: OffsetRange): boolean {\n\t\t// TODO use binary search\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n\t\t\ti++;\n\t\t}\n\t\treturn i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n\t}\n\n\tpublic intersectWithRange(other: OffsetRange): OffsetRangeSet {\n\t\t// TODO use binary search + slice\n\t\tconst result = new OffsetRangeSet();\n\t\tfor (const range of this._sortedRanges) {\n\t\t\tconst intersection = range.intersect(other);\n\t\t\tif (intersection) {\n\t\t\t\tresult.addRange(intersection);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic intersectWithRangeLength(other: OffsetRange): number {\n\t\treturn this.intersectWithRange(other).length;\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\n\nexport interface IOffsetRange {\n\treadonly start: number;\n\treadonly endExclusive: number;\n}\n\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange implements IOffsetRange {\n\tpublic static fromTo(start: number, endExclusive: number): OffsetRange {\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static addRange(range: OffsetRange, sortedRanges: OffsetRange[]): void {\n\t\tlet i = 0;\n\t\twhile (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tsortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n\t\t\tsortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic static tryCreate(start: number, endExclusive: number): OffsetRange | undefined {\n\t\tif (start > endExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static ofLength(length: number): OffsetRange {\n\t\treturn new OffsetRange(0, length);\n\t}\n\n\tpublic static ofStartAndLength(start: number, length: number): OffsetRange {\n\t\treturn new OffsetRange(start, start + length);\n\t}\n\n\tpublic static emptyAt(offset: number): OffsetRange {\n\t\treturn new OffsetRange(offset, offset);\n\t}\n\n\tconstructor(public readonly start: number, public readonly endExclusive: number) {\n\t\tif (start > endExclusive) {\n\t\t\tthrow new BugIndicatingError(`Invalid range: ${this.toString()}`);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.start === this.endExclusive;\n\t}\n\n\tpublic delta(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive + offset);\n\t}\n\n\tpublic deltaStart(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive);\n\t}\n\n\tpublic deltaEnd(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start, this.endExclusive + offset);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.endExclusive - this.start;\n\t}\n\n\tpublic toString() {\n\t\treturn `[${this.start}, ${this.endExclusive})`;\n\t}\n\n\tpublic equals(other: OffsetRange): boolean {\n\t\treturn this.start === other.start && this.endExclusive === other.endExclusive;\n\t}\n\n\tpublic containsRange(other: OffsetRange): boolean {\n\t\treturn this.start <= other.start && other.endExclusive <= this.endExclusive;\n\t}\n\n\tpublic contains(offset: number): boolean {\n\t\treturn this.start <= offset && offset < this.endExclusive;\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n\t * The joined range is the smallest range that contains both ranges.\n\t */\n\tpublic join(other: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n\t *\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: OffsetRange): OffsetRange | undefined {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\tif (start <= end) {\n\t\t\treturn new OffsetRange(start, end);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectionLength(range: OffsetRange): number {\n\t\tconst start = Math.max(this.start, range.start);\n\t\tconst end = Math.min(this.endExclusive, range.endExclusive);\n\t\treturn Math.max(0, end - start);\n\t}\n\n\tpublic intersects(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start < end;\n\t}\n\n\tpublic intersectsOrTouches(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start <= end;\n\t}\n\n\tpublic isBefore(other: OffsetRange): boolean {\n\t\treturn this.endExclusive <= other.start;\n\t}\n\n\tpublic isAfter(other: OffsetRange): boolean {\n\t\treturn this.start >= other.endExclusive;\n\t}\n\n\tpublic slice<T>(arr: readonly T[]): T[] {\n\t\treturn arr.slice(this.start, this.endExclusive);\n\t}\n\n\tpublic substring(str: string): string {\n\t\treturn str.substring(this.start, this.endExclusive);\n\t}\n\n\t/**\n\t * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n\t * The range must not be empty.\n\t */\n\tpublic clip(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\treturn Math.max(this.start, Math.min(this.endExclusive - 1, value));\n\t}\n\n\t/**\n\t * Returns `r := value + k * length` such that `r` is contained in this range.\n\t * The range must not be empty.\n\t *\n\t * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n\t */\n\tpublic clipCyclic(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\tif (value < this.start) {\n\t\t\treturn this.endExclusive - ((this.start - value) % this.length);\n\t\t}\n\t\tif (value >= this.endExclusive) {\n\t\t\treturn this.start + ((value - this.start) % this.length);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic map<T>(f: (offset: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tresult.push(f(i));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (offset: number) => void): void {\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tf(i);\n\t\t}\n\t}\n\n\t/**\n\t * this: [ 5, 10), range: [10, 15) => [5, 15)]\n\t * Throws if the ranges are not touching.\n\t*/\n\tpublic joinRightTouching(range: OffsetRange): OffsetRange {\n\t\tif (this.endExclusive !== range.start) {\n\t\t\tthrow new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);\n\t\t}\n\t\treturn new OffsetRange(this.start, range.endExclusive);\n\t}\n}\n\nexport class OffsetRangeSet {\n\tprivate readonly _sortedRanges: OffsetRange[] = [];\n\n\tpublic get ranges(): OffsetRange[] {\n\t\treturn [...this._sortedRanges];\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tthis._sortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n\t\t\tthis._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._sortedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\t/**\n\t * Returns of there is a value that is contained in this instance and the given range.\n\t */\n\tpublic intersectsStrict(other: OffsetRange): boolean {\n\t\t// TODO use binary search\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n\t\t\ti++;\n\t\t}\n\t\treturn i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n\t}\n\n\tpublic intersectWithRange(other: OffsetRange): OffsetRangeSet {\n\t\t// TODO use binary search + slice\n\t\tconst result = new OffsetRangeSet();\n\t\tfor (const range of this._sortedRanges) {\n\t\t\tconst intersection = range.intersect(other);\n\t\t\tif (intersection) {\n\t\t\t\tresult.addRange(intersection);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic intersectWithRangeLength(other: OffsetRange): number {\n\t\treturn this.intersectWithRange(other).length;\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { IRange, Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRange(range: IRange): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber);\n\t}\n\n\tpublic static fromRangeInclusive(range: IRange): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\tpublic static subtract(a: LineRange, b: LineRange | undefined): LineRange[] {\n\t\tif (!b) {\n\t\t\treturn [a];\n\t\t}\n\t\tif (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(a.startLineNumber, b.startLineNumber),\n\t\t\t\tnew LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n\t\t\t];\n\t\t} else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n\t\t\treturn [];\n\t\t} else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n\t\t} else {\n\t\t\treturn [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n\t\t}\n\t}\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic containsRange(range: LineRange): boolean {\n\t\treturn this.startLineNumber <= range.startLineNumber && range.endLineNumberExclusive <= this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic distanceToRange(other: LineRange): number {\n\t\tif (this.endLineNumberExclusive <= other.startLineNumber) {\n\t\t\treturn other.startLineNumber - this.endLineNumberExclusive;\n\t\t}\n\t\tif (other.endLineNumberExclusive <= this.startLineNumber) {\n\t\t\treturn this.startLineNumber - other.endLineNumberExclusive;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic distanceToLine(lineNumber: number): number {\n\t\tif (this.contains(lineNumber)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (lineNumber < this.startLineNumber) {\n\t\t\treturn this.startLineNumber - lineNumber;\n\t\t}\n\t\treturn lineNumber - this.endLineNumberExclusive;\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { IRange, Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRange(range: IRange): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber);\n\t}\n\n\tpublic static fromRangeInclusive(range: IRange): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\tpublic static subtract(a: LineRange, b: LineRange | undefined): LineRange[] {\n\t\tif (!b) {\n\t\t\treturn [a];\n\t\t}\n\t\tif (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [\n\t\t\t\tnew LineRange(a.startLineNumber, b.startLineNumber),\n\t\t\t\tnew LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive)\n\t\t\t];\n\t\t} else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n\t\t\treturn [];\n\t\t} else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n\t\t\treturn [new LineRange(Math.max(b.endLineNumberExclusive, a.startLineNumber), a.endLineNumberExclusive)];\n\t\t} else {\n\t\t\treturn [new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive))];\n\t\t}\n\t}\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic containsRange(range: LineRange): boolean {\n\t\treturn this.startLineNumber <= range.startLineNumber && range.endLineNumberExclusive <= this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic distanceToRange(other: LineRange): number {\n\t\tif (this.endLineNumberExclusive <= other.startLineNumber) {\n\t\t\treturn other.startLineNumber - this.endLineNumberExclusive;\n\t\t}\n\t\tif (other.endLineNumberExclusive <= this.startLineNumber) {\n\t\t\treturn this.startLineNumber - other.endLineNumberExclusive;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic distanceToLine(lineNumber: number): number {\n\t\tif (this.contains(lineNumber)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (lineNumber < this.startLineNumber) {\n\t\t\treturn this.startLineNumber - lineNumber;\n\t\t}\n\t\treturn lineNumber - this.endLineNumberExclusive;\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n\tpublic static zero = new TextLength(0, 0);\n\n\tpublic static lengthDiffNonNegative(start: TextLength, end: TextLength): TextLength {\n\t\tif (end.isLessThan(start)) {\n\t\t\treturn TextLength.zero;\n\t\t}\n\t\tif (start.lineCount === end.lineCount) {\n\t\t\treturn new TextLength(0, end.columnCount - start.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(end.lineCount - start.lineCount, end.columnCount);\n\t\t}\n\t}\n\n\tpublic static betweenPositions(position1: Position, position2: Position): TextLength {\n\t\tif (position1.lineNumber === position2.lineNumber) {\n\t\t\treturn new TextLength(0, position2.column - position1.column);\n\t\t} else {\n\t\t\treturn new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n\t\t}\n\t}\n\n\tpublic static fromPosition(pos: Position): TextLength {\n\t\treturn new TextLength(pos.lineNumber - 1, pos.column - 1);\n\t}\n\n\tpublic static ofRange(range: Range) {\n\t\treturn TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n\t}\n\n\tpublic static ofText(text: string): TextLength {\n\t\tlet line = 0;\n\t\tlet column = 0;\n\t\tfor (const c of text) {\n\t\t\tif (c === '\\n') {\n\t\t\t\tline++;\n\t\t\t\tcolumn = 0;\n\t\t\t} else {\n\t\t\t\tcolumn++;\n\t\t\t}\n\t\t}\n\t\treturn new TextLength(line, column);\n\t}\n\n\tpublic static ofSubstr(str: string, range: OffsetRange): TextLength {\n\t\treturn TextLength.ofText(range.substring(str));\n\t}\n\n\tpublic static sum<T>(fragments: readonly T[], getLength: (f: T) => TextLength): TextLength {\n\t\treturn fragments.reduce((acc, f) => acc.add(getLength(f)), TextLength.zero);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isZero() {\n\t\treturn this.lineCount === 0 && this.columnCount === 0;\n\t}\n\n\tpublic isLessThan(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount < other.lineCount;\n\t\t}\n\t\treturn this.columnCount < other.columnCount;\n\t}\n\n\tpublic isGreaterThan(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount > other.columnCount;\n\t}\n\n\tpublic isGreaterThanOrEqualTo(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount >= other.columnCount;\n\t}\n\n\tpublic equals(other: TextLength): boolean {\n\t\treturn this.lineCount === other.lineCount && this.columnCount === other.columnCount;\n\t}\n\n\tpublic compare(other: TextLength): number {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount - other.lineCount;\n\t\t}\n\t\treturn this.columnCount - other.columnCount;\n\t}\n\n\tpublic add(other: TextLength): TextLength {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new TextLength(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\tpublic createRange(startPosition: Position): Range {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic toRange(): Range {\n\t\treturn new Range(1, 1, this.lineCount + 1, this.columnCount + 1);\n\t}\n\n\tpublic toLineRange(): LineRange {\n\t\treturn LineRange.ofLength(1, this.lineCount + 1);\n\t}\n\n\tpublic addToPosition(position: Position): Position {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Position(position.lineNumber, position.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic addToRange(range: Range): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.addToPosition(range.getStartPosition()),\n\t\t\tthis.addToPosition(range.getEndPosition())\n\t\t);\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n\tpublic static zero = new TextLength(0, 0);\n\n\tpublic static lengthDiffNonNegative(start: TextLength, end: TextLength): TextLength {\n\t\tif (end.isLessThan(start)) {\n\t\t\treturn TextLength.zero;\n\t\t}\n\t\tif (start.lineCount === end.lineCount) {\n\t\t\treturn new TextLength(0, end.columnCount - start.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(end.lineCount - start.lineCount, end.columnCount);\n\t\t}\n\t}\n\n\tpublic static betweenPositions(position1: Position, position2: Position): TextLength {\n\t\tif (position1.lineNumber === position2.lineNumber) {\n\t\t\treturn new TextLength(0, position2.column - position1.column);\n\t\t} else {\n\t\t\treturn new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n\t\t}\n\t}\n\n\tpublic static fromPosition(pos: Position): TextLength {\n\t\treturn new TextLength(pos.lineNumber - 1, pos.column - 1);\n\t}\n\n\tpublic static ofRange(range: Range) {\n\t\treturn TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n\t}\n\n\tpublic static ofText(text: string): TextLength {\n\t\tlet line = 0;\n\t\tlet column = 0;\n\t\tfor (const c of text) {\n\t\t\tif (c === '\\n') {\n\t\t\t\tline++;\n\t\t\t\tcolumn = 0;\n\t\t\t} else {\n\t\t\t\tcolumn++;\n\t\t\t}\n\t\t}\n\t\treturn new TextLength(line, column);\n\t}\n\n\tpublic static ofSubstr(str: string, range: OffsetRange): TextLength {\n\t\treturn TextLength.ofText(range.substring(str));\n\t}\n\n\tpublic static sum<T>(fragments: readonly T[], getLength: (f: T) => TextLength): TextLength {\n\t\treturn fragments.reduce((acc, f) => acc.add(getLength(f)), TextLength.zero);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isZero() {\n\t\treturn this.lineCount === 0 && this.columnCount === 0;\n\t}\n\n\tpublic isLessThan(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount < other.lineCount;\n\t\t}\n\t\treturn this.columnCount < other.columnCount;\n\t}\n\n\tpublic isGreaterThan(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount > other.columnCount;\n\t}\n\n\tpublic isGreaterThanOrEqualTo(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount >= other.columnCount;\n\t}\n\n\tpublic equals(other: TextLength): boolean {\n\t\treturn this.lineCount === other.lineCount && this.columnCount === other.columnCount;\n\t}\n\n\tpublic compare(other: TextLength): number {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount - other.lineCount;\n\t\t}\n\t\treturn this.columnCount - other.columnCount;\n\t}\n\n\tpublic add(other: TextLength): TextLength {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new TextLength(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\tpublic createRange(startPosition: Position): Range {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic toRange(): Range {\n\t\treturn new Range(1, 1, this.lineCount + 1, this.columnCount + 1);\n\t}\n\n\tpublic toLineRange(): LineRange {\n\t\treturn LineRange.ofLength(1, this.lineCount + 1);\n\t}\n\n\tpublic addToPosition(position: Position): Position {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Position(position.lineNumber, position.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic addToRange(range: Range): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.addToPosition(range.getStartPosition()),\n\t\t\tthis.addToPosition(range.getEndPosition())\n\t\t);\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous } from '../../../../base/common/arraysFind.js';\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport type { TextReplacement, TextEdit } from '../edits/textEdit.js';\nimport type { TextLength } from '../text/textLength.js';\n\nexport abstract class PositionOffsetTransformerBase {\n\tabstract getOffset(position: Position): number;\n\n\tgetOffsetRange(range: Range): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.getOffset(range.getStartPosition()),\n\t\t\tthis.getOffset(range.getEndPosition())\n\t\t);\n\t}\n\n\tabstract getPosition(offset: number): Position;\n\n\tgetRange(offsetRange: OffsetRange): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.getPosition(offsetRange.start),\n\t\t\tthis.getPosition(offsetRange.endExclusive)\n\t\t);\n\t}\n\n\tgetStringEdit(edit: TextEdit): StringEdit {\n\t\tconst edits = edit.replacements.map(e => this.getStringReplacement(e));\n\t\treturn new Deps.deps.StringEdit(edits);\n\t}\n\n\tgetStringReplacement(edit: TextReplacement): StringReplacement {\n\t\treturn new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);\n\t}\n\n\tgetTextReplacement(edit: StringReplacement): TextReplacement {\n\t\treturn new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);\n\t}\n\n\tgetTextEdit(edit: StringEdit): TextEdit {\n\t\tconst edits = edit.replacements.map(e => this.getTextReplacement(e));\n\t\treturn new Deps.deps.TextEdit(edits);\n\t}\n}\n\ninterface IDeps {\n\tStringEdit: typeof StringEdit;\n\tStringReplacement: typeof StringReplacement;\n\tTextReplacement: typeof TextReplacement;\n\tTextEdit: typeof TextEdit;\n\tTextLength: typeof TextLength;\n}\n\nclass Deps {\n\tstatic _deps: IDeps | undefined = undefined;\n\tstatic get deps(): IDeps {\n\t\tif (!this._deps) {\n\t\t\tthrow new Error('Dependencies not set. Call _setDependencies first.');\n\t\t}\n\t\treturn this._deps;\n\t}\n}\n\n/** This is to break circular module dependencies. */\nexport function _setPositionOffsetTransformerDependencies(deps: IDeps): void {\n\tDeps._deps = deps;\n}\n\nexport class PositionOffsetTransformer extends PositionOffsetTransformerBase {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\tprivate readonly lineEndOffsetByLineIdx: number[];\n\n\tconstructor(public readonly text: string) {\n\t\tsuper();\n\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineEndOffsetByLineIdx = [];\n\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t\tif (i > 0 && text.charAt(i - 1) === '\\r') {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i - 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineEndOffsetByLineIdx.push(text.length);\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\tconst valPos = this._validatePosition(position);\n\t\treturn this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;\n\t}\n\n\tprivate _validatePosition(position: Position): Position {\n\t\tif (position.lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\t\tconst lineCount = this.textLength.lineCount + 1;\n\t\tif (position.lineNumber > lineCount) {\n\t\t\tconst lineLength = this.getLineLength(lineCount);\n\t\t\treturn new Position(lineCount, lineLength + 1);\n\t\t}\n\t\tif (position.column < 1) {\n\t\t\treturn new Position(position.lineNumber, 1);\n\t\t}\n\t\tconst lineLength = this.getLineLength(position.lineNumber);\n\t\tif (position.column - 1 > lineLength) {\n\t\t\treturn new Position(position.lineNumber, lineLength + 1);\n\t\t}\n\t\treturn position;\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\tconst idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n\t\tconst lineNumber = idx + 1;\n\t\tconst column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tgetTextLength(offsetRange: OffsetRange): TextLength {\n\t\treturn Deps.deps.TextLength.ofRange(this.getRange(offsetRange));\n\t}\n\n\tget textLength(): TextLength {\n\t\tconst lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n\t\treturn new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous } from '../../../../base/common/arraysFind.js';\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport type { TextReplacement, TextEdit } from '../edits/textEdit.js';\nimport type { TextLength } from '../text/textLength.js';\n\nexport abstract class PositionOffsetTransformerBase {\n\tabstract getOffset(position: Position): number;\n\n\tgetOffsetRange(range: Range): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.getOffset(range.getStartPosition()),\n\t\t\tthis.getOffset(range.getEndPosition())\n\t\t);\n\t}\n\n\tabstract getPosition(offset: number): Position;\n\n\tgetRange(offsetRange: OffsetRange): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.getPosition(offsetRange.start),\n\t\t\tthis.getPosition(offsetRange.endExclusive)\n\t\t);\n\t}\n\n\tgetStringEdit(edit: TextEdit): StringEdit {\n\t\tconst edits = edit.replacements.map(e => this.getStringReplacement(e));\n\t\treturn new Deps.deps.StringEdit(edits);\n\t}\n\n\tgetStringReplacement(edit: TextReplacement): StringReplacement {\n\t\treturn new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);\n\t}\n\n\tgetTextReplacement(edit: StringReplacement): TextReplacement {\n\t\treturn new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);\n\t}\n\n\tgetTextEdit(edit: StringEdit): TextEdit {\n\t\tconst edits = edit.replacements.map(e => this.getTextReplacement(e));\n\t\treturn new Deps.deps.TextEdit(edits);\n\t}\n}\n\ninterface IDeps {\n\tStringEdit: typeof StringEdit;\n\tStringReplacement: typeof StringReplacement;\n\tTextReplacement: typeof TextReplacement;\n\tTextEdit: typeof TextEdit;\n\tTextLength: typeof TextLength;\n}\n\nclass Deps {\n\tstatic _deps: IDeps | undefined = undefined;\n\tstatic get deps(): IDeps {\n\t\tif (!this._deps) {\n\t\t\tthrow new Error('Dependencies not set. Call _setDependencies first.');\n\t\t}\n\t\treturn this._deps;\n\t}\n}\n\n/** This is to break circular module dependencies. */\nexport function _setPositionOffsetTransformerDependencies(deps: IDeps): void {\n\tDeps._deps = deps;\n}\n\nexport class PositionOffsetTransformer extends PositionOffsetTransformerBase {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\tprivate readonly lineEndOffsetByLineIdx: number[];\n\n\tconstructor(public readonly text: string) {\n\t\tsuper();\n\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineEndOffsetByLineIdx = [];\n\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t\tif (i > 0 && text.charAt(i - 1) === '\\r') {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i - 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineEndOffsetByLineIdx.push(text.length);\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\tconst valPos = this._validatePosition(position);\n\t\treturn this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;\n\t}\n\n\tprivate _validatePosition(position: Position): Position {\n\t\tif (position.lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\t\tconst lineCount = this.textLength.lineCount + 1;\n\t\tif (position.lineNumber > lineCount) {\n\t\t\tconst lineLength = this.getLineLength(lineCount);\n\t\t\treturn new Position(lineCount, lineLength + 1);\n\t\t}\n\t\tif (position.column < 1) {\n\t\t\treturn new Position(position.lineNumber, 1);\n\t\t}\n\t\tconst lineLength = this.getLineLength(position.lineNumber);\n\t\tif (position.column - 1 > lineLength) {\n\t\t\treturn new Position(position.lineNumber, lineLength + 1);\n\t\t}\n\t\treturn position;\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\tconst idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n\t\tconst lineNumber = idx + 1;\n\t\tconst column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tgetTextLength(offsetRange: OffsetRange): TextLength {\n\t\treturn Deps.deps.TextLength.ofRange(this.getRange(offsetRange));\n\t}\n\n\tget textLength(): TextLength {\n\t\tconst lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n\t\treturn new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformer } from './positionToOffsetImpl.js';\nimport { Range } from '../range.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { TextLength } from '../text/textLength.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetValueOfOffsetRange(range: OffsetRange): string {\n\t\treturn this.getValueOfRange(this.getTransformer().getRange(range));\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n\n\tgetLines(): string[] {\n\t\tconst value = this.getValue();\n\t\treturn splitLines(value);\n\t}\n\n\tgetLinesOfRange(range: LineRange): string[] {\n\t\treturn range.mapToLineArray(lineNumber => this.getLineAt(lineNumber));\n\t}\n\n\tequals(other: AbstractText): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this.getValue() === other.getValue();\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t;\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t\tthis._t = new PositionOffsetTransformer(this.value);\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformer } from './positionToOffsetImpl.js';\nimport { Range } from '../range.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { TextLength } from '../text/textLength.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetValueOfOffsetRange(range: OffsetRange): string {\n\t\treturn this.getValueOfRange(this.getTransformer().getRange(range));\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n\n\tgetLines(): string[] {\n\t\tconst value = this.getValue();\n\t\treturn splitLines(value);\n\t}\n\n\tgetLinesOfRange(range: LineRange): string[] {\n\t\treturn range.mapToLineArray(lineNumber => this.getLineAt(lineNumber));\n\t}\n\n\tequals(other: AbstractText): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this.getValue() === other.getValue();\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t;\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t\tthis._t = new PositionOffsetTransformer(this.value);\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, equals } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { ISingleEditOperation } from '../editOperation.js';\nimport { BaseStringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from '../text/textLength.js';\nimport { AbstractText, StringText } from '../text/abstractText.js';\n\nexport class TextEdit {\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.replacements.map(e => TextReplacement.fromStringReplacement(e, initialState));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static replace(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(originalRange, newText)]);\n\t}\n\n\tpublic static delete(range: Range): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(range, '')]);\n\t}\n\n\tpublic static insert(position: Position, newText: string): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(Range.fromPositions(position, position), newText)]);\n\t}\n\n\tpublic static fromParallelReplacementsUnsorted(replacements: readonly TextReplacement[]): TextEdit {\n\t\tconst r = replacements.slice().sort(compareBy(i => i.range, Range.compareRangesUsingStarts));\n\t\treturn new TextEdit(r);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replacements: readonly TextReplacement[]\n\t) {\n\t\tassertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst replacements: TextReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (replacements.length > 0 && replacements[replacements.length - 1].range.getEndPosition().equals(r.range.getStartPosition())) {\n\t\t\t\tconst last = replacements[replacements.length - 1];\n\t\t\t\treplacements[replacements.length - 1] = new TextReplacement(last.range.plusRange(r.range), last.text + r.text);\n\t\t\t} else if (!r.isEmpty) {\n\t\t\t\treplacements.push(r);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(replacements);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst start = replacement.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = replacement.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(replacement.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst editRange = replacement.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += replacement.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.replacements.map((e, idx) => new TextReplacement(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst textLength = TextLength.ofText(replacement.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: replacement.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - replacement.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - replacement.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = replacement.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoReplacement(text: AbstractText): TextReplacement {\n\t\tif (this.replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.replacements.length === 1) { return this.replacements[0]; }\n\n\t\tconst startPos = this.replacements[0].range.getStartPosition();\n\t\tconst endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tconst curEdit = this.replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.replacements.length - 1) {\n\t\t\t\tconst nextEdit = this.replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tequals(other: TextEdit): boolean {\n\t\treturn equals(this.replacements, other.replacements, (a, b) => a.equals(b));\n\t}\n\n\ttoString(text: AbstractText | string | undefined): string {\n\t\tif (text === undefined) {\n\t\t\treturn this.replacements.map(edit => edit.toString()).join('\\n');\n\t\t}\n\n\t\tif (typeof text === 'string') {\n\t\t\treturn this.toString(new StringText(text));\n\t\t}\n\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.replacements.map(r => {\n\t\t\tconst maxLength = 10;\n\t\t\tconst originalText = text.getValueOfRange(r.range);\n\n\t\t\t// Get text before the edit\n\t\t\tconst beforeRange = Range.fromPositions(\n\t\t\t\tnew Position(Math.max(1, r.range.startLineNumber - 1), 1),\n\t\t\t\tr.range.getStartPosition()\n\t\t\t);\n\t\t\tlet beforeText = text.getValueOfRange(beforeRange);\n\t\t\tif (beforeText.length > maxLength) {\n\t\t\t\tbeforeText = '...' + beforeText.substring(beforeText.length - maxLength);\n\t\t\t}\n\n\t\t\t// Get text after the edit\n\t\t\tconst afterRange = Range.fromPositions(\n\t\t\t\tr.range.getEndPosition(),\n\t\t\t\tnew Position(r.range.endLineNumber + 1, 1)\n\t\t\t);\n\t\t\tlet afterText = text.getValueOfRange(afterRange);\n\t\t\tif (afterText.length > maxLength) {\n\t\t\t\tafterText = afterText.substring(0, maxLength) + '...';\n\t\t\t}\n\n\t\t\t// Format the replaced text\n\t\t\tlet replacedText = originalText;\n\t\t\tif (replacedText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\treplacedText = replacedText.substring(0, halfMax) + '...' +\n\t\t\t\t\treplacedText.substring(replacedText.length - halfMax);\n\t\t\t}\n\n\t\t\t// Format the new text\n\t\t\tlet newText = r.text;\n\t\t\tif (newText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\tnewText = newText.substring(0, halfMax) + '...' +\n\t\t\t\t\tnewText.substring(newText.length - halfMax);\n\t\t\t}\n\n\t\t\tif (replacedText.length === 0) {\n\t\t\t\t// allow-any-unicode-next-line\n\t\t\t\treturn `${beforeText}❰${newText}❱${afterText}`;\n\t\t\t}\n\t\t\t// allow-any-unicode-next-line\n\t\t\treturn `${beforeText}❰${replacedText}↦${newText}❱${afterText}`;\n\t\t}).join('\\n');\n\t}\n}\n\nexport class TextReplacement {\n\tpublic static joinReplacements(replacements: TextReplacement[], initialValue: AbstractText): TextReplacement {\n\t\tif (replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (replacements.length === 1) { return replacements[0]; }\n\n\t\tconst startPos = replacements[0].range.getStartPosition();\n\t\tconst endPos = replacements[replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < replacements.length; i++) {\n\t\t\tconst curEdit = replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < replacements.length - 1) {\n\t\t\t\tconst nextEdit = replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tpublic static fromStringReplacement(replacement: StringReplacement, initialState: AbstractText): TextReplacement {\n\t\treturn new TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);\n\t}\n\n\tpublic static delete(range: Range): TextReplacement {\n\t\treturn new TextReplacement(range, '');\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: TextReplacement, second: TextReplacement) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n\n\tpublic toEdit(): TextEdit {\n\t\treturn new TextEdit([this]);\n\t}\n\n\tpublic equals(other: TextReplacement): boolean {\n\t\treturn TextReplacement.equals(this, other);\n\t}\n\n\tpublic extendToCoverRange(range: Range, initialValue: AbstractText): TextReplacement {\n\t\tif (this.range.containsRange(range)) { return this; }\n\n\t\tconst newRange = this.range.plusRange(range);\n\t\tconst textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));\n\t\tconst textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));\n\t\tconst newText = textBefore + this.text + textAfter;\n\t\treturn new TextReplacement(newRange, newText);\n\t}\n\n\tpublic extendToFullLine(initialValue: AbstractText): TextReplacement {\n\t\tconst newRange = new Range(\n\t\t\tthis.range.startLineNumber,\n\t\t\t1,\n\t\t\tthis.range.endLineNumber,\n\t\t\tinitialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1\n\t\t);\n\t\treturn this.extendToCoverRange(newRange, initialValue);\n\t}\n\n\tpublic removeCommonPrefixAndSuffix(text: AbstractText): TextReplacement {\n\t\tconst prefix = this.removeCommonPrefix(text);\n\t\tconst suffix = prefix.removeCommonSuffix(text);\n\t\treturn suffix;\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic removeCommonSuffix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);\n\t\tconst range = Range.fromPositions(this.range.getStartPosition(), end);\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic isEffectiveDeletion(text: AbstractText): boolean {\n\t\tlet newText = this.text.replaceAll('\\r\\n', '\\n');\n\t\tlet existingText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst l = commonPrefixLength(newText, existingText);\n\t\tnewText = newText.substring(l);\n\t\texistingText = existingText.substring(l);\n\t\tconst r = commonSuffixLength(newText, existingText);\n\t\tnewText = newText.substring(0, newText.length - r);\n\t\texistingText = existingText.substring(0, existingText.length - r);\n\n\t\treturn newText === '';\n\t}\n\n\tpublic toString(): string {\n\t\tconst start = this.range.getStartPosition();\n\t\tconst end = this.range.getEndPosition();\n\t\treturn `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): \"${this.text}\"`;\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, equals } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { ISingleEditOperation } from '../editOperation.js';\nimport { BaseStringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from '../text/textLength.js';\nimport { AbstractText, StringText } from '../text/abstractText.js';\n\nexport class TextEdit {\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.replacements.map(e => TextReplacement.fromStringReplacement(e, initialState));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static replace(originalRange: Range, newText: string): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(originalRange, newText)]);\n\t}\n\n\tpublic static delete(range: Range): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(range, '')]);\n\t}\n\n\tpublic static insert(position: Position, newText: string): TextEdit {\n\t\treturn new TextEdit([new TextReplacement(Range.fromPositions(position, position), newText)]);\n\t}\n\n\tpublic static fromParallelReplacementsUnsorted(replacements: readonly TextReplacement[]): TextEdit {\n\t\tconst r = replacements.slice().sort(compareBy(i => i.range, Range.compareRangesUsingStarts));\n\t\treturn new TextEdit(r);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replacements: readonly TextReplacement[]\n\t) {\n\t\tassertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\t/**\n\t * Joins touching edits and removes empty edits.\n\t */\n\tnormalize(): TextEdit {\n\t\tconst replacements: TextReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (replacements.length > 0 && replacements[replacements.length - 1].range.getEndPosition().equals(r.range.getStartPosition())) {\n\t\t\t\tconst last = replacements[replacements.length - 1];\n\t\t\t\treplacements[replacements.length - 1] = new TextReplacement(last.range.plusRange(r.range), last.text + r.text);\n\t\t\t} else if (!r.isEmpty) {\n\t\t\t\treplacements.push(r);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(replacements);\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst start = replacement.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = replacement.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(replacement.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\t// TODO: `doc` is not needed for this!\n\tinverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapPosition(positionAfterEdit);\n\t}\n\n\tinverseMapRange(range: Range, doc: AbstractText): Range {\n\t\tconst reversed = this.inverse(doc);\n\t\treturn reversed.mapRange(range);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst editRange = replacement.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += replacement.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tinverse(doc: AbstractText): TextEdit {\n\t\tconst ranges = this.getNewRanges();\n\t\treturn new TextEdit(this.replacements.map((e, idx) => new TextReplacement(ranges[idx], doc.getValueOfRange(e.range))));\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst textLength = TextLength.ofText(replacement.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: replacement.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - replacement.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - replacement.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = replacement.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoReplacement(text: AbstractText): TextReplacement {\n\t\tif (this.replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.replacements.length === 1) { return this.replacements[0]; }\n\n\t\tconst startPos = this.replacements[0].range.getStartPosition();\n\t\tconst endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tconst curEdit = this.replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.replacements.length - 1) {\n\t\t\t\tconst nextEdit = this.replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tequals(other: TextEdit): boolean {\n\t\treturn equals(this.replacements, other.replacements, (a, b) => a.equals(b));\n\t}\n\n\ttoString(text: AbstractText | string | undefined): string {\n\t\tif (text === undefined) {\n\t\t\treturn this.replacements.map(edit => edit.toString()).join('\\n');\n\t\t}\n\n\t\tif (typeof text === 'string') {\n\t\t\treturn this.toString(new StringText(text));\n\t\t}\n\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.replacements.map(r => {\n\t\t\tconst maxLength = 10;\n\t\t\tconst originalText = text.getValueOfRange(r.range);\n\n\t\t\t// Get text before the edit\n\t\t\tconst beforeRange = Range.fromPositions(\n\t\t\t\tnew Position(Math.max(1, r.range.startLineNumber - 1), 1),\n\t\t\t\tr.range.getStartPosition()\n\t\t\t);\n\t\t\tlet beforeText = text.getValueOfRange(beforeRange);\n\t\t\tif (beforeText.length > maxLength) {\n\t\t\t\tbeforeText = '...' + beforeText.substring(beforeText.length - maxLength);\n\t\t\t}\n\n\t\t\t// Get text after the edit\n\t\t\tconst afterRange = Range.fromPositions(\n\t\t\t\tr.range.getEndPosition(),\n\t\t\t\tnew Position(r.range.endLineNumber + 1, 1)\n\t\t\t);\n\t\t\tlet afterText = text.getValueOfRange(afterRange);\n\t\t\tif (afterText.length > maxLength) {\n\t\t\t\tafterText = afterText.substring(0, maxLength) + '...';\n\t\t\t}\n\n\t\t\t// Format the replaced text\n\t\t\tlet replacedText = originalText;\n\t\t\tif (replacedText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\treplacedText = replacedText.substring(0, halfMax) + '...' +\n\t\t\t\t\treplacedText.substring(replacedText.length - halfMax);\n\t\t\t}\n\n\t\t\t// Format the new text\n\t\t\tlet newText = r.text;\n\t\t\tif (newText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\tnewText = newText.substring(0, halfMax) + '...' +\n\t\t\t\t\tnewText.substring(newText.length - halfMax);\n\t\t\t}\n\n\t\t\tif (replacedText.length === 0) {\n\t\t\t\t// allow-any-unicode-next-line\n\t\t\t\treturn `${beforeText}❰${newText}❱${afterText}`;\n\t\t\t}\n\t\t\t// allow-any-unicode-next-line\n\t\t\treturn `${beforeText}❰${replacedText}↦${newText}❱${afterText}`;\n\t\t}).join('\\n');\n\t}\n}\n\nexport class TextReplacement {\n\tpublic static joinReplacements(replacements: TextReplacement[], initialValue: AbstractText): TextReplacement {\n\t\tif (replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (replacements.length === 1) { return replacements[0]; }\n\n\t\tconst startPos = replacements[0].range.getStartPosition();\n\t\tconst endPos = replacements[replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < replacements.length; i++) {\n\t\t\tconst curEdit = replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < replacements.length - 1) {\n\t\t\t\tconst nextEdit = replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tpublic static fromStringReplacement(replacement: StringReplacement, initialState: AbstractText): TextReplacement {\n\t\treturn new TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);\n\t}\n\n\tpublic static delete(range: Range): TextReplacement {\n\t\treturn new TextReplacement(range, '');\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: TextReplacement, second: TextReplacement) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic toSingleEditOperation(): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: this.range,\n\t\t\ttext: this.text,\n\t\t};\n\t}\n\n\tpublic toEdit(): TextEdit {\n\t\treturn new TextEdit([this]);\n\t}\n\n\tpublic equals(other: TextReplacement): boolean {\n\t\treturn TextReplacement.equals(this, other);\n\t}\n\n\tpublic extendToCoverRange(range: Range, initialValue: AbstractText): TextReplacement {\n\t\tif (this.range.containsRange(range)) { return this; }\n\n\t\tconst newRange = this.range.plusRange(range);\n\t\tconst textBefore = initialValue.getValueOfRange(Range.fromPositions(newRange.getStartPosition(), this.range.getStartPosition()));\n\t\tconst textAfter = initialValue.getValueOfRange(Range.fromPositions(this.range.getEndPosition(), newRange.getEndPosition()));\n\t\tconst newText = textBefore + this.text + textAfter;\n\t\treturn new TextReplacement(newRange, newText);\n\t}\n\n\tpublic extendToFullLine(initialValue: AbstractText): TextReplacement {\n\t\tconst newRange = new Range(\n\t\t\tthis.range.startLineNumber,\n\t\t\t1,\n\t\t\tthis.range.endLineNumber,\n\t\t\tinitialValue.getTransformer().getLineLength(this.range.endLineNumber) + 1\n\t\t);\n\t\treturn this.extendToCoverRange(newRange, initialValue);\n\t}\n\n\tpublic removeCommonPrefixAndSuffix(text: AbstractText): TextReplacement {\n\t\tconst prefix = this.removeCommonPrefix(text);\n\t\tconst suffix = prefix.removeCommonSuffix(text);\n\t\treturn suffix;\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic removeCommonSuffix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);\n\t\tconst range = Range.fromPositions(this.range.getStartPosition(), end);\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic isEffectiveDeletion(text: AbstractText): boolean {\n\t\tlet newText = this.text.replaceAll('\\r\\n', '\\n');\n\t\tlet existingText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst l = commonPrefixLength(newText, existingText);\n\t\tnewText = newText.substring(l);\n\t\texistingText = existingText.substring(l);\n\t\tconst r = commonSuffixLength(newText, existingText);\n\t\tnewText = newText.substring(0, newText.length - r);\n\t\texistingText = existingText.substring(0, existingText.length - r);\n\n\t\treturn newText === '';\n\t}\n\n\tpublic toString(): string {\n\t\tconst start = this.range.getStartPosition();\n\t\tconst end = this.range.getEndPosition();\n\t\treturn `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): \"${this.text}\"`;\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\nimport { IChange } from './legacyLinesDiffComputer.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\tpublic get changedLineCount() {\n\t\treturn Math.max(this.original.length, this.modified.length);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\tpublic static toTextEdit(mapping: readonly DetailedLineRangeMapping[], modified: AbstractText): TextEdit {\n\t\tconst replacements: TextReplacement[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tfor (const r of m.innerChanges ?? []) {\n\t\t\t\tconst replacement = r.toTextEdit(modified);\n\t\t\t\treplacements.push(replacement);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(replacements);\n\t}\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static fromEditJoin(edit: TextEdit): RangeMapping {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn RangeMapping.join(result);\n\t}\n\n\tpublic static join(rangeMappings: RangeMapping[]): RangeMapping {\n\t\tif (rangeMappings.length === 0) {\n\t\t\tthrow new BugIndicatingError('Cannot join an empty list of range mappings');\n\t\t}\n\t\tlet result = rangeMappings[0];\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tresult = result.join(rangeMappings[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n\n\tpublic join(other: RangeMapping): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tthis.originalRange.plusRange(other.originalRange),\n\t\t\tthis.modifiedRange.plusRange(other.modifiedRange)\n\t\t);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\nexport function lineRangeMappingFromChange(change: IChange): LineRangeMapping {\n\tlet originalRange: LineRange;\n\tif (change.originalEndLineNumber === 0) {\n\t\t// Insertion\n\t\toriginalRange = new LineRange(change.originalStartLineNumber + 1, change.originalStartLineNumber + 1);\n\t} else {\n\t\toriginalRange = new LineRange(change.originalStartLineNumber, change.originalEndLineNumber + 1);\n\t}\n\n\tlet modifiedRange: LineRange;\n\tif (change.modifiedEndLineNumber === 0) {\n\t\t// Deletion\n\t\tmodifiedRange = new LineRange(change.modifiedStartLineNumber + 1, change.modifiedStartLineNumber + 1);\n\t} else {\n\t\tmodifiedRange = new LineRange(change.modifiedStartLineNumber, change.modifiedEndLineNumber + 1);\n\t}\n\n\treturn new LineRangeMapping(originalRange, modifiedRange);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\nimport { IChange } from './legacyLinesDiffComputer.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\tpublic get changedLineCount() {\n\t\treturn Math.max(this.original.length, this.modified.length);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\tpublic static toTextEdit(mapping: readonly DetailedLineRangeMapping[], modified: AbstractText): TextEdit {\n\t\tconst replacements: TextReplacement[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tfor (const r of m.innerChanges ?? []) {\n\t\t\t\tconst replacement = r.toTextEdit(modified);\n\t\t\t\treplacements.push(replacement);\n\t\t\t}\n\t\t}\n\t\treturn new TextEdit(replacements);\n\t}\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static fromEditJoin(edit: TextEdit): RangeMapping {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn RangeMapping.join(result);\n\t}\n\n\tpublic static join(rangeMappings: RangeMapping[]): RangeMapping {\n\t\tif (rangeMappings.length === 0) {\n\t\t\tthrow new BugIndicatingError('Cannot join an empty list of range mappings');\n\t\t}\n\t\tlet result = rangeMappings[0];\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tresult = result.join(rangeMappings[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n\n\tpublic join(other: RangeMapping): RangeMapping {\n\t\treturn new RangeMapping(\n\t\t\tthis.originalRange.plusRange(other.originalRange),\n\t\t\tthis.modifiedRange.plusRange(other.modifiedRange)\n\t\t);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\nexport function lineRangeMappingFromChange(change: IChange): LineRangeMapping {\n\tlet originalRange: LineRange;\n\tif (change.originalEndLineNumber === 0) {\n\t\t// Insertion\n\t\toriginalRange = new LineRange(change.originalStartLineNumber + 1, change.originalStartLineNumber + 1);\n\t} else {\n\t\toriginalRange = new LineRange(change.originalStartLineNumber, change.originalEndLineNumber + 1);\n\t}\n\n\tlet modifiedRange: LineRange;\n\tif (change.modifiedEndLineNumber === 0) {\n\t\t// Deletion\n\t\tmodifiedRange = new LineRange(change.modifiedStartLineNumber + 1, change.modifiedStartLineNumber + 1);\n\t} else {\n\t\tmodifiedRange = new LineRange(change.modifiedStartLineNumber, change.modifiedEndLineNumber + 1);\n\t}\n\n\treturn new LineRangeMapping(originalRange, modifiedRange);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\nexport interface IDiffComputationResult {\n\tquitEarly: boolean;\n\tidentical: boolean;\n\n\t/**\n\t * The changes as (legacy) line change array.\n\t * @deprecated Use `changes2` instead.\n\t */\n\tchanges: ILineChange[];\n\n\t/**\n\t * The changes as (modern) line range mapping array.\n\t */\n\tchanges2: readonly DetailedLineRangeMapping[];\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\nexport interface IDiffComputationResult {\n\tquitEarly: boolean;\n\tidentical: boolean;\n\n\t/**\n\t * The changes as (legacy) line change array.\n\t * @deprecated Use `changes2` instead.\n\t */\n\tchanges: ILineChange[];\n\n\t/**\n\t * The changes as (modern) line range mapping array.\n\t */\n\tchanges2: readonly DetailedLineRangeMapping[];\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n*/\nexport interface IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout?: ITimeout): DiffAlgorithmResult;\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n\t}\n\n\tstatic trivialTimedOut(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) { }\n}\n\nexport class SequenceDiff {\n\tpublic static invert(sequenceDiffs: SequenceDiff[], doc1Length: number): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(SequenceDiff.fromOffsetPairs(\n\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\tb ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n\t\t\t));\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(start: OffsetPair, endExclusive: OffsetPair): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined = undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n\t\t\t\t\tthrow new BugIndicatingError('Sequence diffs must be sorted');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) { }\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n\t}\n\n\tpublic intersectsOrTouches(other: SequenceDiff): boolean {\n\t\treturn this.seq1Range.intersectsOrTouches(other.seq1Range) || this.seq2Range.intersectsOrTouches(other.seq2Range);\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t*/\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError('timeout must be positive');\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n\n\tpublic disable() {\n\t\tthis.timeout = Number.MAX_SAFE_INTEGER;\n\t\tthis.isValid = () => true;\n\t\tthis.valid = true;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n*/\nexport interface IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout?: ITimeout): DiffAlgorithmResult;\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n\t}\n\n\tstatic trivialTimedOut(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) { }\n}\n\nexport class SequenceDiff {\n\tpublic static invert(sequenceDiffs: SequenceDiff[], doc1Length: number): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(SequenceDiff.fromOffsetPairs(\n\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\tb ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n\t\t\t));\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(start: OffsetPair, endExclusive: OffsetPair): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined = undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n\t\t\t\t\tthrow new BugIndicatingError('Sequence diffs must be sorted');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) { }\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n\t}\n\n\tpublic intersectsOrTouches(other: SequenceDiff): boolean {\n\t\treturn this.seq1Range.intersectsOrTouches(other.seq1Range) || this.seq2Range.intersectsOrTouches(other.seq2Range);\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t*/\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError('timeout must be positive');\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n\n\tpublic disable() {\n\t\tthis.timeout = Number.MAX_SAFE_INTEGER;\n\t\tthis.isValid = () => true;\n\t\tthis.valid = true;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { DetailedLineRangeMapping } from '../rangeMapping.js';\n\nexport class Array2D<T> {\n\tprivate readonly array: T[] = [];\n\n\tconstructor(public readonly width: number, public readonly height: number) {\n\t\tthis.array = new Array<T>(width * height);\n\t}\n\n\tget(x: number, y: number): T {\n\t\treturn this.array[x + y * this.width];\n\t}\n\n\tset(x: number, y: number, value: T): void {\n\t\tthis.array[x + y * this.width] = value;\n\t}\n}\n\nexport function isSpace(charCode: number): boolean {\n\treturn charCode === CharCode.Space || charCode === CharCode.Tab;\n}\n\nexport class LineRangeFragment {\n\tprivate static chrKeys = new Map<string, number>();\n\n\tprivate static getKey(chr: string): number {\n\t\tlet key = this.chrKeys.get(chr);\n\t\tif (key === undefined) {\n\t\t\tkey = this.chrKeys.size;\n\t\t\tthis.chrKeys.set(chr, key);\n\t\t}\n\t\treturn key;\n\t}\n\n\tprivate readonly totalCount: number;\n\tprivate readonly histogram: number[] = [];\n\tconstructor(\n\t\tpublic readonly range: LineRange,\n\t\tpublic readonly lines: string[],\n\t\tpublic readonly source: DetailedLineRangeMapping,\n\t) {\n\t\tlet counter = 0;\n\t\tfor (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tcounter++;\n\t\t\t\tconst chr = line[j];\n\t\t\t\tconst key = LineRangeFragment.getKey(chr);\n\t\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tconst key = LineRangeFragment.getKey('\\n');\n\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t}\n\n\t\tthis.totalCount = counter;\n\t}\n\n\tpublic computeSimilarity(other: LineRangeFragment): number {\n\t\tlet sumDifferences = 0;\n\t\tconst maxLength = Math.max(this.histogram.length, other.histogram.length);\n\t\tfor (let i = 0; i < maxLength; i++) {\n\t\t\tsumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n\t\t}\n\t\treturn 1 - (sumDifferences / (this.totalCount + other.totalCount));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { DetailedLineRangeMapping } from '../rangeMapping.js';\n\nexport class Array2D<T> {\n\tprivate readonly array: T[] = [];\n\n\tconstructor(public readonly width: number, public readonly height: number) {\n\t\tthis.array = new Array<T>(width * height);\n\t}\n\n\tget(x: number, y: number): T {\n\t\treturn this.array[x + y * this.width];\n\t}\n\n\tset(x: number, y: number, value: T): void {\n\t\tthis.array[x + y * this.width] = value;\n\t}\n}\n\nexport function isSpace(charCode: number): boolean {\n\treturn charCode === CharCode.Space || charCode === CharCode.Tab;\n}\n\nexport class LineRangeFragment {\n\tprivate static chrKeys = new Map<string, number>();\n\n\tprivate static getKey(chr: string): number {\n\t\tlet key = this.chrKeys.get(chr);\n\t\tif (key === undefined) {\n\t\t\tkey = this.chrKeys.size;\n\t\t\tthis.chrKeys.set(chr, key);\n\t\t}\n\t\treturn key;\n\t}\n\n\tprivate readonly totalCount: number;\n\tprivate readonly histogram: number[] = [];\n\tconstructor(\n\t\tpublic readonly range: LineRange,\n\t\tpublic readonly lines: string[],\n\t\tpublic readonly source: DetailedLineRangeMapping,\n\t) {\n\t\tlet counter = 0;\n\t\tfor (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tcounter++;\n\t\t\t\tconst chr = line[j];\n\t\t\t\tconst key = LineRangeFragment.getKey(chr);\n\t\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tconst key = LineRangeFragment.getKey('\\n');\n\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t}\n\n\t\tthis.totalCount = counter;\n\t}\n\n\tpublic computeSimilarity(other: LineRangeFragment): number {\n\t\tlet sumDifferences = 0;\n\t\tconst maxLength = Math.max(this.histogram.length, other.histogram.length);\n\t\tfor (let i = 0; i < maxLength; i++) {\n\t\t\tsumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n\t\t}\n\t\treturn 1 - (sumDifferences / (this.totalCount + other.totalCount));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { DiffAlgorithmResult, IDiffAlgorithm, ISequence, ITimeout, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm implements IDiffAlgorithm {\n\tcompute(seq1: ISequence, seq2: ISequence, timeout: ITimeout = InfiniteTimeout.instance): DiffAlgorithmResult {\n\t\t// These are common special cases.\n\t\t// The early return improves performance dramatically.\n\t\tif (seq1.length === 0 || seq2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(seq1, seq2);\n\t\t}\n\n\t\tconst seqX = seq1; // Text on the x axis\n\t\tconst seqY = seq2; // Text on the y axis\n\n\t\tfunction getXAfterSnake(x: number, y: number): number {\n\t\t\twhile (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\n\t\tlet d = 0;\n\t\t// V[k]: X value of longest d-line that ends in diagonal k.\n\t\t// d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n\t\t// diagonal k: Set of points (x,y) with x-y = k.\n\t\t// k=1 -> (1,0),(2,1)\n\t\tconst V = new FastInt32Array();\n\t\tV.set(0, getXAfterSnake(0, 0));\n\n\t\tconst paths = new FastArrayNegativeIndices<SnakePath | null>();\n\t\tpaths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n\n\t\tlet k = 0;\n\n\t\tloop: while (true) {\n\t\t\td++;\n\t\t\tif (!timeout.isValid()) {\n\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n\t\t\t}\n\t\t\t// The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n\t\t\tconst lowerBound = -Math.min(d, seqY.length + (d % 2));\n\t\t\tconst upperBound = Math.min(d, seqX.length + (d % 2));\n\t\t\tfor (k = lowerBound; k <= upperBound; k += 2) {\n\t\t\t\tlet step = 0;\n\t\t\t\t// We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n\t\t\t\tconst maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n\t\t\t\tconst maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n\t\t\t\tstep++;\n\t\t\t\tconst x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n\t\t\t\tconst y = x - k;\n\t\t\t\tstep++;\n\t\t\t\tif (x > seqX.length || y > seqY.length) {\n\t\t\t\t\t// This diagonal is irrelevant for the result.\n\t\t\t\t\t// TODO: Don't pay the cost for this in the next iteration.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newMaxX = getXAfterSnake(x, y);\n\t\t\t\tV.set(k, newMaxX);\n\t\t\t\tconst lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n\t\t\t\tpaths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n\n\t\t\t\tif (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet path = paths.get(k);\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = seqX.length;\n\t\tlet lastAligningPosS2: number = seqY.length;\n\n\t\twhile (true) {\n\t\t\tconst endX = path ? path.x + path.length : 0;\n\t\t\tconst endY = path ? path.y + path.length : 0;\n\n\t\t\tif (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(endX, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(endY, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tif (!path) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAligningPosS1 = path.x;\n\t\t\tlastAligningPosS2 = path.y;\n\n\t\t\tpath = path.prev;\n\t\t}\n\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n\nclass SnakePath {\n\tconstructor(\n\t\tpublic readonly prev: SnakePath | null,\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t\tpublic readonly length: number\n\t) {\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n\tprivate positiveArr: Int32Array = new Int32Array(10);\n\tprivate negativeArr: Int32Array = new Int32Array(10);\n\n\tget(idx: number): number {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: number): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tif (idx >= this.negativeArr.length) {\n\t\t\t\tconst arr = this.negativeArr;\n\t\t\t\tthis.negativeArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.negativeArr.set(arr);\n\t\t\t}\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tif (idx >= this.positiveArr.length) {\n\t\t\t\tconst arr = this.positiveArr;\n\t\t\t\tthis.positiveArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.positiveArr.set(arr);\n\t\t\t}\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices<T> {\n\tprivate readonly positiveArr: T[] = [];\n\tprivate readonly negativeArr: T[] = [];\n\n\tget(idx: number): T {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: T): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { DiffAlgorithmResult, IDiffAlgorithm, ISequence, ITimeout, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm implements IDiffAlgorithm {\n\tcompute(seq1: ISequence, seq2: ISequence, timeout: ITimeout = InfiniteTimeout.instance): DiffAlgorithmResult {\n\t\t// These are common special cases.\n\t\t// The early return improves performance dramatically.\n\t\tif (seq1.length === 0 || seq2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(seq1, seq2);\n\t\t}\n\n\t\tconst seqX = seq1; // Text on the x axis\n\t\tconst seqY = seq2; // Text on the y axis\n\n\t\tfunction getXAfterSnake(x: number, y: number): number {\n\t\t\twhile (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\n\t\tlet d = 0;\n\t\t// V[k]: X value of longest d-line that ends in diagonal k.\n\t\t// d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n\t\t// diagonal k: Set of points (x,y) with x-y = k.\n\t\t// k=1 -> (1,0),(2,1)\n\t\tconst V = new FastInt32Array();\n\t\tV.set(0, getXAfterSnake(0, 0));\n\n\t\tconst paths = new FastArrayNegativeIndices<SnakePath | null>();\n\t\tpaths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n\n\t\tlet k = 0;\n\n\t\tloop: while (true) {\n\t\t\td++;\n\t\t\tif (!timeout.isValid()) {\n\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n\t\t\t}\n\t\t\t// The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n\t\t\tconst lowerBound = -Math.min(d, seqY.length + (d % 2));\n\t\t\tconst upperBound = Math.min(d, seqX.length + (d % 2));\n\t\t\tfor (k = lowerBound; k <= upperBound; k += 2) {\n\t\t\t\tlet step = 0;\n\t\t\t\t// We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n\t\t\t\tconst maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n\t\t\t\tconst maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n\t\t\t\tstep++;\n\t\t\t\tconst x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n\t\t\t\tconst y = x - k;\n\t\t\t\tstep++;\n\t\t\t\tif (x > seqX.length || y > seqY.length) {\n\t\t\t\t\t// This diagonal is irrelevant for the result.\n\t\t\t\t\t// TODO: Don't pay the cost for this in the next iteration.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newMaxX = getXAfterSnake(x, y);\n\t\t\t\tV.set(k, newMaxX);\n\t\t\t\tconst lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n\t\t\t\tpaths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n\n\t\t\t\tif (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet path = paths.get(k);\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = seqX.length;\n\t\tlet lastAligningPosS2: number = seqY.length;\n\n\t\twhile (true) {\n\t\t\tconst endX = path ? path.x + path.length : 0;\n\t\t\tconst endY = path ? path.y + path.length : 0;\n\n\t\t\tif (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(endX, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(endY, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tif (!path) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAligningPosS1 = path.x;\n\t\t\tlastAligningPosS2 = path.y;\n\n\t\t\tpath = path.prev;\n\t\t}\n\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n\nclass SnakePath {\n\tconstructor(\n\t\tpublic readonly prev: SnakePath | null,\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t\tpublic readonly length: number\n\t) {\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n\tprivate positiveArr: Int32Array = new Int32Array(10);\n\tprivate negativeArr: Int32Array = new Int32Array(10);\n\n\tget(idx: number): number {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: number): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tif (idx >= this.negativeArr.length) {\n\t\t\t\tconst arr = this.negativeArr;\n\t\t\t\tthis.negativeArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.negativeArr.set(arr);\n\t\t\t}\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tif (idx >= this.positiveArr.length) {\n\t\t\t\tconst arr = this.positiveArr;\n\t\t\t\tthis.positiveArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.positiveArr.set(arr);\n\t\t\t}\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices<T> {\n\tprivate readonly positiveArr: T[] = [];\n\tprivate readonly negativeArr: T[] = [];\n\n\tget(idx: number): T {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: T): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DetailedLineRangeMapping, LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/ranges/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\n\nexport function computeMovedLines(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\ttimeout: ITimeout\n): LineRangeMapping[] {\n\tlet { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n\n\tif (!timeout.isValid()) { return []; }\n\n\tconst filteredChanges = changes.filter(c => !excludedChanges.has(c));\n\tconst unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n\tpushMany(moves, unchangedMoves);\n\n\tmoves = joinCloseConsecutiveMoves(moves);\n\t// Ignore too short moves\n\tmoves = moves.filter(current => {\n\t\tconst lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n\t\tconst originalText = lines.join('\\n');\n\t\treturn originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n\t});\n\tmoves = removeMovesInSameDiff(changes, moves);\n\n\treturn moves;\n}\n\nfunction countWhere<T>(arr: T[], predicate: (t: T) => boolean): number {\n\tlet count = 0;\n\tfor (const t of arr) {\n\t\tif (predicate(t)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst deletions = changes\n\t\t.filter(c => c.modified.isEmpty && c.original.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.original, originalLines, d));\n\tconst insertions = new Set(changes\n\t\t.filter(c => c.original.isEmpty && c.modified.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n\n\tconst excludedChanges = new Set<DetailedLineRangeMapping>();\n\n\tfor (const deletion of deletions) {\n\t\tlet highestSimilarity = -1;\n\t\tlet best: LineRangeFragment | undefined;\n\t\tfor (const insertion of insertions) {\n\t\t\tconst similarity = deletion.computeSimilarity(insertion);\n\t\t\tif (similarity > highestSimilarity) {\n\t\t\t\thighestSimilarity = similarity;\n\t\t\t\tbest = insertion;\n\t\t\t}\n\t\t}\n\n\t\tif (highestSimilarity > 0.90 && best) {\n\t\t\tinsertions.delete(best);\n\t\t\tmoves.push(new LineRangeMapping(deletion.range, best.range));\n\t\t\texcludedChanges.add(deletion.source);\n\t\t\texcludedChanges.add(best.source);\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn { moves, excludedChanges };\n\t\t}\n\t}\n\n\treturn { moves, excludedChanges };\n}\n\nfunction computeUnchangedMoves(\n\tchanges: DetailedLineRangeMapping[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst original3LineHashes = new SetMap<string, { range: LineRange }>();\n\n\tfor (const change of changes) {\n\t\tfor (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n\t\t\toriginal3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n\t\t}\n\t}\n\n\tinterface PossibleMapping {\n\t\tmodifiedLineRange: LineRange;\n\t\toriginalLineRange: LineRange;\n\t}\n\n\tconst possibleMappings: PossibleMapping[] = [];\n\n\tchanges.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n\n\tfor (const change of changes) {\n\t\tlet lastMappings: PossibleMapping[] = [];\n\t\tfor (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n\t\t\tconst currentModifiedRange = new LineRange(i, i + 3);\n\n\t\t\tconst nextMappings: PossibleMapping[] = [];\n\t\t\toriginal3LineHashes.forEach(key, ({ range }) => {\n\t\t\t\tfor (const lastMapping of lastMappings) {\n\t\t\t\t\t// does this match extend some last match?\n\t\t\t\t\tif (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n\t\t\t\t\t\tlastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n\t\t\t\t\t\tlastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n\t\t\t\t\t\tlastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n\t\t\t\t\t\tnextMappings.push(lastMapping);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst mapping: PossibleMapping = {\n\t\t\t\t\tmodifiedLineRange: currentModifiedRange,\n\t\t\t\t\toriginalLineRange: range,\n\t\t\t\t};\n\t\t\t\tpossibleMappings.push(mapping);\n\t\t\t\tnextMappings.push(mapping);\n\t\t\t});\n\t\t\tlastMappings = nextMappings;\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tpossibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n\n\tconst modifiedSet = new LineRangeSet();\n\tconst originalSet = new LineRangeSet();\n\n\tfor (const mapping of possibleMappings) {\n\n\t\tconst diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n\t\tconst modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n\t\tconst originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n\n\t\tconst modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n\n\t\tfor (const s of modifiedIntersectedSections.ranges) {\n\t\t\tif (s.length < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst modifiedLineRange = s;\n\t\t\tconst originalLineRange = s.delta(-diffOrigToMod);\n\n\t\t\tmoves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n\n\t\t\tmodifiedSet.addRange(modifiedLineRange);\n\t\t\toriginalSet.addRange(originalLineRange);\n\t\t}\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst monotonousChanges = new MonotonousArray(changes);\n\tfor (let i = 0; i < moves.length; i++) {\n\t\tconst move = moves[i];\n\t\tconst firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber)!;\n\t\tconst firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber)!;\n\t\tconst linesAbove = Math.max(\n\t\t\tmove.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber,\n\t\t\tmove.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber\n\t\t);\n\n\t\tconst lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive)!;\n\t\tconst lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive)!;\n\t\tconst linesBelow = Math.max(\n\t\t\tlastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive,\n\t\t\tlastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive\n\t\t);\n\n\t\tlet extendToTop: number;\n\t\tfor (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n\t\t\tconst origLine = move.original.startLineNumber - extendToTop - 1;\n\t\t\tconst modLine = move.modified.startLineNumber - extendToTop - 1;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToTop > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n\t\t}\n\n\t\tlet extendToBottom: number;\n\t\tfor (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n\t\t\tconst origLine = move.original.endLineNumberExclusive + extendToBottom;\n\t\t\tconst modLine = move.modified.endLineNumberExclusive + extendToBottom;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToBottom > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n\t\t}\n\n\t\tif (extendToTop > 0 || extendToBottom > 0) {\n\t\t\tmoves[i] = new LineRangeMapping(\n\t\t\t\tnew LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom),\n\t\t\t\tnew LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn moves;\n}\n\nfunction areLinesSimilar(line1: string, line2: string, timeout: ITimeout): boolean {\n\tif (line1.trim() === line2.trim()) { return true; }\n\tif (line1.length > 300 && line2.length > 300) { return false; }\n\n\tconst myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\tconst result = myersDiffingAlgorithm.compute(\n\t\tnew LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false),\n\t\tnew LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false),\n\t\ttimeout\n\t);\n\tlet commonNonSpaceCharCount = 0;\n\tconst inverted = SequenceDiff.invert(result.diffs, line1.length);\n\tfor (const seq of inverted) {\n\t\tseq.seq1Range.forEach(idx => {\n\t\t\tif (!isSpace(line1.charCodeAt(idx))) {\n\t\t\t\tcommonNonSpaceCharCount++;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction countNonWsChars(str: string): number {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < line1.length; i++) {\n\t\t\tif (!isSpace(str.charCodeAt(i))) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tconst longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n\tconst r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n\treturn r;\n}\n\nfunction joinCloseConsecutiveMoves(moves: LineRangeMapping[]): LineRangeMapping[] {\n\tif (moves.length === 0) {\n\t\treturn moves;\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst result = [moves[0]];\n\tfor (let i = 1; i < moves.length; i++) {\n\t\tconst last = result[result.length - 1];\n\t\tconst current = moves[i];\n\n\t\tconst originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n\t\tconst modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n\t\tconst currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n\n\t\tif (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n\t\t\tresult[result.length - 1] = last.join(current);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(current);\n\t}\n\treturn result;\n}\n\nfunction removeMovesInSameDiff(changes: DetailedLineRangeMapping[], moves: LineRangeMapping[]) {\n\tconst changesMonotonous = new MonotonousArray(changes);\n\tmoves = moves.filter(m => {\n\t\tconst diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n\t\t\t|| new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n\t\tconst diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n\n\t\tconst differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n\t\treturn differentDiffs;\n\t});\n\treturn moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DetailedLineRangeMapping, LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/ranges/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\n\nexport function computeMovedLines(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\ttimeout: ITimeout\n): LineRangeMapping[] {\n\tlet { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n\n\tif (!timeout.isValid()) { return []; }\n\n\tconst filteredChanges = changes.filter(c => !excludedChanges.has(c));\n\tconst unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n\tpushMany(moves, unchangedMoves);\n\n\tmoves = joinCloseConsecutiveMoves(moves);\n\t// Ignore too short moves\n\tmoves = moves.filter(current => {\n\t\tconst lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n\t\tconst originalText = lines.join('\\n');\n\t\treturn originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n\t});\n\tmoves = removeMovesInSameDiff(changes, moves);\n\n\treturn moves;\n}\n\nfunction countWhere<T>(arr: T[], predicate: (t: T) => boolean): number {\n\tlet count = 0;\n\tfor (const t of arr) {\n\t\tif (predicate(t)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst deletions = changes\n\t\t.filter(c => c.modified.isEmpty && c.original.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.original, originalLines, d));\n\tconst insertions = new Set(changes\n\t\t.filter(c => c.original.isEmpty && c.modified.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n\n\tconst excludedChanges = new Set<DetailedLineRangeMapping>();\n\n\tfor (const deletion of deletions) {\n\t\tlet highestSimilarity = -1;\n\t\tlet best: LineRangeFragment | undefined;\n\t\tfor (const insertion of insertions) {\n\t\t\tconst similarity = deletion.computeSimilarity(insertion);\n\t\t\tif (similarity > highestSimilarity) {\n\t\t\t\thighestSimilarity = similarity;\n\t\t\t\tbest = insertion;\n\t\t\t}\n\t\t}\n\n\t\tif (highestSimilarity > 0.90 && best) {\n\t\t\tinsertions.delete(best);\n\t\t\tmoves.push(new LineRangeMapping(deletion.range, best.range));\n\t\t\texcludedChanges.add(deletion.source);\n\t\t\texcludedChanges.add(best.source);\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn { moves, excludedChanges };\n\t\t}\n\t}\n\n\treturn { moves, excludedChanges };\n}\n\nfunction computeUnchangedMoves(\n\tchanges: DetailedLineRangeMapping[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst original3LineHashes = new SetMap<string, { range: LineRange }>();\n\n\tfor (const change of changes) {\n\t\tfor (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n\t\t\toriginal3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n\t\t}\n\t}\n\n\tinterface PossibleMapping {\n\t\tmodifiedLineRange: LineRange;\n\t\toriginalLineRange: LineRange;\n\t}\n\n\tconst possibleMappings: PossibleMapping[] = [];\n\n\tchanges.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n\n\tfor (const change of changes) {\n\t\tlet lastMappings: PossibleMapping[] = [];\n\t\tfor (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n\t\t\tconst currentModifiedRange = new LineRange(i, i + 3);\n\n\t\t\tconst nextMappings: PossibleMapping[] = [];\n\t\t\toriginal3LineHashes.forEach(key, ({ range }) => {\n\t\t\t\tfor (const lastMapping of lastMappings) {\n\t\t\t\t\t// does this match extend some last match?\n\t\t\t\t\tif (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n\t\t\t\t\t\tlastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n\t\t\t\t\t\tlastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n\t\t\t\t\t\tlastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n\t\t\t\t\t\tnextMappings.push(lastMapping);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst mapping: PossibleMapping = {\n\t\t\t\t\tmodifiedLineRange: currentModifiedRange,\n\t\t\t\t\toriginalLineRange: range,\n\t\t\t\t};\n\t\t\t\tpossibleMappings.push(mapping);\n\t\t\t\tnextMappings.push(mapping);\n\t\t\t});\n\t\t\tlastMappings = nextMappings;\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tpossibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n\n\tconst modifiedSet = new LineRangeSet();\n\tconst originalSet = new LineRangeSet();\n\n\tfor (const mapping of possibleMappings) {\n\n\t\tconst diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n\t\tconst modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n\t\tconst originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n\n\t\tconst modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n\n\t\tfor (const s of modifiedIntersectedSections.ranges) {\n\t\t\tif (s.length < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst modifiedLineRange = s;\n\t\t\tconst originalLineRange = s.delta(-diffOrigToMod);\n\n\t\t\tmoves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n\n\t\t\tmodifiedSet.addRange(modifiedLineRange);\n\t\t\toriginalSet.addRange(originalLineRange);\n\t\t}\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst monotonousChanges = new MonotonousArray(changes);\n\tfor (let i = 0; i < moves.length; i++) {\n\t\tconst move = moves[i];\n\t\tconst firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber)!;\n\t\tconst firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber)!;\n\t\tconst linesAbove = Math.max(\n\t\t\tmove.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber,\n\t\t\tmove.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber\n\t\t);\n\n\t\tconst lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive)!;\n\t\tconst lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive)!;\n\t\tconst linesBelow = Math.max(\n\t\t\tlastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive,\n\t\t\tlastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive\n\t\t);\n\n\t\tlet extendToTop: number;\n\t\tfor (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n\t\t\tconst origLine = move.original.startLineNumber - extendToTop - 1;\n\t\t\tconst modLine = move.modified.startLineNumber - extendToTop - 1;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToTop > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n\t\t}\n\n\t\tlet extendToBottom: number;\n\t\tfor (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n\t\t\tconst origLine = move.original.endLineNumberExclusive + extendToBottom;\n\t\t\tconst modLine = move.modified.endLineNumberExclusive + extendToBottom;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToBottom > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n\t\t}\n\n\t\tif (extendToTop > 0 || extendToBottom > 0) {\n\t\t\tmoves[i] = new LineRangeMapping(\n\t\t\t\tnew LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom),\n\t\t\t\tnew LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn moves;\n}\n\nfunction areLinesSimilar(line1: string, line2: string, timeout: ITimeout): boolean {\n\tif (line1.trim() === line2.trim()) { return true; }\n\tif (line1.length > 300 && line2.length > 300) { return false; }\n\n\tconst myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\tconst result = myersDiffingAlgorithm.compute(\n\t\tnew LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false),\n\t\tnew LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false),\n\t\ttimeout\n\t);\n\tlet commonNonSpaceCharCount = 0;\n\tconst inverted = SequenceDiff.invert(result.diffs, line1.length);\n\tfor (const seq of inverted) {\n\t\tseq.seq1Range.forEach(idx => {\n\t\t\tif (!isSpace(line1.charCodeAt(idx))) {\n\t\t\t\tcommonNonSpaceCharCount++;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction countNonWsChars(str: string): number {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < line1.length; i++) {\n\t\t\tif (!isSpace(str.charCodeAt(i))) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tconst longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n\tconst r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n\treturn r;\n}\n\nfunction joinCloseConsecutiveMoves(moves: LineRangeMapping[]): LineRangeMapping[] {\n\tif (moves.length === 0) {\n\t\treturn moves;\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst result = [moves[0]];\n\tfor (let i = 1; i < moves.length; i++) {\n\t\tconst last = result[result.length - 1];\n\t\tconst current = moves[i];\n\n\t\tconst originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n\t\tconst modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n\t\tconst currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n\n\t\tif (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n\t\t\tresult[result.length - 1] = last.join(current);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(current);\n\t}\n\treturn result;\n}\n\nfunction removeMovesInSameDiff(changes: DetailedLineRangeMapping[], moves: LineRangeMapping[]) {\n\tconst changesMonotonous = new MonotonousArray(changes);\n\tmoves = moves.filter(m => {\n\t\tconst diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n\t\t\t|| new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n\t\tconst diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n\n\t\tconst differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n\t\treturn differentDiffs;\n\t});\n\treturn moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence, OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport function optimizeSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n\t\t\t\t\tnew OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n\t\t\t\t\tnew OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n\n\t\tconst seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n\t\tconst seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(diff: SequenceDiff, sequence1: ISequence, sequence2: ISequence, seq1ValidRange: OffsetRange, seq2ValidRange: OffsetRange,) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score = sequence1.getBoundaryScore!(seq1Offset) + sequence2.getBoundaryScore!(seq2OffsetStart) + sequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n\tfindParent: (seq: LinesSliceCharSequence, idx: number) => OffsetRange | undefined,\n\tforce: boolean = false,\n): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = findParent(sequence1, pair.offset1);\n\t\tconst w2 = findParent(sequence2, pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = findParent(sequence1, next.seq1Range.start);\n\t\t\tconst v2 = findParent(sequence2, next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((force && equalChars1 + equalChars2 < w.seq1Range.length + w.seq2Range.length) || equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(sequenceDiffs1: SequenceDiff[], sequenceDiffs2: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1: LineSequence, _sequence2: LineSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n\t\t\t\tif (unchangedTextWithoutWs.length <= 4\n\t\t\t\t\t&& (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n\t\t\t\t\t+ Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n\t\t\tnewDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence, OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport function optimizeSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n\t\t\t\t\tnew OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n\t\t\t\t\tnew OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n\n\t\tconst seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n\t\tconst seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(diff: SequenceDiff, sequence1: ISequence, sequence2: ISequence, seq1ValidRange: OffsetRange, seq2ValidRange: OffsetRange,) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score = sequence1.getBoundaryScore!(seq1Offset) + sequence2.getBoundaryScore!(seq2OffsetStart) + sequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n\tfindParent: (seq: LinesSliceCharSequence, idx: number) => OffsetRange | undefined,\n\tforce: boolean = false,\n): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = findParent(sequence1, pair.offset1);\n\t\tconst w2 = findParent(sequence2, pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = findParent(sequence1, next.seq1Range.start);\n\t\t\tconst v2 = findParent(sequence2, next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((force && equalChars1 + equalChars2 < w.seq1Range.length + w.seq2Range.length) || equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(sequenceDiffs1: SequenceDiff[], sequenceDiffs2: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1: LineSequence, _sequence2: LineSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n\t\t\t\tif (unchangedTextWithoutWs.length <= 4\n\t\t\t\t\t&& (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n\t\t\t\t\t+ Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n\t\t\tnewDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\n\nexport class LineSequence implements ISequence {\n\tconstructor(\n\t\tprivate readonly trimmedHash: number[],\n\t\tprivate readonly lines: string[]\n\t) { }\n\n\tgetElement(offset: number): number {\n\t\treturn this.trimmedHash[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.trimmedHash.length;\n\t}\n\n\tgetBoundaryScore(length: number): number {\n\t\tconst indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n\t\tconst indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n\t\treturn 1000 - (indentationBefore + indentationAfter);\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.lines.slice(range.start, range.endExclusive).join('\\n');\n\t}\n\n\tisStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.lines[offset1] === this.lines[offset2];\n\t}\n}\n\nfunction getIndentation(str: string): number {\n\tlet i = 0;\n\twhile (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\n\nexport class LineSequence implements ISequence {\n\tconstructor(\n\t\tprivate readonly trimmedHash: number[],\n\t\tprivate readonly lines: string[]\n\t) { }\n\n\tgetElement(offset: number): number {\n\t\treturn this.trimmedHash[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.trimmedHash.length;\n\t}\n\n\tgetBoundaryScore(length: number): number {\n\t\tconst indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n\t\tconst indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n\t\treturn 1000 - (indentationBefore + indentationAfter);\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.lines.slice(range.start, range.endExclusive).join('\\n');\n\t}\n\n\tisStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.lines[offset1] === this.lines[offset2];\n\t}\n}\n\nfunction getIndentation(str: string): number {\n\tlet i = 0;\n\twhile (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertFn } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ArrayText } from '../../core/text/abstractText.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, lineRangeMappingFromRangeMappings, RangeMapping } from '../rangeMapping.js';\nimport { DateTimeout, InfiniteTimeout, ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tif (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n\t\t\treturn new LinesDiff([\n\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n\t\t\t\t\t\t\tnew Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1),\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t], [], false);\n\t\t}\n\n\t\tconst timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 + Math.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst original = new ArrayText(originalLines);\n\t\tconst modified = new ArrayText(modifiedLines);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(alignments, original, modified);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges, options);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) { return false; }\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) { return false; }\n\t\t\t\tif (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) { return false; }\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n\t\t\t\t\t\tvalidatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t\toptions: ILinesDiffComputerOptions,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map(m => {\n\t\t\tconst moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, new ArrayText(originalLines), new ArrayText(modifiedLines), true);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(originalLines: string[], modifiedLines: string[], diff: SequenceDiff, timeout: ITimeout, considerWhitespaceChanges: boolean, options: ILinesDiffComputerOptions): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n\n\t\tconst slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n\t\tconst slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n\n\t\tconst diffResult = slice1.length + slice2.length < 500\n\t\t\t? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findWordContaining(idx));\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tif (options.extendToSubwords) {\n\t\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findSubWordContaining(idx), true);\n\t\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\t}\n\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range)\n\t\t\t\t)\n\t\t);\n\n\t\tif (check) { RangeMapping.assertSorted(result); }\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n\t\tnew LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1),\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertFn } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ArrayText } from '../../core/text/abstractText.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, lineRangeMappingFromRangeMappings, RangeMapping } from '../rangeMapping.js';\nimport { DateTimeout, InfiniteTimeout, ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tif (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n\t\t\treturn new LinesDiff([\n\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n\t\t\t\t\t\t\tnew Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1),\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t], [], false);\n\t\t}\n\n\t\tconst timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 + Math.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst original = new ArrayText(originalLines);\n\t\tconst modified = new ArrayText(modifiedLines);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(alignments, original, modified);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges, options);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) { return false; }\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) { return false; }\n\t\t\t\tif (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) { return false; }\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n\t\t\t\t\t\tvalidatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t\toptions: ILinesDiffComputerOptions,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map(m => {\n\t\t\tconst moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, new ArrayText(originalLines), new ArrayText(modifiedLines), true);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(originalLines: string[], modifiedLines: string[], diff: SequenceDiff, timeout: ITimeout, considerWhitespaceChanges: boolean, options: ILinesDiffComputerOptions): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n\n\t\tconst slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n\t\tconst slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n\n\t\tconst diffResult = slice1.length + slice2.length < 500\n\t\t\t? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findWordContaining(idx));\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tif (options.extendToSubwords) {\n\t\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findSubWordContaining(idx), true);\n\t\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\t}\n\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range)\n\t\t\t\t)\n\t\t);\n\n\t\tif (check) { RangeMapping.assertSorted(result); }\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n\t\tnew LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1),\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { ILinesDiffComputer } from './linesDiffComputer.js';\n\nexport const linesDiffComputers = {\n\tgetLegacy: () => new LegacyLinesDiffComputer(),\n\tgetDefault: () => new DefaultLinesDiffComputer(),\n} satisfies Record<string, () => ILinesDiffComputer>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { ILinesDiffComputer } from './linesDiffComputer.js';\n\nexport const linesDiffComputers = {\n\tgetLegacy: () => new LegacyLinesDiffComputer(),\n\tgetDefault: () => new DefaultLinesDiffComputer(),\n} satisfies Record<string, () => ILinesDiffComputer>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\n\nfunction roundFloat(number: number, decimalPoints: number): number {\n\tconst decimal = Math.pow(10, decimalPoints);\n\treturn Math.round(number * decimal) / decimal;\n}\n\nexport class RGBA {\n\t_rgbaBrand: void = undefined;\n\n\t/**\n\t * Red: integer in [0-255]\n\t */\n\treadonly r: number;\n\n\t/**\n\t * Green: integer in [0-255]\n\t */\n\treadonly g: number;\n\n\t/**\n\t * Blue: integer in [0-255]\n\t */\n\treadonly b: number;\n\n\t/**\n\t * Alpha: float in [0-1]\n\t */\n\treadonly a: number;\n\n\tconstructor(r: number, g: number, b: number, a: number = 1) {\n\t\tthis.r = Math.min(255, Math.max(0, r)) | 0;\n\t\tthis.g = Math.min(255, Math.max(0, g)) | 0;\n\t\tthis.b = Math.min(255, Math.max(0, b)) | 0;\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: RGBA, b: RGBA): boolean {\n\t\treturn a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n\t}\n}\n\nexport class HSLA {\n\n\t_hslaBrand: void = undefined;\n\n\t/**\n\t * Hue: integer in [0, 360]\n\t */\n\treadonly h: number;\n\n\t/**\n\t * Saturation: float in [0, 1]\n\t */\n\treadonly s: number;\n\n\t/**\n\t * Luminosity: float in [0, 1]\n\t */\n\treadonly l: number;\n\n\t/**\n\t * Alpha: float in [0, 1]\n\t */\n\treadonly a: number;\n\n\tconstructor(h: number, s: number, l: number, a: number) {\n\t\tthis.h = Math.max(Math.min(360, h), 0) | 0;\n\t\tthis.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n\t\tthis.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: HSLA, b: HSLA): boolean {\n\t\treturn a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\n\t}\n\n\t/**\n\t * Converts an RGB color value to HSL. Conversion formula\n\t * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\t * Assumes r, g, and b are contained in the set [0, 255] and\n\t * returns h in the set [0, 360], s, and l in the set [0, 1].\n\t */\n\tstatic fromRGBA(rgba: RGBA): HSLA {\n\t\tconst r = rgba.r / 255;\n\t\tconst g = rgba.g / 255;\n\t\tconst b = rgba.b / 255;\n\t\tconst a = rgba.a;\n\n\t\tconst max = Math.max(r, g, b);\n\t\tconst min = Math.min(r, g, b);\n\t\tlet h = 0;\n\t\tlet s = 0;\n\t\tconst l = (min + max) / 2;\n\t\tconst chroma = max - min;\n\n\t\tif (chroma > 0) {\n\t\t\ts = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\n\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / chroma + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / chroma + 2; break;\n\t\t\t\tcase b: h = (r - g) / chroma + 4; break;\n\t\t\t}\n\n\t\t\th *= 60;\n\t\t\th = Math.round(h);\n\t\t}\n\t\treturn new HSLA(h, s, l, a);\n\t}\n\n\tprivate static _hue2rgb(p: number, q: number, t: number): number {\n\t\tif (t < 0) {\n\t\t\tt += 1;\n\t\t}\n\t\tif (t > 1) {\n\t\t\tt -= 1;\n\t\t}\n\t\tif (t < 1 / 6) {\n\t\t\treturn p + (q - p) * 6 * t;\n\t\t}\n\t\tif (t < 1 / 2) {\n\t\t\treturn q;\n\t\t}\n\t\tif (t < 2 / 3) {\n\t\t\treturn p + (q - p) * (2 / 3 - t) * 6;\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Converts an HSL color value to RGB. Conversion formula\n\t * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\t * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n\t * returns r, g, and b in the set [0, 255].\n\t */\n\tstatic toRGBA(hsla: HSLA): RGBA {\n\t\tconst h = hsla.h / 360;\n\t\tconst { s, l, a } = hsla;\n\t\tlet r: number, g: number, b: number;\n\n\t\tif (s === 0) {\n\t\t\tr = g = b = l; // achromatic\n\t\t} else {\n\t\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\tconst p = 2 * l - q;\n\t\t\tr = HSLA._hue2rgb(p, q, h + 1 / 3);\n\t\t\tg = HSLA._hue2rgb(p, q, h);\n\t\t\tb = HSLA._hue2rgb(p, q, h - 1 / 3);\n\t\t}\n\n\t\treturn new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\n\t}\n}\n\nexport class HSVA {\n\n\t_hsvaBrand: void = undefined;\n\n\t/**\n\t * Hue: integer in [0, 360]\n\t */\n\treadonly h: number;\n\n\t/**\n\t * Saturation: float in [0, 1]\n\t */\n\treadonly s: number;\n\n\t/**\n\t * Value: float in [0, 1]\n\t */\n\treadonly v: number;\n\n\t/**\n\t * Alpha: float in [0, 1]\n\t */\n\treadonly a: number;\n\n\tconstructor(h: number, s: number, v: number, a: number) {\n\t\tthis.h = Math.max(Math.min(360, h), 0) | 0;\n\t\tthis.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n\t\tthis.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: HSVA, b: HSVA): boolean {\n\t\treturn a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\n\t}\n\n\t// from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n\tstatic fromRGBA(rgba: RGBA): HSVA {\n\t\tconst r = rgba.r / 255;\n\t\tconst g = rgba.g / 255;\n\t\tconst b = rgba.b / 255;\n\t\tconst cmax = Math.max(r, g, b);\n\t\tconst cmin = Math.min(r, g, b);\n\t\tconst delta = cmax - cmin;\n\t\tconst s = cmax === 0 ? 0 : (delta / cmax);\n\t\tlet m: number;\n\n\t\tif (delta === 0) {\n\t\t\tm = 0;\n\t\t} else if (cmax === r) {\n\t\t\tm = ((((g - b) / delta) % 6) + 6) % 6;\n\t\t} else if (cmax === g) {\n\t\t\tm = ((b - r) / delta) + 2;\n\t\t} else {\n\t\t\tm = ((r - g) / delta) + 4;\n\t\t}\n\n\t\treturn new HSVA(Math.round(m * 60), s, cmax, rgba.a);\n\t}\n\n\t// from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n\tstatic toRGBA(hsva: HSVA): RGBA {\n\t\tconst { h, s, v, a } = hsva;\n\t\tconst c = v * s;\n\t\tconst x = c * (1 - Math.abs((h / 60) % 2 - 1));\n\t\tconst m = v - c;\n\t\tlet [r, g, b] = [0, 0, 0];\n\n\t\tif (h < 60) {\n\t\t\tr = c;\n\t\t\tg = x;\n\t\t} else if (h < 120) {\n\t\t\tr = x;\n\t\t\tg = c;\n\t\t} else if (h < 180) {\n\t\t\tg = c;\n\t\t\tb = x;\n\t\t} else if (h < 240) {\n\t\t\tg = x;\n\t\t\tb = c;\n\t\t} else if (h < 300) {\n\t\t\tr = x;\n\t\t\tb = c;\n\t\t} else if (h <= 360) {\n\t\t\tr = c;\n\t\t\tb = x;\n\t\t}\n\n\t\tr = Math.round((r + m) * 255);\n\t\tg = Math.round((g + m) * 255);\n\t\tb = Math.round((b + m) * 255);\n\n\t\treturn new RGBA(r, g, b, a);\n\t}\n}\n\nexport class Color {\n\n\tstatic fromHex(hex: string): Color {\n\t\treturn Color.Format.CSS.parseHex(hex) || Color.red;\n\t}\n\n\tstatic equals(a: Color | null, b: Color | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.equals(b);\n\t}\n\n\treadonly rgba: RGBA;\n\tprivate _hsla?: HSLA;\n\tget hsla(): HSLA {\n\t\tif (this._hsla) {\n\t\t\treturn this._hsla;\n\t\t} else {\n\t\t\treturn HSLA.fromRGBA(this.rgba);\n\t\t}\n\t}\n\n\tprivate _hsva?: HSVA;\n\tget hsva(): HSVA {\n\t\tif (this._hsva) {\n\t\t\treturn this._hsva;\n\t\t}\n\t\treturn HSVA.fromRGBA(this.rgba);\n\t}\n\n\tconstructor(arg: RGBA | HSLA | HSVA) {\n\t\tif (!arg) {\n\t\t\tthrow new Error('Color needs a value');\n\t\t} else if (arg instanceof RGBA) {\n\t\t\tthis.rgba = arg;\n\t\t} else if (arg instanceof HSLA) {\n\t\t\tthis._hsla = arg;\n\t\t\tthis.rgba = HSLA.toRGBA(arg);\n\t\t} else if (arg instanceof HSVA) {\n\t\t\tthis._hsva = arg;\n\t\t\tthis.rgba = HSVA.toRGBA(arg);\n\t\t} else {\n\t\t\tthrow new Error('Invalid color ctor argument');\n\t\t}\n\t}\n\n\tequals(other: Color | null): boolean {\n\t\treturn !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\n\t}\n\n\t/**\n\t * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.\n\t */\n\tgetRelativeLuminance(): number {\n\t\tconst R = Color._relativeLuminanceForComponent(this.rgba.r);\n\t\tconst G = Color._relativeLuminanceForComponent(this.rgba.g);\n\t\tconst B = Color._relativeLuminanceForComponent(this.rgba.b);\n\t\tconst luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n\n\t\treturn roundFloat(luminance, 4);\n\t}\n\n\t/**\n\t * Reduces the \"foreground\" color on this \"background\" color unti it is\n\t * below the relative luminace ratio.\n\t * @returns the new foreground color\n\t * @see https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L315\n\t */\n\treduceRelativeLuminace(foreground: Color, ratio: number): Color {\n\t\t// This is a naive but fast approach to reducing luminance as converting to\n\t\t// HSL and back is expensive\n\t\tlet { r: fgR, g: fgG, b: fgB } = foreground.rgba;\n\n\t\tlet cr = this.getContrastRatio(foreground);\n\t\twhile (cr < ratio && (fgR > 0 || fgG > 0 || fgB > 0)) {\n\t\t\t// Reduce by 10% until the ratio is hit\n\t\t\tfgR -= Math.max(0, Math.ceil(fgR * 0.1));\n\t\t\tfgG -= Math.max(0, Math.ceil(fgG * 0.1));\n\t\t\tfgB -= Math.max(0, Math.ceil(fgB * 0.1));\n\t\t\tcr = this.getContrastRatio(new Color(new RGBA(fgR, fgG, fgB)));\n\t\t}\n\n\t\treturn new Color(new RGBA(fgR, fgG, fgB));\n\t}\n\n\t/**\n\t * Increases the \"foreground\" color on this \"background\" color unti it is\n\t * below the relative luminace ratio.\n\t * @returns the new foreground color\n\t * @see https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L335\n\t */\n\tincreaseRelativeLuminace(foreground: Color, ratio: number): Color {\n\t\t// This is a naive but fast approach to reducing luminance as converting to\n\t\t// HSL and back is expensive\n\t\tlet { r: fgR, g: fgG, b: fgB } = foreground.rgba;\n\t\tlet cr = this.getContrastRatio(foreground);\n\t\twhile (cr < ratio && (fgR < 0xFF || fgG < 0xFF || fgB < 0xFF)) {\n\t\t\tfgR = Math.min(0xFF, fgR + Math.ceil((255 - fgR) * 0.1));\n\t\t\tfgG = Math.min(0xFF, fgG + Math.ceil((255 - fgG) * 0.1));\n\t\t\tfgB = Math.min(0xFF, fgB + Math.ceil((255 - fgB) * 0.1));\n\t\t\tcr = this.getContrastRatio(new Color(new RGBA(fgR, fgG, fgB)));\n\t\t}\n\n\t\treturn new Color(new RGBA(fgR, fgG, fgB));\n\t}\n\n\tprivate static _relativeLuminanceForComponent(color: number): number {\n\t\tconst c = color / 255;\n\t\treturn (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\n\t}\n\n\t/**\n\t * http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t * Returns the contrast ration number in the set [1, 21].\n\t */\n\tgetContrastRatio(another: Color): number {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n\t}\n\n\t/**\n\t *\thttp://24ways.org/2010/calculating-color-contrast\n\t *  Return 'true' if darker color otherwise 'false'\n\t */\n\tisDarker(): boolean {\n\t\tconst yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n\t\treturn yiq < 128;\n\t}\n\n\t/**\n\t *\thttp://24ways.org/2010/calculating-color-contrast\n\t *  Return 'true' if lighter color otherwise 'false'\n\t */\n\tisLighter(): boolean {\n\t\tconst yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n\t\treturn yiq >= 128;\n\t}\n\n\tisLighterThan(another: Color): boolean {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 > lum2;\n\t}\n\n\tisDarkerThan(another: Color): boolean {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 < lum2;\n\t}\n\n\t/**\n\t * Based on xterm.js: https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L288\n\t *\n\t * Given a foreground color and a background color, either increase or reduce the luminance of the\n\t * foreground color until the specified contrast ratio is met. If pure white or black is hit\n\t * without the contrast ratio being met, go the other direction using the background color as the\n\t * foreground color and take either the first or second result depending on which has the higher\n\t * contrast ratio.\n\t *\n\t * @param foreground The foreground color.\n\t * @param ratio The contrast ratio to achieve.\n\t * @returns The adjusted foreground color.\n\t */\n\tensureConstrast(foreground: Color, ratio: number): Color {\n\t\tconst bgL = this.getRelativeLuminance();\n\t\tconst fgL = foreground.getRelativeLuminance();\n\t\tconst cr = this.getContrastRatio(foreground);\n\t\tif (cr < ratio) {\n\t\t\tif (fgL < bgL) {\n\t\t\t\tconst resultA = this.reduceRelativeLuminace(foreground, ratio);\n\t\t\t\tconst resultARatio = this.getContrastRatio(resultA);\n\t\t\t\tif (resultARatio < ratio) {\n\t\t\t\t\tconst resultB = this.increaseRelativeLuminace(foreground, ratio);\n\t\t\t\t\tconst resultBRatio = this.getContrastRatio(resultB);\n\t\t\t\t\treturn resultARatio > resultBRatio ? resultA : resultB;\n\t\t\t\t}\n\t\t\t\treturn resultA;\n\t\t\t}\n\t\t\tconst resultA = this.increaseRelativeLuminace(foreground, ratio);\n\t\t\tconst resultARatio = this.getContrastRatio(resultA);\n\t\t\tif (resultARatio < ratio) {\n\t\t\t\tconst resultB = this.reduceRelativeLuminace(foreground, ratio);\n\t\t\t\tconst resultBRatio = this.getContrastRatio(resultB);\n\t\t\t\treturn resultARatio > resultBRatio ? resultA : resultB;\n\t\t\t}\n\t\t\treturn resultA;\n\t\t}\n\n\t\treturn foreground;\n\t}\n\n\tlighten(factor: number): Color {\n\t\treturn new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n\t}\n\n\tdarken(factor: number): Color {\n\t\treturn new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n\t}\n\n\ttransparent(factor: number): Color {\n\t\tconst { r, g, b, a } = this.rgba;\n\t\treturn new Color(new RGBA(r, g, b, a * factor));\n\t}\n\n\tisTransparent(): boolean {\n\t\treturn this.rgba.a === 0;\n\t}\n\n\tisOpaque(): boolean {\n\t\treturn this.rgba.a === 1;\n\t}\n\n\topposite(): Color {\n\t\treturn new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n\t}\n\n\tblend(c: Color): Color {\n\t\tconst rgba = c.rgba;\n\n\t\t// Convert to 0..1 opacity\n\t\tconst thisA = this.rgba.a;\n\t\tconst colorA = rgba.a;\n\n\t\tconst a = thisA + colorA * (1 - thisA);\n\t\tif (a < 1e-6) {\n\t\t\treturn Color.transparent;\n\t\t}\n\n\t\tconst r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;\n\t\tconst g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;\n\t\tconst b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;\n\n\t\treturn new Color(new RGBA(r, g, b, a));\n\t}\n\n\t/**\n\t * Mixes the current color with the provided color based on the given factor.\n\t * @param color The color to mix with\n\t * @param factor The factor of mixing (0 means this color, 1 means the input color, 0.5 means equal mix)\n\t * @returns A new color representing the mix\n\t */\n\tmix(color: Color, factor: number = 0.5): Color {\n\t\tconst normalize = Math.min(Math.max(factor, 0), 1);\n\t\tconst thisRGBA = this.rgba;\n\t\tconst otherRGBA = color.rgba;\n\n\t\tconst r = thisRGBA.r + (otherRGBA.r - thisRGBA.r) * normalize;\n\t\tconst g = thisRGBA.g + (otherRGBA.g - thisRGBA.g) * normalize;\n\t\tconst b = thisRGBA.b + (otherRGBA.b - thisRGBA.b) * normalize;\n\t\tconst a = thisRGBA.a + (otherRGBA.a - thisRGBA.a) * normalize;\n\n\t\treturn new Color(new RGBA(r, g, b, a));\n\t}\n\n\tmakeOpaque(opaqueBackground: Color): Color {\n\t\tif (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n\t\t\t// only allow to blend onto a non-opaque color onto a opaque color\n\t\t\treturn this;\n\t\t}\n\n\t\tconst { r, g, b, a } = this.rgba;\n\n\t\t// https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity\n\t\treturn new Color(new RGBA(\n\t\t\topaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r),\n\t\t\topaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g),\n\t\t\topaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b),\n\t\t\t1\n\t\t));\n\t}\n\n\tflatten(...backgrounds: Color[]): Color {\n\t\tconst background = backgrounds.reduceRight((accumulator, color) => {\n\t\t\treturn Color._flatten(color, accumulator);\n\t\t});\n\t\treturn Color._flatten(this, background);\n\t}\n\n\tprivate static _flatten(foreground: Color, background: Color) {\n\t\tconst backgroundAlpha = 1 - foreground.rgba.a;\n\t\treturn new Color(new RGBA(\n\t\t\tbackgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r,\n\t\t\tbackgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g,\n\t\t\tbackgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b\n\t\t));\n\t}\n\n\tprivate _toString?: string;\n\ttoString(): string {\n\t\tif (!this._toString) {\n\t\t\tthis._toString = Color.Format.CSS.format(this);\n\t\t}\n\t\treturn this._toString;\n\t}\n\n\tprivate _toNumber32Bit?: number;\n\ttoNumber32Bit(): number {\n\t\tif (!this._toNumber32Bit) {\n\t\t\tthis._toNumber32Bit = (\n\t\t\t\tthis.rgba.r /*  */ << 24 |\n\t\t\t\tthis.rgba.g /*  */ << 16 |\n\t\t\t\tthis.rgba.b /*  */ << 8 |\n\t\t\t\tthis.rgba.a * 0xFF << 0\n\t\t\t) >>> 0;\n\t\t}\n\t\treturn this._toNumber32Bit;\n\t}\n\n\tstatic getLighterColor(of: Color, relative: Color, factor?: number): Color {\n\t\tif (of.isLighterThan(relative)) {\n\t\t\treturn of;\n\t\t}\n\t\tfactor = factor ? factor : 0.5;\n\t\tconst lum1 = of.getRelativeLuminance();\n\t\tconst lum2 = relative.getRelativeLuminance();\n\t\tfactor = factor * (lum2 - lum1) / lum2;\n\t\treturn of.lighten(factor);\n\t}\n\n\tstatic getDarkerColor(of: Color, relative: Color, factor?: number): Color {\n\t\tif (of.isDarkerThan(relative)) {\n\t\t\treturn of;\n\t\t}\n\t\tfactor = factor ? factor : 0.5;\n\t\tconst lum1 = of.getRelativeLuminance();\n\t\tconst lum2 = relative.getRelativeLuminance();\n\t\tfactor = factor * (lum1 - lum2) / lum1;\n\t\treturn of.darken(factor);\n\t}\n\n\tstatic readonly white = new Color(new RGBA(255, 255, 255, 1));\n\tstatic readonly black = new Color(new RGBA(0, 0, 0, 1));\n\tstatic readonly red = new Color(new RGBA(255, 0, 0, 1));\n\tstatic readonly blue = new Color(new RGBA(0, 0, 255, 1));\n\tstatic readonly green = new Color(new RGBA(0, 255, 0, 1));\n\tstatic readonly cyan = new Color(new RGBA(0, 255, 255, 1));\n\tstatic readonly lightgrey = new Color(new RGBA(211, 211, 211, 1));\n\tstatic readonly transparent = new Color(new RGBA(0, 0, 0, 0));\n}\n\nexport namespace Color {\n\texport namespace Format {\n\t\texport namespace CSS {\n\n\t\t\texport function formatRGB(color: Color): string {\n\t\t\t\tif (color.rgba.a === 1) {\n\t\t\t\t\treturn `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatRGBA(color);\n\t\t\t}\n\n\t\t\texport function formatRGBA(color: Color): string {\n\t\t\t\treturn `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\n\t\t\t}\n\n\t\t\texport function formatHSL(color: Color): string {\n\t\t\t\tif (color.hsla.a === 1) {\n\t\t\t\t\treturn `hsl(${color.hsla.h}, ${Math.round(color.hsla.s * 100)}%, ${Math.round(color.hsla.l * 100)}%)`;\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatHSLA(color);\n\t\t\t}\n\n\t\t\texport function formatHSLA(color: Color): string {\n\t\t\t\treturn `hsla(${color.hsla.h}, ${Math.round(color.hsla.s * 100)}%, ${Math.round(color.hsla.l * 100)}%, ${color.hsla.a.toFixed(2)})`;\n\t\t\t}\n\n\t\t\tfunction _toTwoDigitHex(n: number): string {\n\t\t\t\tconst r = n.toString(16);\n\t\t\t\treturn r.length !== 2 ? '0' + r : r;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Formats the color as #RRGGBB\n\t\t\t */\n\t\t\texport function formatHex(color: Color): string {\n\t\t\t\treturn `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Formats the color as #RRGGBBAA\n\t\t\t * If 'compact' is set, colors without transparancy will be printed as #RRGGBB\n\t\t\t */\n\t\t\texport function formatHexA(color: Color, compact = false): string {\n\t\t\t\tif (compact && color.rgba.a === 1) {\n\t\t\t\t\treturn Color.Format.CSS.formatHex(color);\n\t\t\t\t}\n\n\t\t\t\treturn `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The default format will use HEX if opaque and RGBA otherwise.\n\t\t\t */\n\t\t\texport function format(color: Color): string {\n\t\t\t\tif (color.isOpaque()) {\n\t\t\t\t\treturn Color.Format.CSS.formatHex(color);\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatRGBA(color);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Parse a CSS color and return a {@link Color}.\n\t\t\t * @param css The CSS color to parse.\n\t\t\t * @see https://drafts.csswg.org/css-color/#typedef-color\n\t\t\t */\n\t\t\texport function parse(css: string): Color | null {\n\t\t\t\tif (css === 'transparent') {\n\t\t\t\t\treturn Color.transparent;\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('#')) {\n\t\t\t\t\treturn parseHex(css);\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('rgba(')) {\n\t\t\t\t\tconst color = css.match(/rgba\\((?<r>(?:\\+|-)?\\d+), *(?<g>(?:\\+|-)?\\d+), *(?<b>(?:\\+|-)?\\d+), *(?<a>(?:\\+|-)?\\d+(\\.\\d+)?)\\)/);\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tthrow new Error('Invalid color format ' + css);\n\t\t\t\t\t}\n\t\t\t\t\tconst r = parseInt(color.groups?.r ?? '0');\n\t\t\t\t\tconst g = parseInt(color.groups?.g ?? '0');\n\t\t\t\t\tconst b = parseInt(color.groups?.b ?? '0');\n\t\t\t\t\tconst a = parseFloat(color.groups?.a ?? '0');\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, a));\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('rgb(')) {\n\t\t\t\t\tconst color = css.match(/rgb\\((?<r>(?:\\+|-)?\\d+), *(?<g>(?:\\+|-)?\\d+), *(?<b>(?:\\+|-)?\\d+)\\)/);\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tthrow new Error('Invalid color format ' + css);\n\t\t\t\t\t}\n\t\t\t\t\tconst r = parseInt(color.groups?.r ?? '0');\n\t\t\t\t\tconst g = parseInt(color.groups?.g ?? '0');\n\t\t\t\t\tconst b = parseInt(color.groups?.b ?? '0');\n\t\t\t\t\treturn new Color(new RGBA(r, g, b));\n\t\t\t\t}\n\t\t\t\t// TODO: Support more formats as needed\n\t\t\t\treturn parseNamedKeyword(css);\n\t\t\t}\n\n\t\t\tfunction parseNamedKeyword(css: string): Color | null {\n\t\t\t\t// https://drafts.csswg.org/css-color/#named-colors\n\t\t\t\tswitch (css) {\n\t\t\t\t\tcase 'aliceblue': return new Color(new RGBA(240, 248, 255, 1));\n\t\t\t\t\tcase 'antiquewhite': return new Color(new RGBA(250, 235, 215, 1));\n\t\t\t\t\tcase 'aqua': return new Color(new RGBA(0, 255, 255, 1));\n\t\t\t\t\tcase 'aquamarine': return new Color(new RGBA(127, 255, 212, 1));\n\t\t\t\t\tcase 'azure': return new Color(new RGBA(240, 255, 255, 1));\n\t\t\t\t\tcase 'beige': return new Color(new RGBA(245, 245, 220, 1));\n\t\t\t\t\tcase 'bisque': return new Color(new RGBA(255, 228, 196, 1));\n\t\t\t\t\tcase 'black': return new Color(new RGBA(0, 0, 0, 1));\n\t\t\t\t\tcase 'blanchedalmond': return new Color(new RGBA(255, 235, 205, 1));\n\t\t\t\t\tcase 'blue': return new Color(new RGBA(0, 0, 255, 1));\n\t\t\t\t\tcase 'blueviolet': return new Color(new RGBA(138, 43, 226, 1));\n\t\t\t\t\tcase 'brown': return new Color(new RGBA(165, 42, 42, 1));\n\t\t\t\t\tcase 'burlywood': return new Color(new RGBA(222, 184, 135, 1));\n\t\t\t\t\tcase 'cadetblue': return new Color(new RGBA(95, 158, 160, 1));\n\t\t\t\t\tcase 'chartreuse': return new Color(new RGBA(127, 255, 0, 1));\n\t\t\t\t\tcase 'chocolate': return new Color(new RGBA(210, 105, 30, 1));\n\t\t\t\t\tcase 'coral': return new Color(new RGBA(255, 127, 80, 1));\n\t\t\t\t\tcase 'cornflowerblue': return new Color(new RGBA(100, 149, 237, 1));\n\t\t\t\t\tcase 'cornsilk': return new Color(new RGBA(255, 248, 220, 1));\n\t\t\t\t\tcase 'crimson': return new Color(new RGBA(220, 20, 60, 1));\n\t\t\t\t\tcase 'cyan': return new Color(new RGBA(0, 255, 255, 1));\n\t\t\t\t\tcase 'darkblue': return new Color(new RGBA(0, 0, 139, 1));\n\t\t\t\t\tcase 'darkcyan': return new Color(new RGBA(0, 139, 139, 1));\n\t\t\t\t\tcase 'darkgoldenrod': return new Color(new RGBA(184, 134, 11, 1));\n\t\t\t\t\tcase 'darkgray': return new Color(new RGBA(169, 169, 169, 1));\n\t\t\t\t\tcase 'darkgreen': return new Color(new RGBA(0, 100, 0, 1));\n\t\t\t\t\tcase 'darkgrey': return new Color(new RGBA(169, 169, 169, 1));\n\t\t\t\t\tcase 'darkkhaki': return new Color(new RGBA(189, 183, 107, 1));\n\t\t\t\t\tcase 'darkmagenta': return new Color(new RGBA(139, 0, 139, 1));\n\t\t\t\t\tcase 'darkolivegreen': return new Color(new RGBA(85, 107, 47, 1));\n\t\t\t\t\tcase 'darkorange': return new Color(new RGBA(255, 140, 0, 1));\n\t\t\t\t\tcase 'darkorchid': return new Color(new RGBA(153, 50, 204, 1));\n\t\t\t\t\tcase 'darkred': return new Color(new RGBA(139, 0, 0, 1));\n\t\t\t\t\tcase 'darksalmon': return new Color(new RGBA(233, 150, 122, 1));\n\t\t\t\t\tcase 'darkseagreen': return new Color(new RGBA(143, 188, 143, 1));\n\t\t\t\t\tcase 'darkslateblue': return new Color(new RGBA(72, 61, 139, 1));\n\t\t\t\t\tcase 'darkslategray': return new Color(new RGBA(47, 79, 79, 1));\n\t\t\t\t\tcase 'darkslategrey': return new Color(new RGBA(47, 79, 79, 1));\n\t\t\t\t\tcase 'darkturquoise': return new Color(new RGBA(0, 206, 209, 1));\n\t\t\t\t\tcase 'darkviolet': return new Color(new RGBA(148, 0, 211, 1));\n\t\t\t\t\tcase 'deeppink': return new Color(new RGBA(255, 20, 147, 1));\n\t\t\t\t\tcase 'deepskyblue': return new Color(new RGBA(0, 191, 255, 1));\n\t\t\t\t\tcase 'dimgray': return new Color(new RGBA(105, 105, 105, 1));\n\t\t\t\t\tcase 'dimgrey': return new Color(new RGBA(105, 105, 105, 1));\n\t\t\t\t\tcase 'dodgerblue': return new Color(new RGBA(30, 144, 255, 1));\n\t\t\t\t\tcase 'firebrick': return new Color(new RGBA(178, 34, 34, 1));\n\t\t\t\t\tcase 'floralwhite': return new Color(new RGBA(255, 250, 240, 1));\n\t\t\t\t\tcase 'forestgreen': return new Color(new RGBA(34, 139, 34, 1));\n\t\t\t\t\tcase 'fuchsia': return new Color(new RGBA(255, 0, 255, 1));\n\t\t\t\t\tcase 'gainsboro': return new Color(new RGBA(220, 220, 220, 1));\n\t\t\t\t\tcase 'ghostwhite': return new Color(new RGBA(248, 248, 255, 1));\n\t\t\t\t\tcase 'gold': return new Color(new RGBA(255, 215, 0, 1));\n\t\t\t\t\tcase 'goldenrod': return new Color(new RGBA(218, 165, 32, 1));\n\t\t\t\t\tcase 'gray': return new Color(new RGBA(128, 128, 128, 1));\n\t\t\t\t\tcase 'green': return new Color(new RGBA(0, 128, 0, 1));\n\t\t\t\t\tcase 'greenyellow': return new Color(new RGBA(173, 255, 47, 1));\n\t\t\t\t\tcase 'grey': return new Color(new RGBA(128, 128, 128, 1));\n\t\t\t\t\tcase 'honeydew': return new Color(new RGBA(240, 255, 240, 1));\n\t\t\t\t\tcase 'hotpink': return new Color(new RGBA(255, 105, 180, 1));\n\t\t\t\t\tcase 'indianred': return new Color(new RGBA(205, 92, 92, 1));\n\t\t\t\t\tcase 'indigo': return new Color(new RGBA(75, 0, 130, 1));\n\t\t\t\t\tcase 'ivory': return new Color(new RGBA(255, 255, 240, 1));\n\t\t\t\t\tcase 'khaki': return new Color(new RGBA(240, 230, 140, 1));\n\t\t\t\t\tcase 'lavender': return new Color(new RGBA(230, 230, 250, 1));\n\t\t\t\t\tcase 'lavenderblush': return new Color(new RGBA(255, 240, 245, 1));\n\t\t\t\t\tcase 'lawngreen': return new Color(new RGBA(124, 252, 0, 1));\n\t\t\t\t\tcase 'lemonchiffon': return new Color(new RGBA(255, 250, 205, 1));\n\t\t\t\t\tcase 'lightblue': return new Color(new RGBA(173, 216, 230, 1));\n\t\t\t\t\tcase 'lightcoral': return new Color(new RGBA(240, 128, 128, 1));\n\t\t\t\t\tcase 'lightcyan': return new Color(new RGBA(224, 255, 255, 1));\n\t\t\t\t\tcase 'lightgoldenrodyellow': return new Color(new RGBA(250, 250, 210, 1));\n\t\t\t\t\tcase 'lightgray': return new Color(new RGBA(211, 211, 211, 1));\n\t\t\t\t\tcase 'lightgreen': return new Color(new RGBA(144, 238, 144, 1));\n\t\t\t\t\tcase 'lightgrey': return new Color(new RGBA(211, 211, 211, 1));\n\t\t\t\t\tcase 'lightpink': return new Color(new RGBA(255, 182, 193, 1));\n\t\t\t\t\tcase 'lightsalmon': return new Color(new RGBA(255, 160, 122, 1));\n\t\t\t\t\tcase 'lightseagreen': return new Color(new RGBA(32, 178, 170, 1));\n\t\t\t\t\tcase 'lightskyblue': return new Color(new RGBA(135, 206, 250, 1));\n\t\t\t\t\tcase 'lightslategray': return new Color(new RGBA(119, 136, 153, 1));\n\t\t\t\t\tcase 'lightslategrey': return new Color(new RGBA(119, 136, 153, 1));\n\t\t\t\t\tcase 'lightsteelblue': return new Color(new RGBA(176, 196, 222, 1));\n\t\t\t\t\tcase 'lightyellow': return new Color(new RGBA(255, 255, 224, 1));\n\t\t\t\t\tcase 'lime': return new Color(new RGBA(0, 255, 0, 1));\n\t\t\t\t\tcase 'limegreen': return new Color(new RGBA(50, 205, 50, 1));\n\t\t\t\t\tcase 'linen': return new Color(new RGBA(250, 240, 230, 1));\n\t\t\t\t\tcase 'magenta': return new Color(new RGBA(255, 0, 255, 1));\n\t\t\t\t\tcase 'maroon': return new Color(new RGBA(128, 0, 0, 1));\n\t\t\t\t\tcase 'mediumaquamarine': return new Color(new RGBA(102, 205, 170, 1));\n\t\t\t\t\tcase 'mediumblue': return new Color(new RGBA(0, 0, 205, 1));\n\t\t\t\t\tcase 'mediumorchid': return new Color(new RGBA(186, 85, 211, 1));\n\t\t\t\t\tcase 'mediumpurple': return new Color(new RGBA(147, 112, 219, 1));\n\t\t\t\t\tcase 'mediumseagreen': return new Color(new RGBA(60, 179, 113, 1));\n\t\t\t\t\tcase 'mediumslateblue': return new Color(new RGBA(123, 104, 238, 1));\n\t\t\t\t\tcase 'mediumspringgreen': return new Color(new RGBA(0, 250, 154, 1));\n\t\t\t\t\tcase 'mediumturquoise': return new Color(new RGBA(72, 209, 204, 1));\n\t\t\t\t\tcase 'mediumvioletred': return new Color(new RGBA(199, 21, 133, 1));\n\t\t\t\t\tcase 'midnightblue': return new Color(new RGBA(25, 25, 112, 1));\n\t\t\t\t\tcase 'mintcream': return new Color(new RGBA(245, 255, 250, 1));\n\t\t\t\t\tcase 'mistyrose': return new Color(new RGBA(255, 228, 225, 1));\n\t\t\t\t\tcase 'moccasin': return new Color(new RGBA(255, 228, 181, 1));\n\t\t\t\t\tcase 'navajowhite': return new Color(new RGBA(255, 222, 173, 1));\n\t\t\t\t\tcase 'navy': return new Color(new RGBA(0, 0, 128, 1));\n\t\t\t\t\tcase 'oldlace': return new Color(new RGBA(253, 245, 230, 1));\n\t\t\t\t\tcase 'olive': return new Color(new RGBA(128, 128, 0, 1));\n\t\t\t\t\tcase 'olivedrab': return new Color(new RGBA(107, 142, 35, 1));\n\t\t\t\t\tcase 'orange': return new Color(new RGBA(255, 165, 0, 1));\n\t\t\t\t\tcase 'orangered': return new Color(new RGBA(255, 69, 0, 1));\n\t\t\t\t\tcase 'orchid': return new Color(new RGBA(218, 112, 214, 1));\n\t\t\t\t\tcase 'palegoldenrod': return new Color(new RGBA(238, 232, 170, 1));\n\t\t\t\t\tcase 'palegreen': return new Color(new RGBA(152, 251, 152, 1));\n\t\t\t\t\tcase 'paleturquoise': return new Color(new RGBA(175, 238, 238, 1));\n\t\t\t\t\tcase 'palevioletred': return new Color(new RGBA(219, 112, 147, 1));\n\t\t\t\t\tcase 'papayawhip': return new Color(new RGBA(255, 239, 213, 1));\n\t\t\t\t\tcase 'peachpuff': return new Color(new RGBA(255, 218, 185, 1));\n\t\t\t\t\tcase 'peru': return new Color(new RGBA(205, 133, 63, 1));\n\t\t\t\t\tcase 'pink': return new Color(new RGBA(255, 192, 203, 1));\n\t\t\t\t\tcase 'plum': return new Color(new RGBA(221, 160, 221, 1));\n\t\t\t\t\tcase 'powderblue': return new Color(new RGBA(176, 224, 230, 1));\n\t\t\t\t\tcase 'purple': return new Color(new RGBA(128, 0, 128, 1));\n\t\t\t\t\tcase 'rebeccapurple': return new Color(new RGBA(102, 51, 153, 1));\n\t\t\t\t\tcase 'red': return new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t\tcase 'rosybrown': return new Color(new RGBA(188, 143, 143, 1));\n\t\t\t\t\tcase 'royalblue': return new Color(new RGBA(65, 105, 225, 1));\n\t\t\t\t\tcase 'saddlebrown': return new Color(new RGBA(139, 69, 19, 1));\n\t\t\t\t\tcase 'salmon': return new Color(new RGBA(250, 128, 114, 1));\n\t\t\t\t\tcase 'sandybrown': return new Color(new RGBA(244, 164, 96, 1));\n\t\t\t\t\tcase 'seagreen': return new Color(new RGBA(46, 139, 87, 1));\n\t\t\t\t\tcase 'seashell': return new Color(new RGBA(255, 245, 238, 1));\n\t\t\t\t\tcase 'sienna': return new Color(new RGBA(160, 82, 45, 1));\n\t\t\t\t\tcase 'silver': return new Color(new RGBA(192, 192, 192, 1));\n\t\t\t\t\tcase 'skyblue': return new Color(new RGBA(135, 206, 235, 1));\n\t\t\t\t\tcase 'slateblue': return new Color(new RGBA(106, 90, 205, 1));\n\t\t\t\t\tcase 'slategray': return new Color(new RGBA(112, 128, 144, 1));\n\t\t\t\t\tcase 'slategrey': return new Color(new RGBA(112, 128, 144, 1));\n\t\t\t\t\tcase 'snow': return new Color(new RGBA(255, 250, 250, 1));\n\t\t\t\t\tcase 'springgreen': return new Color(new RGBA(0, 255, 127, 1));\n\t\t\t\t\tcase 'steelblue': return new Color(new RGBA(70, 130, 180, 1));\n\t\t\t\t\tcase 'tan': return new Color(new RGBA(210, 180, 140, 1));\n\t\t\t\t\tcase 'teal': return new Color(new RGBA(0, 128, 128, 1));\n\t\t\t\t\tcase 'thistle': return new Color(new RGBA(216, 191, 216, 1));\n\t\t\t\t\tcase 'tomato': return new Color(new RGBA(255, 99, 71, 1));\n\t\t\t\t\tcase 'turquoise': return new Color(new RGBA(64, 224, 208, 1));\n\t\t\t\t\tcase 'violet': return new Color(new RGBA(238, 130, 238, 1));\n\t\t\t\t\tcase 'wheat': return new Color(new RGBA(245, 222, 179, 1));\n\t\t\t\t\tcase 'white': return new Color(new RGBA(255, 255, 255, 1));\n\t\t\t\t\tcase 'whitesmoke': return new Color(new RGBA(245, 245, 245, 1));\n\t\t\t\t\tcase 'yellow': return new Color(new RGBA(255, 255, 0, 1));\n\t\t\t\t\tcase 'yellowgreen': return new Color(new RGBA(154, 205, 50, 1));\n\t\t\t\t\tdefault: return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Converts an Hex color value to a Color.\n\t\t\t * returns r, g, and b are contained in the set [0, 255]\n\t\t\t * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).\n\t\t\t */\n\t\t\texport function parseHex(hex: string): Color | null {\n\t\t\t\tconst length = hex.length;\n\n\t\t\t\tif (length === 0) {\n\t\t\t\t\t// Invalid color\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (hex.charCodeAt(0) !== CharCode.Hash) {\n\t\t\t\t\t// Does not begin with a #\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (length === 7) {\n\t\t\t\t\t// #RRGGBB format\n\t\t\t\t\tconst r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\tconst b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, 1));\n\t\t\t\t}\n\n\t\t\t\tif (length === 9) {\n\t\t\t\t\t// #RRGGBBAA format\n\t\t\t\t\tconst r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\tconst b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n\t\t\t\t\tconst a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, a / 255));\n\t\t\t\t}\n\n\t\t\t\tif (length === 4) {\n\t\t\t\t\t// #RGB format\n\t\t\t\t\tconst r = _parseHexDigit(hex.charCodeAt(1));\n\t\t\t\t\tconst g = _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst b = _parseHexDigit(hex.charCodeAt(3));\n\t\t\t\t\treturn new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n\t\t\t\t}\n\n\t\t\t\tif (length === 5) {\n\t\t\t\t\t// #RGBA format\n\t\t\t\t\tconst r = _parseHexDigit(hex.charCodeAt(1));\n\t\t\t\t\tconst g = _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst b = _parseHexDigit(hex.charCodeAt(3));\n\t\t\t\t\tconst a = _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\treturn new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\n\t\t\t\t}\n\n\t\t\t\t// Invalid color\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfunction _parseHexDigit(charCode: CharCode): number {\n\t\t\t\tswitch (charCode) {\n\t\t\t\t\tcase CharCode.Digit0: return 0;\n\t\t\t\t\tcase CharCode.Digit1: return 1;\n\t\t\t\t\tcase CharCode.Digit2: return 2;\n\t\t\t\t\tcase CharCode.Digit3: return 3;\n\t\t\t\t\tcase CharCode.Digit4: return 4;\n\t\t\t\t\tcase CharCode.Digit5: return 5;\n\t\t\t\t\tcase CharCode.Digit6: return 6;\n\t\t\t\t\tcase CharCode.Digit7: return 7;\n\t\t\t\t\tcase CharCode.Digit8: return 8;\n\t\t\t\t\tcase CharCode.Digit9: return 9;\n\t\t\t\t\tcase CharCode.a: return 10;\n\t\t\t\t\tcase CharCode.A: return 10;\n\t\t\t\t\tcase CharCode.b: return 11;\n\t\t\t\t\tcase CharCode.B: return 11;\n\t\t\t\t\tcase CharCode.c: return 12;\n\t\t\t\t\tcase CharCode.C: return 12;\n\t\t\t\t\tcase CharCode.d: return 13;\n\t\t\t\t\tcase CharCode.D: return 13;\n\t\t\t\t\tcase CharCode.e: return 14;\n\t\t\t\t\tcase CharCode.E: return 14;\n\t\t\t\t\tcase CharCode.f: return 15;\n\t\t\t\t\tcase CharCode.F: return 15;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\n\nfunction roundFloat(number: number, decimalPoints: number): number {\n\tconst decimal = Math.pow(10, decimalPoints);\n\treturn Math.round(number * decimal) / decimal;\n}\n\nexport class RGBA {\n\t_rgbaBrand: void = undefined;\n\n\t/**\n\t * Red: integer in [0-255]\n\t */\n\treadonly r: number;\n\n\t/**\n\t * Green: integer in [0-255]\n\t */\n\treadonly g: number;\n\n\t/**\n\t * Blue: integer in [0-255]\n\t */\n\treadonly b: number;\n\n\t/**\n\t * Alpha: float in [0-1]\n\t */\n\treadonly a: number;\n\n\tconstructor(r: number, g: number, b: number, a: number = 1) {\n\t\tthis.r = Math.min(255, Math.max(0, r)) | 0;\n\t\tthis.g = Math.min(255, Math.max(0, g)) | 0;\n\t\tthis.b = Math.min(255, Math.max(0, b)) | 0;\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: RGBA, b: RGBA): boolean {\n\t\treturn a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n\t}\n}\n\nexport class HSLA {\n\n\t_hslaBrand: void = undefined;\n\n\t/**\n\t * Hue: integer in [0, 360]\n\t */\n\treadonly h: number;\n\n\t/**\n\t * Saturation: float in [0, 1]\n\t */\n\treadonly s: number;\n\n\t/**\n\t * Luminosity: float in [0, 1]\n\t */\n\treadonly l: number;\n\n\t/**\n\t * Alpha: float in [0, 1]\n\t */\n\treadonly a: number;\n\n\tconstructor(h: number, s: number, l: number, a: number) {\n\t\tthis.h = Math.max(Math.min(360, h), 0) | 0;\n\t\tthis.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n\t\tthis.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: HSLA, b: HSLA): boolean {\n\t\treturn a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\n\t}\n\n\t/**\n\t * Converts an RGB color value to HSL. Conversion formula\n\t * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\t * Assumes r, g, and b are contained in the set [0, 255] and\n\t * returns h in the set [0, 360], s, and l in the set [0, 1].\n\t */\n\tstatic fromRGBA(rgba: RGBA): HSLA {\n\t\tconst r = rgba.r / 255;\n\t\tconst g = rgba.g / 255;\n\t\tconst b = rgba.b / 255;\n\t\tconst a = rgba.a;\n\n\t\tconst max = Math.max(r, g, b);\n\t\tconst min = Math.min(r, g, b);\n\t\tlet h = 0;\n\t\tlet s = 0;\n\t\tconst l = (min + max) / 2;\n\t\tconst chroma = max - min;\n\n\t\tif (chroma > 0) {\n\t\t\ts = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\n\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / chroma + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / chroma + 2; break;\n\t\t\t\tcase b: h = (r - g) / chroma + 4; break;\n\t\t\t}\n\n\t\t\th *= 60;\n\t\t\th = Math.round(h);\n\t\t}\n\t\treturn new HSLA(h, s, l, a);\n\t}\n\n\tprivate static _hue2rgb(p: number, q: number, t: number): number {\n\t\tif (t < 0) {\n\t\t\tt += 1;\n\t\t}\n\t\tif (t > 1) {\n\t\t\tt -= 1;\n\t\t}\n\t\tif (t < 1 / 6) {\n\t\t\treturn p + (q - p) * 6 * t;\n\t\t}\n\t\tif (t < 1 / 2) {\n\t\t\treturn q;\n\t\t}\n\t\tif (t < 2 / 3) {\n\t\t\treturn p + (q - p) * (2 / 3 - t) * 6;\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Converts an HSL color value to RGB. Conversion formula\n\t * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\t * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n\t * returns r, g, and b in the set [0, 255].\n\t */\n\tstatic toRGBA(hsla: HSLA): RGBA {\n\t\tconst h = hsla.h / 360;\n\t\tconst { s, l, a } = hsla;\n\t\tlet r: number, g: number, b: number;\n\n\t\tif (s === 0) {\n\t\t\tr = g = b = l; // achromatic\n\t\t} else {\n\t\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\tconst p = 2 * l - q;\n\t\t\tr = HSLA._hue2rgb(p, q, h + 1 / 3);\n\t\t\tg = HSLA._hue2rgb(p, q, h);\n\t\t\tb = HSLA._hue2rgb(p, q, h - 1 / 3);\n\t\t}\n\n\t\treturn new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\n\t}\n}\n\nexport class HSVA {\n\n\t_hsvaBrand: void = undefined;\n\n\t/**\n\t * Hue: integer in [0, 360]\n\t */\n\treadonly h: number;\n\n\t/**\n\t * Saturation: float in [0, 1]\n\t */\n\treadonly s: number;\n\n\t/**\n\t * Value: float in [0, 1]\n\t */\n\treadonly v: number;\n\n\t/**\n\t * Alpha: float in [0, 1]\n\t */\n\treadonly a: number;\n\n\tconstructor(h: number, s: number, v: number, a: number) {\n\t\tthis.h = Math.max(Math.min(360, h), 0) | 0;\n\t\tthis.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n\t\tthis.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n\t\tthis.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n\t}\n\n\tstatic equals(a: HSVA, b: HSVA): boolean {\n\t\treturn a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\n\t}\n\n\t// from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n\tstatic fromRGBA(rgba: RGBA): HSVA {\n\t\tconst r = rgba.r / 255;\n\t\tconst g = rgba.g / 255;\n\t\tconst b = rgba.b / 255;\n\t\tconst cmax = Math.max(r, g, b);\n\t\tconst cmin = Math.min(r, g, b);\n\t\tconst delta = cmax - cmin;\n\t\tconst s = cmax === 0 ? 0 : (delta / cmax);\n\t\tlet m: number;\n\n\t\tif (delta === 0) {\n\t\t\tm = 0;\n\t\t} else if (cmax === r) {\n\t\t\tm = ((((g - b) / delta) % 6) + 6) % 6;\n\t\t} else if (cmax === g) {\n\t\t\tm = ((b - r) / delta) + 2;\n\t\t} else {\n\t\t\tm = ((r - g) / delta) + 4;\n\t\t}\n\n\t\treturn new HSVA(Math.round(m * 60), s, cmax, rgba.a);\n\t}\n\n\t// from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n\tstatic toRGBA(hsva: HSVA): RGBA {\n\t\tconst { h, s, v, a } = hsva;\n\t\tconst c = v * s;\n\t\tconst x = c * (1 - Math.abs((h / 60) % 2 - 1));\n\t\tconst m = v - c;\n\t\tlet [r, g, b] = [0, 0, 0];\n\n\t\tif (h < 60) {\n\t\t\tr = c;\n\t\t\tg = x;\n\t\t} else if (h < 120) {\n\t\t\tr = x;\n\t\t\tg = c;\n\t\t} else if (h < 180) {\n\t\t\tg = c;\n\t\t\tb = x;\n\t\t} else if (h < 240) {\n\t\t\tg = x;\n\t\t\tb = c;\n\t\t} else if (h < 300) {\n\t\t\tr = x;\n\t\t\tb = c;\n\t\t} else if (h <= 360) {\n\t\t\tr = c;\n\t\t\tb = x;\n\t\t}\n\n\t\tr = Math.round((r + m) * 255);\n\t\tg = Math.round((g + m) * 255);\n\t\tb = Math.round((b + m) * 255);\n\n\t\treturn new RGBA(r, g, b, a);\n\t}\n}\n\nexport class Color {\n\n\tstatic fromHex(hex: string): Color {\n\t\treturn Color.Format.CSS.parseHex(hex) || Color.red;\n\t}\n\n\tstatic equals(a: Color | null, b: Color | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.equals(b);\n\t}\n\n\treadonly rgba: RGBA;\n\tprivate _hsla?: HSLA;\n\tget hsla(): HSLA {\n\t\tif (this._hsla) {\n\t\t\treturn this._hsla;\n\t\t} else {\n\t\t\treturn HSLA.fromRGBA(this.rgba);\n\t\t}\n\t}\n\n\tprivate _hsva?: HSVA;\n\tget hsva(): HSVA {\n\t\tif (this._hsva) {\n\t\t\treturn this._hsva;\n\t\t}\n\t\treturn HSVA.fromRGBA(this.rgba);\n\t}\n\n\tconstructor(arg: RGBA | HSLA | HSVA) {\n\t\tif (!arg) {\n\t\t\tthrow new Error('Color needs a value');\n\t\t} else if (arg instanceof RGBA) {\n\t\t\tthis.rgba = arg;\n\t\t} else if (arg instanceof HSLA) {\n\t\t\tthis._hsla = arg;\n\t\t\tthis.rgba = HSLA.toRGBA(arg);\n\t\t} else if (arg instanceof HSVA) {\n\t\t\tthis._hsva = arg;\n\t\t\tthis.rgba = HSVA.toRGBA(arg);\n\t\t} else {\n\t\t\tthrow new Error('Invalid color ctor argument');\n\t\t}\n\t}\n\n\tequals(other: Color | null): boolean {\n\t\treturn !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\n\t}\n\n\t/**\n\t * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.\n\t */\n\tgetRelativeLuminance(): number {\n\t\tconst R = Color._relativeLuminanceForComponent(this.rgba.r);\n\t\tconst G = Color._relativeLuminanceForComponent(this.rgba.g);\n\t\tconst B = Color._relativeLuminanceForComponent(this.rgba.b);\n\t\tconst luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n\n\t\treturn roundFloat(luminance, 4);\n\t}\n\n\t/**\n\t * Reduces the \"foreground\" color on this \"background\" color unti it is\n\t * below the relative luminace ratio.\n\t * @returns the new foreground color\n\t * @see https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L315\n\t */\n\treduceRelativeLuminace(foreground: Color, ratio: number): Color {\n\t\t// This is a naive but fast approach to reducing luminance as converting to\n\t\t// HSL and back is expensive\n\t\tlet { r: fgR, g: fgG, b: fgB } = foreground.rgba;\n\n\t\tlet cr = this.getContrastRatio(foreground);\n\t\twhile (cr < ratio && (fgR > 0 || fgG > 0 || fgB > 0)) {\n\t\t\t// Reduce by 10% until the ratio is hit\n\t\t\tfgR -= Math.max(0, Math.ceil(fgR * 0.1));\n\t\t\tfgG -= Math.max(0, Math.ceil(fgG * 0.1));\n\t\t\tfgB -= Math.max(0, Math.ceil(fgB * 0.1));\n\t\t\tcr = this.getContrastRatio(new Color(new RGBA(fgR, fgG, fgB)));\n\t\t}\n\n\t\treturn new Color(new RGBA(fgR, fgG, fgB));\n\t}\n\n\t/**\n\t * Increases the \"foreground\" color on this \"background\" color unti it is\n\t * below the relative luminace ratio.\n\t * @returns the new foreground color\n\t * @see https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L335\n\t */\n\tincreaseRelativeLuminace(foreground: Color, ratio: number): Color {\n\t\t// This is a naive but fast approach to reducing luminance as converting to\n\t\t// HSL and back is expensive\n\t\tlet { r: fgR, g: fgG, b: fgB } = foreground.rgba;\n\t\tlet cr = this.getContrastRatio(foreground);\n\t\twhile (cr < ratio && (fgR < 0xFF || fgG < 0xFF || fgB < 0xFF)) {\n\t\t\tfgR = Math.min(0xFF, fgR + Math.ceil((255 - fgR) * 0.1));\n\t\t\tfgG = Math.min(0xFF, fgG + Math.ceil((255 - fgG) * 0.1));\n\t\t\tfgB = Math.min(0xFF, fgB + Math.ceil((255 - fgB) * 0.1));\n\t\t\tcr = this.getContrastRatio(new Color(new RGBA(fgR, fgG, fgB)));\n\t\t}\n\n\t\treturn new Color(new RGBA(fgR, fgG, fgB));\n\t}\n\n\tprivate static _relativeLuminanceForComponent(color: number): number {\n\t\tconst c = color / 255;\n\t\treturn (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\n\t}\n\n\t/**\n\t * http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t * Returns the contrast ration number in the set [1, 21].\n\t */\n\tgetContrastRatio(another: Color): number {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n\t}\n\n\t/**\n\t *\thttp://24ways.org/2010/calculating-color-contrast\n\t *  Return 'true' if darker color otherwise 'false'\n\t */\n\tisDarker(): boolean {\n\t\tconst yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n\t\treturn yiq < 128;\n\t}\n\n\t/**\n\t *\thttp://24ways.org/2010/calculating-color-contrast\n\t *  Return 'true' if lighter color otherwise 'false'\n\t */\n\tisLighter(): boolean {\n\t\tconst yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n\t\treturn yiq >= 128;\n\t}\n\n\tisLighterThan(another: Color): boolean {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 > lum2;\n\t}\n\n\tisDarkerThan(another: Color): boolean {\n\t\tconst lum1 = this.getRelativeLuminance();\n\t\tconst lum2 = another.getRelativeLuminance();\n\t\treturn lum1 < lum2;\n\t}\n\n\t/**\n\t * Based on xterm.js: https://github.com/xtermjs/xterm.js/blob/44f9fa39ae03e2ca6d28354d88a399608686770e/src/common/Color.ts#L288\n\t *\n\t * Given a foreground color and a background color, either increase or reduce the luminance of the\n\t * foreground color until the specified contrast ratio is met. If pure white or black is hit\n\t * without the contrast ratio being met, go the other direction using the background color as the\n\t * foreground color and take either the first or second result depending on which has the higher\n\t * contrast ratio.\n\t *\n\t * @param foreground The foreground color.\n\t * @param ratio The contrast ratio to achieve.\n\t * @returns The adjusted foreground color.\n\t */\n\tensureConstrast(foreground: Color, ratio: number): Color {\n\t\tconst bgL = this.getRelativeLuminance();\n\t\tconst fgL = foreground.getRelativeLuminance();\n\t\tconst cr = this.getContrastRatio(foreground);\n\t\tif (cr < ratio) {\n\t\t\tif (fgL < bgL) {\n\t\t\t\tconst resultA = this.reduceRelativeLuminace(foreground, ratio);\n\t\t\t\tconst resultARatio = this.getContrastRatio(resultA);\n\t\t\t\tif (resultARatio < ratio) {\n\t\t\t\t\tconst resultB = this.increaseRelativeLuminace(foreground, ratio);\n\t\t\t\t\tconst resultBRatio = this.getContrastRatio(resultB);\n\t\t\t\t\treturn resultARatio > resultBRatio ? resultA : resultB;\n\t\t\t\t}\n\t\t\t\treturn resultA;\n\t\t\t}\n\t\t\tconst resultA = this.increaseRelativeLuminace(foreground, ratio);\n\t\t\tconst resultARatio = this.getContrastRatio(resultA);\n\t\t\tif (resultARatio < ratio) {\n\t\t\t\tconst resultB = this.reduceRelativeLuminace(foreground, ratio);\n\t\t\t\tconst resultBRatio = this.getContrastRatio(resultB);\n\t\t\t\treturn resultARatio > resultBRatio ? resultA : resultB;\n\t\t\t}\n\t\t\treturn resultA;\n\t\t}\n\n\t\treturn foreground;\n\t}\n\n\tlighten(factor: number): Color {\n\t\treturn new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n\t}\n\n\tdarken(factor: number): Color {\n\t\treturn new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n\t}\n\n\ttransparent(factor: number): Color {\n\t\tconst { r, g, b, a } = this.rgba;\n\t\treturn new Color(new RGBA(r, g, b, a * factor));\n\t}\n\n\tisTransparent(): boolean {\n\t\treturn this.rgba.a === 0;\n\t}\n\n\tisOpaque(): boolean {\n\t\treturn this.rgba.a === 1;\n\t}\n\n\topposite(): Color {\n\t\treturn new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n\t}\n\n\tblend(c: Color): Color {\n\t\tconst rgba = c.rgba;\n\n\t\t// Convert to 0..1 opacity\n\t\tconst thisA = this.rgba.a;\n\t\tconst colorA = rgba.a;\n\n\t\tconst a = thisA + colorA * (1 - thisA);\n\t\tif (a < 1e-6) {\n\t\t\treturn Color.transparent;\n\t\t}\n\n\t\tconst r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;\n\t\tconst g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;\n\t\tconst b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;\n\n\t\treturn new Color(new RGBA(r, g, b, a));\n\t}\n\n\t/**\n\t * Mixes the current color with the provided color based on the given factor.\n\t * @param color The color to mix with\n\t * @param factor The factor of mixing (0 means this color, 1 means the input color, 0.5 means equal mix)\n\t * @returns A new color representing the mix\n\t */\n\tmix(color: Color, factor: number = 0.5): Color {\n\t\tconst normalize = Math.min(Math.max(factor, 0), 1);\n\t\tconst thisRGBA = this.rgba;\n\t\tconst otherRGBA = color.rgba;\n\n\t\tconst r = thisRGBA.r + (otherRGBA.r - thisRGBA.r) * normalize;\n\t\tconst g = thisRGBA.g + (otherRGBA.g - thisRGBA.g) * normalize;\n\t\tconst b = thisRGBA.b + (otherRGBA.b - thisRGBA.b) * normalize;\n\t\tconst a = thisRGBA.a + (otherRGBA.a - thisRGBA.a) * normalize;\n\n\t\treturn new Color(new RGBA(r, g, b, a));\n\t}\n\n\tmakeOpaque(opaqueBackground: Color): Color {\n\t\tif (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n\t\t\t// only allow to blend onto a non-opaque color onto a opaque color\n\t\t\treturn this;\n\t\t}\n\n\t\tconst { r, g, b, a } = this.rgba;\n\n\t\t// https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity\n\t\treturn new Color(new RGBA(\n\t\t\topaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r),\n\t\t\topaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g),\n\t\t\topaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b),\n\t\t\t1\n\t\t));\n\t}\n\n\tflatten(...backgrounds: Color[]): Color {\n\t\tconst background = backgrounds.reduceRight((accumulator, color) => {\n\t\t\treturn Color._flatten(color, accumulator);\n\t\t});\n\t\treturn Color._flatten(this, background);\n\t}\n\n\tprivate static _flatten(foreground: Color, background: Color) {\n\t\tconst backgroundAlpha = 1 - foreground.rgba.a;\n\t\treturn new Color(new RGBA(\n\t\t\tbackgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r,\n\t\t\tbackgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g,\n\t\t\tbackgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b\n\t\t));\n\t}\n\n\tprivate _toString?: string;\n\ttoString(): string {\n\t\tif (!this._toString) {\n\t\t\tthis._toString = Color.Format.CSS.format(this);\n\t\t}\n\t\treturn this._toString;\n\t}\n\n\tprivate _toNumber32Bit?: number;\n\ttoNumber32Bit(): number {\n\t\tif (!this._toNumber32Bit) {\n\t\t\tthis._toNumber32Bit = (\n\t\t\t\tthis.rgba.r /*  */ << 24 |\n\t\t\t\tthis.rgba.g /*  */ << 16 |\n\t\t\t\tthis.rgba.b /*  */ << 8 |\n\t\t\t\tthis.rgba.a * 0xFF << 0\n\t\t\t) >>> 0;\n\t\t}\n\t\treturn this._toNumber32Bit;\n\t}\n\n\tstatic getLighterColor(of: Color, relative: Color, factor?: number): Color {\n\t\tif (of.isLighterThan(relative)) {\n\t\t\treturn of;\n\t\t}\n\t\tfactor = factor ? factor : 0.5;\n\t\tconst lum1 = of.getRelativeLuminance();\n\t\tconst lum2 = relative.getRelativeLuminance();\n\t\tfactor = factor * (lum2 - lum1) / lum2;\n\t\treturn of.lighten(factor);\n\t}\n\n\tstatic getDarkerColor(of: Color, relative: Color, factor?: number): Color {\n\t\tif (of.isDarkerThan(relative)) {\n\t\t\treturn of;\n\t\t}\n\t\tfactor = factor ? factor : 0.5;\n\t\tconst lum1 = of.getRelativeLuminance();\n\t\tconst lum2 = relative.getRelativeLuminance();\n\t\tfactor = factor * (lum1 - lum2) / lum1;\n\t\treturn of.darken(factor);\n\t}\n\n\tstatic readonly white = new Color(new RGBA(255, 255, 255, 1));\n\tstatic readonly black = new Color(new RGBA(0, 0, 0, 1));\n\tstatic readonly red = new Color(new RGBA(255, 0, 0, 1));\n\tstatic readonly blue = new Color(new RGBA(0, 0, 255, 1));\n\tstatic readonly green = new Color(new RGBA(0, 255, 0, 1));\n\tstatic readonly cyan = new Color(new RGBA(0, 255, 255, 1));\n\tstatic readonly lightgrey = new Color(new RGBA(211, 211, 211, 1));\n\tstatic readonly transparent = new Color(new RGBA(0, 0, 0, 0));\n}\n\nexport namespace Color {\n\texport namespace Format {\n\t\texport namespace CSS {\n\n\t\t\texport function formatRGB(color: Color): string {\n\t\t\t\tif (color.rgba.a === 1) {\n\t\t\t\t\treturn `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatRGBA(color);\n\t\t\t}\n\n\t\t\texport function formatRGBA(color: Color): string {\n\t\t\t\treturn `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\n\t\t\t}\n\n\t\t\texport function formatHSL(color: Color): string {\n\t\t\t\tif (color.hsla.a === 1) {\n\t\t\t\t\treturn `hsl(${color.hsla.h}, ${Math.round(color.hsla.s * 100)}%, ${Math.round(color.hsla.l * 100)}%)`;\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatHSLA(color);\n\t\t\t}\n\n\t\t\texport function formatHSLA(color: Color): string {\n\t\t\t\treturn `hsla(${color.hsla.h}, ${Math.round(color.hsla.s * 100)}%, ${Math.round(color.hsla.l * 100)}%, ${color.hsla.a.toFixed(2)})`;\n\t\t\t}\n\n\t\t\tfunction _toTwoDigitHex(n: number): string {\n\t\t\t\tconst r = n.toString(16);\n\t\t\t\treturn r.length !== 2 ? '0' + r : r;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Formats the color as #RRGGBB\n\t\t\t */\n\t\t\texport function formatHex(color: Color): string {\n\t\t\t\treturn `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Formats the color as #RRGGBBAA\n\t\t\t * If 'compact' is set, colors without transparancy will be printed as #RRGGBB\n\t\t\t */\n\t\t\texport function formatHexA(color: Color, compact = false): string {\n\t\t\t\tif (compact && color.rgba.a === 1) {\n\t\t\t\t\treturn Color.Format.CSS.formatHex(color);\n\t\t\t\t}\n\n\t\t\t\treturn `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The default format will use HEX if opaque and RGBA otherwise.\n\t\t\t */\n\t\t\texport function format(color: Color): string {\n\t\t\t\tif (color.isOpaque()) {\n\t\t\t\t\treturn Color.Format.CSS.formatHex(color);\n\t\t\t\t}\n\n\t\t\t\treturn Color.Format.CSS.formatRGBA(color);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Parse a CSS color and return a {@link Color}.\n\t\t\t * @param css The CSS color to parse.\n\t\t\t * @see https://drafts.csswg.org/css-color/#typedef-color\n\t\t\t */\n\t\t\texport function parse(css: string): Color | null {\n\t\t\t\tif (css === 'transparent') {\n\t\t\t\t\treturn Color.transparent;\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('#')) {\n\t\t\t\t\treturn parseHex(css);\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('rgba(')) {\n\t\t\t\t\tconst color = css.match(/rgba\\((?<r>(?:\\+|-)?\\d+), *(?<g>(?:\\+|-)?\\d+), *(?<b>(?:\\+|-)?\\d+), *(?<a>(?:\\+|-)?\\d+(\\.\\d+)?)\\)/);\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tthrow new Error('Invalid color format ' + css);\n\t\t\t\t\t}\n\t\t\t\t\tconst r = parseInt(color.groups?.r ?? '0');\n\t\t\t\t\tconst g = parseInt(color.groups?.g ?? '0');\n\t\t\t\t\tconst b = parseInt(color.groups?.b ?? '0');\n\t\t\t\t\tconst a = parseFloat(color.groups?.a ?? '0');\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, a));\n\t\t\t\t}\n\t\t\t\tif (css.startsWith('rgb(')) {\n\t\t\t\t\tconst color = css.match(/rgb\\((?<r>(?:\\+|-)?\\d+), *(?<g>(?:\\+|-)?\\d+), *(?<b>(?:\\+|-)?\\d+)\\)/);\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tthrow new Error('Invalid color format ' + css);\n\t\t\t\t\t}\n\t\t\t\t\tconst r = parseInt(color.groups?.r ?? '0');\n\t\t\t\t\tconst g = parseInt(color.groups?.g ?? '0');\n\t\t\t\t\tconst b = parseInt(color.groups?.b ?? '0');\n\t\t\t\t\treturn new Color(new RGBA(r, g, b));\n\t\t\t\t}\n\t\t\t\t// TODO: Support more formats as needed\n\t\t\t\treturn parseNamedKeyword(css);\n\t\t\t}\n\n\t\t\tfunction parseNamedKeyword(css: string): Color | null {\n\t\t\t\t// https://drafts.csswg.org/css-color/#named-colors\n\t\t\t\tswitch (css) {\n\t\t\t\t\tcase 'aliceblue': return new Color(new RGBA(240, 248, 255, 1));\n\t\t\t\t\tcase 'antiquewhite': return new Color(new RGBA(250, 235, 215, 1));\n\t\t\t\t\tcase 'aqua': return new Color(new RGBA(0, 255, 255, 1));\n\t\t\t\t\tcase 'aquamarine': return new Color(new RGBA(127, 255, 212, 1));\n\t\t\t\t\tcase 'azure': return new Color(new RGBA(240, 255, 255, 1));\n\t\t\t\t\tcase 'beige': return new Color(new RGBA(245, 245, 220, 1));\n\t\t\t\t\tcase 'bisque': return new Color(new RGBA(255, 228, 196, 1));\n\t\t\t\t\tcase 'black': return new Color(new RGBA(0, 0, 0, 1));\n\t\t\t\t\tcase 'blanchedalmond': return new Color(new RGBA(255, 235, 205, 1));\n\t\t\t\t\tcase 'blue': return new Color(new RGBA(0, 0, 255, 1));\n\t\t\t\t\tcase 'blueviolet': return new Color(new RGBA(138, 43, 226, 1));\n\t\t\t\t\tcase 'brown': return new Color(new RGBA(165, 42, 42, 1));\n\t\t\t\t\tcase 'burlywood': return new Color(new RGBA(222, 184, 135, 1));\n\t\t\t\t\tcase 'cadetblue': return new Color(new RGBA(95, 158, 160, 1));\n\t\t\t\t\tcase 'chartreuse': return new Color(new RGBA(127, 255, 0, 1));\n\t\t\t\t\tcase 'chocolate': return new Color(new RGBA(210, 105, 30, 1));\n\t\t\t\t\tcase 'coral': return new Color(new RGBA(255, 127, 80, 1));\n\t\t\t\t\tcase 'cornflowerblue': return new Color(new RGBA(100, 149, 237, 1));\n\t\t\t\t\tcase 'cornsilk': return new Color(new RGBA(255, 248, 220, 1));\n\t\t\t\t\tcase 'crimson': return new Color(new RGBA(220, 20, 60, 1));\n\t\t\t\t\tcase 'cyan': return new Color(new RGBA(0, 255, 255, 1));\n\t\t\t\t\tcase 'darkblue': return new Color(new RGBA(0, 0, 139, 1));\n\t\t\t\t\tcase 'darkcyan': return new Color(new RGBA(0, 139, 139, 1));\n\t\t\t\t\tcase 'darkgoldenrod': return new Color(new RGBA(184, 134, 11, 1));\n\t\t\t\t\tcase 'darkgray': return new Color(new RGBA(169, 169, 169, 1));\n\t\t\t\t\tcase 'darkgreen': return new Color(new RGBA(0, 100, 0, 1));\n\t\t\t\t\tcase 'darkgrey': return new Color(new RGBA(169, 169, 169, 1));\n\t\t\t\t\tcase 'darkkhaki': return new Color(new RGBA(189, 183, 107, 1));\n\t\t\t\t\tcase 'darkmagenta': return new Color(new RGBA(139, 0, 139, 1));\n\t\t\t\t\tcase 'darkolivegreen': return new Color(new RGBA(85, 107, 47, 1));\n\t\t\t\t\tcase 'darkorange': return new Color(new RGBA(255, 140, 0, 1));\n\t\t\t\t\tcase 'darkorchid': return new Color(new RGBA(153, 50, 204, 1));\n\t\t\t\t\tcase 'darkred': return new Color(new RGBA(139, 0, 0, 1));\n\t\t\t\t\tcase 'darksalmon': return new Color(new RGBA(233, 150, 122, 1));\n\t\t\t\t\tcase 'darkseagreen': return new Color(new RGBA(143, 188, 143, 1));\n\t\t\t\t\tcase 'darkslateblue': return new Color(new RGBA(72, 61, 139, 1));\n\t\t\t\t\tcase 'darkslategray': return new Color(new RGBA(47, 79, 79, 1));\n\t\t\t\t\tcase 'darkslategrey': return new Color(new RGBA(47, 79, 79, 1));\n\t\t\t\t\tcase 'darkturquoise': return new Color(new RGBA(0, 206, 209, 1));\n\t\t\t\t\tcase 'darkviolet': return new Color(new RGBA(148, 0, 211, 1));\n\t\t\t\t\tcase 'deeppink': return new Color(new RGBA(255, 20, 147, 1));\n\t\t\t\t\tcase 'deepskyblue': return new Color(new RGBA(0, 191, 255, 1));\n\t\t\t\t\tcase 'dimgray': return new Color(new RGBA(105, 105, 105, 1));\n\t\t\t\t\tcase 'dimgrey': return new Color(new RGBA(105, 105, 105, 1));\n\t\t\t\t\tcase 'dodgerblue': return new Color(new RGBA(30, 144, 255, 1));\n\t\t\t\t\tcase 'firebrick': return new Color(new RGBA(178, 34, 34, 1));\n\t\t\t\t\tcase 'floralwhite': return new Color(new RGBA(255, 250, 240, 1));\n\t\t\t\t\tcase 'forestgreen': return new Color(new RGBA(34, 139, 34, 1));\n\t\t\t\t\tcase 'fuchsia': return new Color(new RGBA(255, 0, 255, 1));\n\t\t\t\t\tcase 'gainsboro': return new Color(new RGBA(220, 220, 220, 1));\n\t\t\t\t\tcase 'ghostwhite': return new Color(new RGBA(248, 248, 255, 1));\n\t\t\t\t\tcase 'gold': return new Color(new RGBA(255, 215, 0, 1));\n\t\t\t\t\tcase 'goldenrod': return new Color(new RGBA(218, 165, 32, 1));\n\t\t\t\t\tcase 'gray': return new Color(new RGBA(128, 128, 128, 1));\n\t\t\t\t\tcase 'green': return new Color(new RGBA(0, 128, 0, 1));\n\t\t\t\t\tcase 'greenyellow': return new Color(new RGBA(173, 255, 47, 1));\n\t\t\t\t\tcase 'grey': return new Color(new RGBA(128, 128, 128, 1));\n\t\t\t\t\tcase 'honeydew': return new Color(new RGBA(240, 255, 240, 1));\n\t\t\t\t\tcase 'hotpink': return new Color(new RGBA(255, 105, 180, 1));\n\t\t\t\t\tcase 'indianred': return new Color(new RGBA(205, 92, 92, 1));\n\t\t\t\t\tcase 'indigo': return new Color(new RGBA(75, 0, 130, 1));\n\t\t\t\t\tcase 'ivory': return new Color(new RGBA(255, 255, 240, 1));\n\t\t\t\t\tcase 'khaki': return new Color(new RGBA(240, 230, 140, 1));\n\t\t\t\t\tcase 'lavender': return new Color(new RGBA(230, 230, 250, 1));\n\t\t\t\t\tcase 'lavenderblush': return new Color(new RGBA(255, 240, 245, 1));\n\t\t\t\t\tcase 'lawngreen': return new Color(new RGBA(124, 252, 0, 1));\n\t\t\t\t\tcase 'lemonchiffon': return new Color(new RGBA(255, 250, 205, 1));\n\t\t\t\t\tcase 'lightblue': return new Color(new RGBA(173, 216, 230, 1));\n\t\t\t\t\tcase 'lightcoral': return new Color(new RGBA(240, 128, 128, 1));\n\t\t\t\t\tcase 'lightcyan': return new Color(new RGBA(224, 255, 255, 1));\n\t\t\t\t\tcase 'lightgoldenrodyellow': return new Color(new RGBA(250, 250, 210, 1));\n\t\t\t\t\tcase 'lightgray': return new Color(new RGBA(211, 211, 211, 1));\n\t\t\t\t\tcase 'lightgreen': return new Color(new RGBA(144, 238, 144, 1));\n\t\t\t\t\tcase 'lightgrey': return new Color(new RGBA(211, 211, 211, 1));\n\t\t\t\t\tcase 'lightpink': return new Color(new RGBA(255, 182, 193, 1));\n\t\t\t\t\tcase 'lightsalmon': return new Color(new RGBA(255, 160, 122, 1));\n\t\t\t\t\tcase 'lightseagreen': return new Color(new RGBA(32, 178, 170, 1));\n\t\t\t\t\tcase 'lightskyblue': return new Color(new RGBA(135, 206, 250, 1));\n\t\t\t\t\tcase 'lightslategray': return new Color(new RGBA(119, 136, 153, 1));\n\t\t\t\t\tcase 'lightslategrey': return new Color(new RGBA(119, 136, 153, 1));\n\t\t\t\t\tcase 'lightsteelblue': return new Color(new RGBA(176, 196, 222, 1));\n\t\t\t\t\tcase 'lightyellow': return new Color(new RGBA(255, 255, 224, 1));\n\t\t\t\t\tcase 'lime': return new Color(new RGBA(0, 255, 0, 1));\n\t\t\t\t\tcase 'limegreen': return new Color(new RGBA(50, 205, 50, 1));\n\t\t\t\t\tcase 'linen': return new Color(new RGBA(250, 240, 230, 1));\n\t\t\t\t\tcase 'magenta': return new Color(new RGBA(255, 0, 255, 1));\n\t\t\t\t\tcase 'maroon': return new Color(new RGBA(128, 0, 0, 1));\n\t\t\t\t\tcase 'mediumaquamarine': return new Color(new RGBA(102, 205, 170, 1));\n\t\t\t\t\tcase 'mediumblue': return new Color(new RGBA(0, 0, 205, 1));\n\t\t\t\t\tcase 'mediumorchid': return new Color(new RGBA(186, 85, 211, 1));\n\t\t\t\t\tcase 'mediumpurple': return new Color(new RGBA(147, 112, 219, 1));\n\t\t\t\t\tcase 'mediumseagreen': return new Color(new RGBA(60, 179, 113, 1));\n\t\t\t\t\tcase 'mediumslateblue': return new Color(new RGBA(123, 104, 238, 1));\n\t\t\t\t\tcase 'mediumspringgreen': return new Color(new RGBA(0, 250, 154, 1));\n\t\t\t\t\tcase 'mediumturquoise': return new Color(new RGBA(72, 209, 204, 1));\n\t\t\t\t\tcase 'mediumvioletred': return new Color(new RGBA(199, 21, 133, 1));\n\t\t\t\t\tcase 'midnightblue': return new Color(new RGBA(25, 25, 112, 1));\n\t\t\t\t\tcase 'mintcream': return new Color(new RGBA(245, 255, 250, 1));\n\t\t\t\t\tcase 'mistyrose': return new Color(new RGBA(255, 228, 225, 1));\n\t\t\t\t\tcase 'moccasin': return new Color(new RGBA(255, 228, 181, 1));\n\t\t\t\t\tcase 'navajowhite': return new Color(new RGBA(255, 222, 173, 1));\n\t\t\t\t\tcase 'navy': return new Color(new RGBA(0, 0, 128, 1));\n\t\t\t\t\tcase 'oldlace': return new Color(new RGBA(253, 245, 230, 1));\n\t\t\t\t\tcase 'olive': return new Color(new RGBA(128, 128, 0, 1));\n\t\t\t\t\tcase 'olivedrab': return new Color(new RGBA(107, 142, 35, 1));\n\t\t\t\t\tcase 'orange': return new Color(new RGBA(255, 165, 0, 1));\n\t\t\t\t\tcase 'orangered': return new Color(new RGBA(255, 69, 0, 1));\n\t\t\t\t\tcase 'orchid': return new Color(new RGBA(218, 112, 214, 1));\n\t\t\t\t\tcase 'palegoldenrod': return new Color(new RGBA(238, 232, 170, 1));\n\t\t\t\t\tcase 'palegreen': return new Color(new RGBA(152, 251, 152, 1));\n\t\t\t\t\tcase 'paleturquoise': return new Color(new RGBA(175, 238, 238, 1));\n\t\t\t\t\tcase 'palevioletred': return new Color(new RGBA(219, 112, 147, 1));\n\t\t\t\t\tcase 'papayawhip': return new Color(new RGBA(255, 239, 213, 1));\n\t\t\t\t\tcase 'peachpuff': return new Color(new RGBA(255, 218, 185, 1));\n\t\t\t\t\tcase 'peru': return new Color(new RGBA(205, 133, 63, 1));\n\t\t\t\t\tcase 'pink': return new Color(new RGBA(255, 192, 203, 1));\n\t\t\t\t\tcase 'plum': return new Color(new RGBA(221, 160, 221, 1));\n\t\t\t\t\tcase 'powderblue': return new Color(new RGBA(176, 224, 230, 1));\n\t\t\t\t\tcase 'purple': return new Color(new RGBA(128, 0, 128, 1));\n\t\t\t\t\tcase 'rebeccapurple': return new Color(new RGBA(102, 51, 153, 1));\n\t\t\t\t\tcase 'red': return new Color(new RGBA(255, 0, 0, 1));\n\t\t\t\t\tcase 'rosybrown': return new Color(new RGBA(188, 143, 143, 1));\n\t\t\t\t\tcase 'royalblue': return new Color(new RGBA(65, 105, 225, 1));\n\t\t\t\t\tcase 'saddlebrown': return new Color(new RGBA(139, 69, 19, 1));\n\t\t\t\t\tcase 'salmon': return new Color(new RGBA(250, 128, 114, 1));\n\t\t\t\t\tcase 'sandybrown': return new Color(new RGBA(244, 164, 96, 1));\n\t\t\t\t\tcase 'seagreen': return new Color(new RGBA(46, 139, 87, 1));\n\t\t\t\t\tcase 'seashell': return new Color(new RGBA(255, 245, 238, 1));\n\t\t\t\t\tcase 'sienna': return new Color(new RGBA(160, 82, 45, 1));\n\t\t\t\t\tcase 'silver': return new Color(new RGBA(192, 192, 192, 1));\n\t\t\t\t\tcase 'skyblue': return new Color(new RGBA(135, 206, 235, 1));\n\t\t\t\t\tcase 'slateblue': return new Color(new RGBA(106, 90, 205, 1));\n\t\t\t\t\tcase 'slategray': return new Color(new RGBA(112, 128, 144, 1));\n\t\t\t\t\tcase 'slategrey': return new Color(new RGBA(112, 128, 144, 1));\n\t\t\t\t\tcase 'snow': return new Color(new RGBA(255, 250, 250, 1));\n\t\t\t\t\tcase 'springgreen': return new Color(new RGBA(0, 255, 127, 1));\n\t\t\t\t\tcase 'steelblue': return new Color(new RGBA(70, 130, 180, 1));\n\t\t\t\t\tcase 'tan': return new Color(new RGBA(210, 180, 140, 1));\n\t\t\t\t\tcase 'teal': return new Color(new RGBA(0, 128, 128, 1));\n\t\t\t\t\tcase 'thistle': return new Color(new RGBA(216, 191, 216, 1));\n\t\t\t\t\tcase 'tomato': return new Color(new RGBA(255, 99, 71, 1));\n\t\t\t\t\tcase 'turquoise': return new Color(new RGBA(64, 224, 208, 1));\n\t\t\t\t\tcase 'violet': return new Color(new RGBA(238, 130, 238, 1));\n\t\t\t\t\tcase 'wheat': return new Color(new RGBA(245, 222, 179, 1));\n\t\t\t\t\tcase 'white': return new Color(new RGBA(255, 255, 255, 1));\n\t\t\t\t\tcase 'whitesmoke': return new Color(new RGBA(245, 245, 245, 1));\n\t\t\t\t\tcase 'yellow': return new Color(new RGBA(255, 255, 0, 1));\n\t\t\t\t\tcase 'yellowgreen': return new Color(new RGBA(154, 205, 50, 1));\n\t\t\t\t\tdefault: return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Converts an Hex color value to a Color.\n\t\t\t * returns r, g, and b are contained in the set [0, 255]\n\t\t\t * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).\n\t\t\t */\n\t\t\texport function parseHex(hex: string): Color | null {\n\t\t\t\tconst length = hex.length;\n\n\t\t\t\tif (length === 0) {\n\t\t\t\t\t// Invalid color\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (hex.charCodeAt(0) !== CharCode.Hash) {\n\t\t\t\t\t// Does not begin with a #\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (length === 7) {\n\t\t\t\t\t// #RRGGBB format\n\t\t\t\t\tconst r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\tconst b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, 1));\n\t\t\t\t}\n\n\t\t\t\tif (length === 9) {\n\t\t\t\t\t// #RRGGBBAA format\n\t\t\t\t\tconst r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\tconst b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n\t\t\t\t\tconst a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n\t\t\t\t\treturn new Color(new RGBA(r, g, b, a / 255));\n\t\t\t\t}\n\n\t\t\t\tif (length === 4) {\n\t\t\t\t\t// #RGB format\n\t\t\t\t\tconst r = _parseHexDigit(hex.charCodeAt(1));\n\t\t\t\t\tconst g = _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst b = _parseHexDigit(hex.charCodeAt(3));\n\t\t\t\t\treturn new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n\t\t\t\t}\n\n\t\t\t\tif (length === 5) {\n\t\t\t\t\t// #RGBA format\n\t\t\t\t\tconst r = _parseHexDigit(hex.charCodeAt(1));\n\t\t\t\t\tconst g = _parseHexDigit(hex.charCodeAt(2));\n\t\t\t\t\tconst b = _parseHexDigit(hex.charCodeAt(3));\n\t\t\t\t\tconst a = _parseHexDigit(hex.charCodeAt(4));\n\t\t\t\t\treturn new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\n\t\t\t\t}\n\n\t\t\t\t// Invalid color\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfunction _parseHexDigit(charCode: CharCode): number {\n\t\t\t\tswitch (charCode) {\n\t\t\t\t\tcase CharCode.Digit0: return 0;\n\t\t\t\t\tcase CharCode.Digit1: return 1;\n\t\t\t\t\tcase CharCode.Digit2: return 2;\n\t\t\t\t\tcase CharCode.Digit3: return 3;\n\t\t\t\t\tcase CharCode.Digit4: return 4;\n\t\t\t\t\tcase CharCode.Digit5: return 5;\n\t\t\t\t\tcase CharCode.Digit6: return 6;\n\t\t\t\t\tcase CharCode.Digit7: return 7;\n\t\t\t\t\tcase CharCode.Digit8: return 8;\n\t\t\t\t\tcase CharCode.Digit9: return 9;\n\t\t\t\t\tcase CharCode.a: return 10;\n\t\t\t\t\tcase CharCode.A: return 10;\n\t\t\t\t\tcase CharCode.b: return 11;\n\t\t\t\t\tcase CharCode.B: return 11;\n\t\t\t\t\tcase CharCode.c: return 12;\n\t\t\t\t\tcase CharCode.C: return 12;\n\t\t\t\t\tcase CharCode.d: return 13;\n\t\t\t\t\tcase CharCode.D: return 13;\n\t\t\t\t\tcase CharCode.e: return 14;\n\t\t\t\t\tcase CharCode.E: return 14;\n\t\t\t\t\tcase CharCode.f: return 15;\n\t\t\t\t\tcase CharCode.F: return 15;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nimport { IPosition } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { IColor, IColorInformation } from '../languages.js';\n\nexport interface IDocumentColorComputerTarget {\n\tgetValue(): string;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n\nfunction _parseCaptureGroups(captureGroups: IterableIterator<string>) {\n\tconst values = [];\n\tfor (const captureGroup of captureGroups) {\n\t\tconst parsedNumber = Number(captureGroup);\n\t\tif (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n\t\t\tvalues.push(parsedNumber);\n\t\t}\n\t}\n\treturn values;\n}\n\nfunction _toIColor(r: number, g: number, b: number, a: number): IColor {\n\treturn {\n\t\tred: r / 255,\n\t\tblue: b / 255,\n\t\tgreen: g / 255,\n\t\talpha: a\n\t};\n}\n\nfunction _findRange(model: IDocumentColorComputerTarget, match: RegExpMatchArray): IRange | undefined {\n\tconst index = match.index;\n\tconst length = match[0].length;\n\tif (index === undefined) {\n\t\treturn;\n\t}\n\tconst startPosition = model.positionAt(index);\n\tconst range: IRange = {\n\t\tstartLineNumber: startPosition.lineNumber,\n\t\tstartColumn: startPosition.column,\n\t\tendLineNumber: startPosition.lineNumber,\n\t\tendColumn: startPosition.column + length\n\t};\n\treturn range;\n}\n\nfunction _findHexColorInformation(range: IRange | undefined, hexValue: string) {\n\tif (!range) {\n\t\treturn;\n\t}\n\tconst parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n\tif (!parsedHexColor) {\n\t\treturn;\n\t}\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n\t};\n}\n\nfunction _findRGBColorInformation(range: IRange | undefined, matches: RegExpMatchArray[], isAlpha: boolean) {\n\tif (!range || matches.length !== 1) {\n\t\treturn;\n\t}\n\tconst match = matches[0]!;\n\tconst captureGroups = match.values();\n\tconst parsedRegex = _parseCaptureGroups(captureGroups);\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n\t};\n}\n\nfunction _findHSLColorInformation(range: IRange | undefined, matches: RegExpMatchArray[], isAlpha: boolean) {\n\tif (!range || matches.length !== 1) {\n\t\treturn;\n\t}\n\tconst match = matches[0]!;\n\tconst captureGroups = match.values();\n\tconst parsedRegex = _parseCaptureGroups(captureGroups);\n\tconst colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n\t};\n}\n\nfunction _findMatches(model: IDocumentColorComputerTarget | string, regex: RegExp): RegExpMatchArray[] {\n\tif (typeof model === 'string') {\n\t\treturn [...model.matchAll(regex)];\n\t} else {\n\t\treturn model.findMatches(regex);\n\t}\n}\n\nfunction computeColors(model: IDocumentColorComputerTarget): IColorInformation[] {\n\tconst result: IColorInformation[] = [];\n\t// Early validation for RGB and HSL\n\tconst initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|^(#)([A-Fa-f0-9]{3})\\b|^(#)([A-Fa-f0-9]{4})\\b|^(#)([A-Fa-f0-9]{6})\\b|^(#)([A-Fa-f0-9]{8})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{3})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{4})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{6})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{8})\\b/gm;\n\tconst initialValidationMatches = _findMatches(model, initialValidationRegex);\n\n\t// Potential colors have been found, validate the parameters\n\tif (initialValidationMatches.length > 0) {\n\t\tfor (const initialMatch of initialValidationMatches) {\n\t\t\tconst initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n\t\t\tconst colorScheme = initialCaptureGroups[1];\n\t\t\tconst colorParameters = initialCaptureGroups[2];\n\t\t\tif (!colorParameters) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet colorInformation;\n\t\t\tif (colorScheme === 'rgb') {\n\t\t\t\tconst regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n\t\t\t} else if (colorScheme === 'rgba') {\n\t\t\t\tconst regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n\t\t\t} else if (colorScheme === 'hsl') {\n\t\t\t\tconst regexParameters = /^\\(\\s*((?:360(?:\\.0+)?|(?:36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])(?:\\.\\d+)?))\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n\t\t\t} else if (colorScheme === 'hsla') {\n\t\t\t\tconst regexParameters = /^\\(\\s*((?:360(?:\\.0+)?|(?:36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])(?:\\.\\d+)?))\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(0[.][0-9]+|[.][0-9]+|[01][.]0*|[01])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n\t\t\t} else if (colorScheme === '#') {\n\t\t\t\tcolorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n\t\t\t}\n\t\t\tif (colorInformation) {\n\t\t\t\tresult.push(colorInformation);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model: IDocumentColorComputerTarget): IColorInformation[] {\n\tif (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nimport { IPosition } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { IColor, IColorInformation } from '../languages.js';\n\nexport interface IDocumentColorComputerTarget {\n\tgetValue(): string;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n\nfunction _parseCaptureGroups(captureGroups: IterableIterator<string>) {\n\tconst values = [];\n\tfor (const captureGroup of captureGroups) {\n\t\tconst parsedNumber = Number(captureGroup);\n\t\tif (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n\t\t\tvalues.push(parsedNumber);\n\t\t}\n\t}\n\treturn values;\n}\n\nfunction _toIColor(r: number, g: number, b: number, a: number): IColor {\n\treturn {\n\t\tred: r / 255,\n\t\tblue: b / 255,\n\t\tgreen: g / 255,\n\t\talpha: a\n\t};\n}\n\nfunction _findRange(model: IDocumentColorComputerTarget, match: RegExpMatchArray): IRange | undefined {\n\tconst index = match.index;\n\tconst length = match[0].length;\n\tif (index === undefined) {\n\t\treturn;\n\t}\n\tconst startPosition = model.positionAt(index);\n\tconst range: IRange = {\n\t\tstartLineNumber: startPosition.lineNumber,\n\t\tstartColumn: startPosition.column,\n\t\tendLineNumber: startPosition.lineNumber,\n\t\tendColumn: startPosition.column + length\n\t};\n\treturn range;\n}\n\nfunction _findHexColorInformation(range: IRange | undefined, hexValue: string) {\n\tif (!range) {\n\t\treturn;\n\t}\n\tconst parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n\tif (!parsedHexColor) {\n\t\treturn;\n\t}\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n\t};\n}\n\nfunction _findRGBColorInformation(range: IRange | undefined, matches: RegExpMatchArray[], isAlpha: boolean) {\n\tif (!range || matches.length !== 1) {\n\t\treturn;\n\t}\n\tconst match = matches[0]!;\n\tconst captureGroups = match.values();\n\tconst parsedRegex = _parseCaptureGroups(captureGroups);\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n\t};\n}\n\nfunction _findHSLColorInformation(range: IRange | undefined, matches: RegExpMatchArray[], isAlpha: boolean) {\n\tif (!range || matches.length !== 1) {\n\t\treturn;\n\t}\n\tconst match = matches[0]!;\n\tconst captureGroups = match.values();\n\tconst parsedRegex = _parseCaptureGroups(captureGroups);\n\tconst colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n\treturn {\n\t\trange: range,\n\t\tcolor: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n\t};\n}\n\nfunction _findMatches(model: IDocumentColorComputerTarget | string, regex: RegExp): RegExpMatchArray[] {\n\tif (typeof model === 'string') {\n\t\treturn [...model.matchAll(regex)];\n\t} else {\n\t\treturn model.findMatches(regex);\n\t}\n}\n\nfunction computeColors(model: IDocumentColorComputerTarget): IColorInformation[] {\n\tconst result: IColorInformation[] = [];\n\t// Early validation for RGB and HSL\n\tconst initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|^(#)([A-Fa-f0-9]{3})\\b|^(#)([A-Fa-f0-9]{4})\\b|^(#)([A-Fa-f0-9]{6})\\b|^(#)([A-Fa-f0-9]{8})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{3})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{4})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{6})\\b|(?<=['\"\\s])(#)([A-Fa-f0-9]{8})\\b/gm;\n\tconst initialValidationMatches = _findMatches(model, initialValidationRegex);\n\n\t// Potential colors have been found, validate the parameters\n\tif (initialValidationMatches.length > 0) {\n\t\tfor (const initialMatch of initialValidationMatches) {\n\t\t\tconst initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n\t\t\tconst colorScheme = initialCaptureGroups[1];\n\t\t\tconst colorParameters = initialCaptureGroups[2];\n\t\t\tif (!colorParameters) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet colorInformation;\n\t\t\tif (colorScheme === 'rgb') {\n\t\t\t\tconst regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n\t\t\t} else if (colorScheme === 'rgba') {\n\t\t\t\tconst regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n\t\t\t} else if (colorScheme === 'hsl') {\n\t\t\t\tconst regexParameters = /^\\(\\s*((?:360(?:\\.0+)?|(?:36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])(?:\\.\\d+)?))\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n\t\t\t} else if (colorScheme === 'hsla') {\n\t\t\t\tconst regexParameters = /^\\(\\s*((?:360(?:\\.0+)?|(?:36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])(?:\\.\\d+)?))\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*[\\s,]\\s*(0[.][0-9]+|[.][0-9]+|[01][.]0*|[01])\\s*\\)$/gm;\n\t\t\t\tcolorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n\t\t\t} else if (colorScheme === '#') {\n\t\t\t\tcolorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n\t\t\t}\n\t\t\tif (colorInformation) {\n\t\t\t\tresult.push(colorInformation);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model: IDocumentColorComputerTarget): IColorInformation[] {\n\tif (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange } from '../core/range.js';\nimport { FoldingRules } from '../languages/languageConfiguration.js';\nimport { isMultilineRegexSource } from '../model/textModelSearch.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\n\nexport interface ISectionHeaderFinderTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface FindSectionHeaderOptions {\n\tfoldingRules?: FoldingRules;\n\tfindRegionSectionHeaders: boolean;\n\tfindMarkSectionHeaders: boolean;\n\tmarkSectionHeaderRegex: string;\n}\n\nexport interface SectionHeader {\n\t/**\n\t * The location of the header text in the text model.\n\t */\n\trange: IRange;\n\t/**\n\t * The section header text.\n\t */\n\ttext: string;\n\t/**\n\t * Whether the section header includes a separator line.\n\t */\n\thasSeparatorLine: boolean;\n\t/**\n\t * This section should be omitted before rendering if it's not in a comment.\n\t */\n\tshouldBeInComments: boolean;\n}\n\nconst trimDashesRegex = /^-+|-+$/g;\n\nconst CHUNK_SIZE = 100;\nconst MAX_SECTION_LINES = 5;\n\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tlet headers: SectionHeader[] = [];\n\tif (options.findRegionSectionHeaders && options.foldingRules?.markers) {\n\t\tconst regionHeaders = collectRegionHeaders(model, options);\n\t\theaders = headers.concat(regionHeaders);\n\t}\n\tif (options.findMarkSectionHeaders) {\n\t\tconst markHeaders = collectMarkHeaders(model, options);\n\t\theaders = headers.concat(markHeaders);\n\t}\n\treturn headers;\n}\n\nfunction collectRegionHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tconst regionHeaders: SectionHeader[] = [];\n\tconst endLineNumber = model.getLineCount();\n\tfor (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tconst match = lineContent.match(options.foldingRules!.markers!.start);\n\t\tif (match) {\n\t\t\tconst range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n\t\t\tif (range.endColumn > range.startColumn) {\n\t\t\t\tconst sectionHeader = {\n\t\t\t\t\trange,\n\t\t\t\t\t...getHeaderText(lineContent.substring(match[0].length)),\n\t\t\t\t\tshouldBeInComments: false\n\t\t\t\t};\n\t\t\t\tif (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n\t\t\t\t\tregionHeaders.push(sectionHeader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn regionHeaders;\n}\n\nexport function collectMarkHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tconst markHeaders: SectionHeader[] = [];\n\tconst endLineNumber = model.getLineCount();\n\n\t// Validate regex to prevent infinite loops\n\tif (!options.markSectionHeaderRegex || options.markSectionHeaderRegex.trim() === '') {\n\t\treturn markHeaders;\n\t}\n\n\t// Create regex with flags for:\n\t// - 'd' for indices to get proper match positions\n\t// - 'm' for multi-line mode so ^ and $ match line starts/ends\n\t// - 's' for dot-all mode so . matches newlines\n\tconst multiline = isMultilineRegexSource(options.markSectionHeaderRegex);\n\tconst regex = new RegExp(options.markSectionHeaderRegex, `gdm${multiline ? 's' : ''}`);\n\n\t// Check if the regex would lead to an endless loop\n\tif (regExpLeadsToEndlessLoop(regex)) {\n\t\treturn markHeaders;\n\t}\n\n\t// Process text in overlapping chunks for better performance\n\tfor (let startLine = 1; startLine <= endLineNumber; startLine += CHUNK_SIZE - MAX_SECTION_LINES) {\n\t\tconst endLine = Math.min(startLine + CHUNK_SIZE - 1, endLineNumber);\n\t\tconst lines: string[] = [];\n\n\t\t// Collect lines for the current chunk\n\t\tfor (let i = startLine; i <= endLine; i++) {\n\t\t\tlines.push(model.getLineContent(i));\n\t\t}\n\n\t\tconst text = lines.join('\\n');\n\t\tregex.lastIndex = 0;\n\n\t\tlet match: RegExpExecArray | null;\n\t\twhile ((match = regex.exec(text)) !== null) {\n\t\t\t// Calculate which line this match starts on by counting newlines before it\n\t\t\tconst precedingText = text.substring(0, match.index);\n\t\t\tconst lineOffset = (precedingText.match(/\\n/g) || []).length;\n\t\t\tconst lineNumber = startLine + lineOffset;\n\n\t\t\t// Calculate match height to check overlap properly\n\t\t\tconst matchLines = match[0].split('\\n');\n\t\t\tconst matchHeight = matchLines.length;\n\t\t\tconst matchEndLine = lineNumber + matchHeight - 1;\n\n\t\t\t// Calculate start column - need to find the start of the line containing the match\n\t\t\tconst lineStartIndex = precedingText.lastIndexOf('\\n') + 1;\n\t\t\tconst startColumn = match.index - lineStartIndex + 1;\n\n\t\t\t// Calculate end column - need to handle multi-line matches\n\t\t\tconst lastMatchLine = matchLines[matchLines.length - 1];\n\t\t\tconst endColumn = matchHeight === 1 ? startColumn + match[0].length : lastMatchLine.length + 1;\n\n\t\t\tconst range = {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tendLineNumber: matchEndLine,\n\t\t\t\tendColumn\n\t\t\t};\n\n\t\t\tconst text2 = (match.groups ?? {})['label'] ?? '';\n\t\t\tconst hasSeparatorLine = ((match.groups ?? {})['separator'] ?? '') !== '';\n\n\t\t\tconst sectionHeader = {\n\t\t\t\trange,\n\t\t\t\ttext: text2,\n\t\t\t\thasSeparatorLine,\n\t\t\t\tshouldBeInComments: true\n\t\t\t};\n\n\t\t\tif (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n\t\t\t\t// only push if the previous one doesn't have this same linbe\n\t\t\t\tif (markHeaders.length === 0 || markHeaders[markHeaders.length - 1].range.endLineNumber < sectionHeader.range.startLineNumber) {\n\t\t\t\t\tmarkHeaders.push(sectionHeader);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move lastIndex past the current match to avoid infinite loop\n\t\t\tregex.lastIndex = match.index + match[0].length;\n\t\t}\n\t}\n\n\treturn markHeaders;\n}\n\nfunction getHeaderText(text: string): { text: string; hasSeparatorLine: boolean } {\n\ttext = text.trim();\n\tconst hasSeparatorLine = text.startsWith('-');\n\ttext = text.replace(trimDashesRegex, '');\n\treturn { text, hasSeparatorLine };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IRange } from '../core/range.js';\nimport { FoldingRules } from '../languages/languageConfiguration.js';\nimport { isMultilineRegexSource } from '../model/textModelSearch.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\n\nexport interface ISectionHeaderFinderTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n}\n\nexport interface FindSectionHeaderOptions {\n\tfoldingRules?: FoldingRules;\n\tfindRegionSectionHeaders: boolean;\n\tfindMarkSectionHeaders: boolean;\n\tmarkSectionHeaderRegex: string;\n}\n\nexport interface SectionHeader {\n\t/**\n\t * The location of the header text in the text model.\n\t */\n\trange: IRange;\n\t/**\n\t * The section header text.\n\t */\n\ttext: string;\n\t/**\n\t * Whether the section header includes a separator line.\n\t */\n\thasSeparatorLine: boolean;\n\t/**\n\t * This section should be omitted before rendering if it's not in a comment.\n\t */\n\tshouldBeInComments: boolean;\n}\n\nconst trimDashesRegex = /^-+|-+$/g;\n\nconst CHUNK_SIZE = 100;\nconst MAX_SECTION_LINES = 5;\n\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tlet headers: SectionHeader[] = [];\n\tif (options.findRegionSectionHeaders && options.foldingRules?.markers) {\n\t\tconst regionHeaders = collectRegionHeaders(model, options);\n\t\theaders = headers.concat(regionHeaders);\n\t}\n\tif (options.findMarkSectionHeaders) {\n\t\tconst markHeaders = collectMarkHeaders(model, options);\n\t\theaders = headers.concat(markHeaders);\n\t}\n\treturn headers;\n}\n\nfunction collectRegionHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tconst regionHeaders: SectionHeader[] = [];\n\tconst endLineNumber = model.getLineCount();\n\tfor (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tconst match = lineContent.match(options.foldingRules!.markers!.start);\n\t\tif (match) {\n\t\t\tconst range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n\t\t\tif (range.endColumn > range.startColumn) {\n\t\t\t\tconst sectionHeader = {\n\t\t\t\t\trange,\n\t\t\t\t\t...getHeaderText(lineContent.substring(match[0].length)),\n\t\t\t\t\tshouldBeInComments: false\n\t\t\t\t};\n\t\t\t\tif (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n\t\t\t\t\tregionHeaders.push(sectionHeader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn regionHeaders;\n}\n\nexport function collectMarkHeaders(model: ISectionHeaderFinderTarget, options: FindSectionHeaderOptions): SectionHeader[] {\n\tconst markHeaders: SectionHeader[] = [];\n\tconst endLineNumber = model.getLineCount();\n\n\t// Validate regex to prevent infinite loops\n\tif (!options.markSectionHeaderRegex || options.markSectionHeaderRegex.trim() === '') {\n\t\treturn markHeaders;\n\t}\n\n\t// Create regex with flags for:\n\t// - 'd' for indices to get proper match positions\n\t// - 'm' for multi-line mode so ^ and $ match line starts/ends\n\t// - 's' for dot-all mode so . matches newlines\n\tconst multiline = isMultilineRegexSource(options.markSectionHeaderRegex);\n\tconst regex = new RegExp(options.markSectionHeaderRegex, `gdm${multiline ? 's' : ''}`);\n\n\t// Check if the regex would lead to an endless loop\n\tif (regExpLeadsToEndlessLoop(regex)) {\n\t\treturn markHeaders;\n\t}\n\n\t// Process text in overlapping chunks for better performance\n\tfor (let startLine = 1; startLine <= endLineNumber; startLine += CHUNK_SIZE - MAX_SECTION_LINES) {\n\t\tconst endLine = Math.min(startLine + CHUNK_SIZE - 1, endLineNumber);\n\t\tconst lines: string[] = [];\n\n\t\t// Collect lines for the current chunk\n\t\tfor (let i = startLine; i <= endLine; i++) {\n\t\t\tlines.push(model.getLineContent(i));\n\t\t}\n\n\t\tconst text = lines.join('\\n');\n\t\tregex.lastIndex = 0;\n\n\t\tlet match: RegExpExecArray | null;\n\t\twhile ((match = regex.exec(text)) !== null) {\n\t\t\t// Calculate which line this match starts on by counting newlines before it\n\t\t\tconst precedingText = text.substring(0, match.index);\n\t\t\tconst lineOffset = (precedingText.match(/\\n/g) || []).length;\n\t\t\tconst lineNumber = startLine + lineOffset;\n\n\t\t\t// Calculate match height to check overlap properly\n\t\t\tconst matchLines = match[0].split('\\n');\n\t\t\tconst matchHeight = matchLines.length;\n\t\t\tconst matchEndLine = lineNumber + matchHeight - 1;\n\n\t\t\t// Calculate start column - need to find the start of the line containing the match\n\t\t\tconst lineStartIndex = precedingText.lastIndexOf('\\n') + 1;\n\t\t\tconst startColumn = match.index - lineStartIndex + 1;\n\n\t\t\t// Calculate end column - need to handle multi-line matches\n\t\t\tconst lastMatchLine = matchLines[matchLines.length - 1];\n\t\t\tconst endColumn = matchHeight === 1 ? startColumn + match[0].length : lastMatchLine.length + 1;\n\n\t\t\tconst range = {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn,\n\t\t\t\tendLineNumber: matchEndLine,\n\t\t\t\tendColumn\n\t\t\t};\n\n\t\t\tconst text2 = (match.groups ?? {})['label'] ?? '';\n\t\t\tconst hasSeparatorLine = ((match.groups ?? {})['separator'] ?? '') !== '';\n\n\t\t\tconst sectionHeader = {\n\t\t\t\trange,\n\t\t\t\ttext: text2,\n\t\t\t\thasSeparatorLine,\n\t\t\t\tshouldBeInComments: true\n\t\t\t};\n\n\t\t\tif (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n\t\t\t\t// only push if the previous one doesn't have this same linbe\n\t\t\t\tif (markHeaders.length === 0 || markHeaders[markHeaders.length - 1].range.endLineNumber < sectionHeader.range.startLineNumber) {\n\t\t\t\t\tmarkHeaders.push(sectionHeader);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move lastIndex past the current match to avoid infinite loop\n\t\t\tregex.lastIndex = match.index + match[0].length;\n\t\t}\n\t}\n\n\treturn markHeaders;\n}\n\nfunction getHeaderText(text: string): { text: string; hasSeparatorLine: boolean } {\n\ttext = text.trim();\n\tconst hasSeparatorLine = text.startsWith('-');\n\ttext = text.replace(trimDashesRegex, '');\n\treturn { text, hasSeparatorLine };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { isAbsolute, join, normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';\nimport { isNumber } from './types.js';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport { isAbsolute, join, normalize, posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from './strings.js';\nimport { isNumber } from './types.js';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from './errors.js';\nimport * as platform from './platform.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\nimport * as paths from './path.js';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellMetadataDiff = 'vscode-notebook-cell-metadata-diff';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeNotebookCellOutputDiff = 'vscode-notebook-cell-output-diff';\n\texport const vscodeNotebookMetadata = 'vscode-notebook-metadata';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\n\t/** Scheme used for LHS of code compare (aka diff) blocks in chat. */\n\texport const vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';\n\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatEditor = 'vscode-chat-editor';\n\n\t/** Scheme used for the chat input part */\n\texport const vscodeChatInput = 'chatSessionInput';\n\n\t/** Scheme for chat session content */\n\texport const vscodeChatSession = 'vscode-chat-session';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for input box for creating comments.\n\t */\n\texport const commentsInput = 'comment';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n\n\t/**\n\t * Scheme used for output panel resources\n\t */\n\texport const outputChannel = 'output';\n\n\t/**\n\t * Scheme used for the accessible view\n\t */\n\texport const accessibleView = 'accessible-view';\n\n\t/**\n\t * Used for snapshots of chat edits\n\t */\n\texport const chatEditingSnapshotScheme = 'chat-editing-snapshot-text-model';\n\texport const chatEditingModel = 'chat-editing-text-model';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = paths.posix.join(serverBasePath ?? '/', getServerProductSegment(product));\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerProductSegment(product: { quality?: string; commit?: string }) {\n\treturn `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\tif (globalThis._VSCODE_FILE_ROOT) {\n\t\t\tconst rootUriOrPath = globalThis._VSCODE_FILE_ROOT;\n\n\t\t\t// File URL (with scheme)\n\t\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(rootUriOrPath)) {\n\t\t\t\treturn URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);\n\t\t\t}\n\n\t\t\t// File Path (no scheme)\n\t\t\tconst modulePath = paths.join(rootUriOrPath, uriOrModule);\n\t\t\treturn URI.file(modulePath);\n\t\t}\n\n\t\tthrow new Error('Cannot determine URI for module id!');\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\nexport const CacheControlheaders: Record<string, string> = Object.freeze({\n\t'Cache-Control': 'no-cache, no-store'\n});\n\nexport const DocumentPolicyheaders: Record<string, string> = Object.freeze({\n\t'Document-Policy': 'include-js-call-stacks-in-crash-reports'\n});\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from './errors.js';\nimport * as platform from './platform.js';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from './strings.js';\nimport { URI } from './uri.js';\nimport * as paths from './path.js';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellMetadataDiff = 'vscode-notebook-cell-metadata-diff';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeNotebookCellOutputDiff = 'vscode-notebook-cell-output-diff';\n\texport const vscodeNotebookMetadata = 'vscode-notebook-metadata';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\n\t/** Scheme used for LHS of code compare (aka diff) blocks in chat. */\n\texport const vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';\n\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatEditor = 'vscode-chat-editor';\n\n\t/** Scheme used for the chat input part */\n\texport const vscodeChatInput = 'chatSessionInput';\n\n\t/** Scheme for chat session content */\n\texport const vscodeChatSession = 'vscode-chat-session';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for input box for creating comments.\n\t */\n\texport const commentsInput = 'comment';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n\n\t/**\n\t * Scheme used for output panel resources\n\t */\n\texport const outputChannel = 'output';\n\n\t/**\n\t * Scheme used for the accessible view\n\t */\n\texport const accessibleView = 'accessible-view';\n\n\t/**\n\t * Used for snapshots of chat edits\n\t */\n\texport const chatEditingSnapshotScheme = 'chat-editing-snapshot-text-model';\n\texport const chatEditingModel = 'chat-editing-text-model';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = paths.posix.join(serverBasePath ?? '/', getServerProductSegment(product));\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerProductSegment(product: { quality?: string; commit?: string }) {\n\treturn `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\tif (globalThis._VSCODE_FILE_ROOT) {\n\t\t\tconst rootUriOrPath = globalThis._VSCODE_FILE_ROOT;\n\n\t\t\t// File URL (with scheme)\n\t\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(rootUriOrPath)) {\n\t\t\t\treturn URI.joinPath(URI.parse(rootUriOrPath, true), uriOrModule);\n\t\t\t}\n\n\t\t\t// File Path (no scheme)\n\t\t\tconst modulePath = paths.join(rootUriOrPath, uriOrModule);\n\t\t\treturn URI.file(modulePath);\n\t\t}\n\n\t\tthrow new Error('Cannot determine URI for module id!');\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\nexport const CacheControlheaders: Record<string, string> = Object.freeze({\n\t'Cache-Control': 'no-cache, no-store'\n});\n\nexport const DocumentPolicyheaders: Record<string, string> = Object.freeze({\n\t'Document-Policy': 'include-js-call-stacks-in-crash-reports'\n});\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from './charCode.js';\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, isDisposable, MutableDisposable, toDisposable } from './lifecycle.js';\nimport { extUri as defaultExtUri, IExtUri } from './resources.js';\nimport { URI } from './uri.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\n/**\n * Returns a promise that can be cancelled using the provided cancellation token.\n *\n * @remarks When cancellation is requested, the promise will be rejected with a {@link CancellationError}.\n * If the promise resolves to a disposable object, it will be automatically disposed when cancellation\n * is requested.\n *\n * @param callback A function that accepts a cancellation token and returns a promise\n * @returns A promise that can be cancelled\n */\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\n\tlet isCancelled = false;\n\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tisCancelled = true;\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\n\t\t\tif (!isCancelled) {\n\t\t\t\tresolve(value);\n\n\t\t\t} else if (isDisposable(value)) {\n\t\t\t\t// promise has been cancelled, result is disposable and will\n\t\t\t\t// be cleaned up\n\t\t\t\tvalue.dispose();\n\t\t\t}\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: unknown) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: unknown) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Wraps a cancellable promise such that it is no cancellable. Can be used to\n * avoid issues with shared promises that would normally be returned as\n * cancellable to consumers.\n */\nexport function notCancellablePromise<T>(promise: CancelablePromise<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tpromise.then(resolve, reject);\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport function raceCancellablePromises<T>(cancellablePromises: (CancelablePromise<T> | Promise<T>)[]): CancelablePromise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst promise = Promise.race(promises) as CancelablePromise<T>;\n\tpromise.cancel = () => {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex && (cancellablePromise as CancelablePromise<T>).cancel) {\n\t\t\t\t(cancellablePromise as CancelablePromise<T>).cancel();\n\t\t\t}\n\t\t});\n\t};\n\tpromise.finally(() => {\n\t\tpromise.cancel();\n\t});\n\treturn promise;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n\n\tkeys(): IterableIterator<TKey> {\n\t\treturn this.promiseMap.keys();\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: unknown) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: Timeout;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.delete(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: unknown): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result as T);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport type Task<T = void> = () => (Promise<T> | T);\n\n/**\n * Processes tasks in the order they were scheduled.\n*/\nexport class TaskQueue {\n\tprivate _runningTask: Task<any> | undefined = undefined;\n\tprivate _pendingTasks: { task: Task<any>; deferred: DeferredPromise<any>; setUndefinedWhenCleared: boolean }[] = [];\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.\n\t*/\n\tpublic schedule<T>(task: Task<T>): Promise<T> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: false });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\t/**\n\t * Waits for the current and pending tasks to finish, then runs and awaits the given task.\n\t * If the task is skipped because of clearPending, the promise is resolved with undefined.\n\t*/\n\tpublic scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined> {\n\t\tconst deferred = new DeferredPromise<T>();\n\t\tthis._pendingTasks.push({ task, deferred, setUndefinedWhenCleared: true });\n\t\tthis._runIfNotRunning();\n\t\treturn deferred.p;\n\t}\n\n\tprivate _runIfNotRunning(): void {\n\t\tif (this._runningTask === undefined) {\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\tprivate async _processQueue(): Promise<void> {\n\t\tif (this._pendingTasks.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst next = this._pendingTasks.shift();\n\t\tif (!next) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._runningTask) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\n\t\tthis._runningTask = next.task;\n\n\t\ttry {\n\t\t\tconst result = await next.task();\n\t\t\tnext.deferred.complete(result);\n\t\t} catch (e) {\n\t\t\tnext.deferred.error(e);\n\t\t} finally {\n\t\t\tthis._runningTask = undefined;\n\t\t\tthis._processQueue();\n\t\t}\n\t}\n\n\t/**\n\t * Clears all pending tasks. Does not cancel the currently running task.\n\t*/\n\tpublic clearPending(): void {\n\t\tconst tasks = this._pendingTasks;\n\t\tthis._pendingTasks = [];\n\t\tfor (const task of tasks) {\n\t\t\tif (task.setUndefinedWhenCleared) {\n\t\t\t\ttask.deferred.complete(undefined);\n\t\t\t} else {\n\t\t\t\ttask.deferred.error(new CancellationError());\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: Timeout | undefined;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = undefined;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== undefined) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = undefined;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== undefined) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = undefined;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: Timeout | undefined;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = undefined;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== undefined;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = undefined;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: Timeout | undefined;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = undefined;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== undefined;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = undefined;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n\n\t/**\n\t * When enabled will guarantee that two distinct calls to `work()` are not executed\n\t * without throttle delay between them.\n\t * Otherwise if the worker isn't currently throttling it will execute work immediately.\n\t */\n\twaitThrottleDelayBetweenWorkUnits?: boolean;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\tprivate lastExecutionTime = 0;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\tconst timeSinceLastExecution = Date.now() - this.lastExecutionTime;\n\n\t\tif (!this.throttler.value && (!this.options.waitThrottleDelayBetweenWorkUnits || timeSinceLastExecution >= this.options.throttleDelay)) {\n\t\t\t// Work directly if we are not throttling and we are not\n\t\t\t// enforced to throttle between `work()` calls.\n\t\t\tthis.doWork();\n\t\t} else if (!this.throttler.value && this.options.waitThrottleDelayBetweenWorkUnits) {\n\t\t\t// Otherwise, schedule the throttler to work.\n\t\t\tthis.scheduleThrottler(Math.max(this.options.throttleDelay - timeSinceLastExecution, 0));\n\t\t} else {\n\t\t\t// Otherwise, our work will be picked up by the running throttler\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\t\tthis.lastExecutionTime = Date.now();\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.scheduleThrottler();\n\t\t}\n\t}\n\n\tprivate scheduleThrottler(delay = this.options.throttleDelay): void {\n\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\tthis.throttler.clear();\n\n\t\t\tthis.doWork();\n\t\t}, delay);\n\t\tthis.throttler.value.schedule();\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.pendingWork.length = 0;\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tconst safeGlobal: any = globalThis;\n\tif (typeof safeGlobal.requestIdleCallback !== 'function' || typeof safeGlobal.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner, timeout?) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: typeof safeGlobal, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner, timeout) => _runWhenIdle(globalThis, runner, timeout);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: unknown } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\tif (this.isSettled) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic settleWith(promise: Promise<T>): Promise<void> {\n\t\treturn promise.then(\n\t\t\tvalue => this.complete(value),\n\t\t\terror => this.error(error)\n\t\t);\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): unknown | Promise<unknown>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableObject<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\n\nexport function createCancelableAsyncIterableProducer<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableProducer<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableProducer<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitOneFn: (item: T) => void;\n\tprivate _emitManyFn: (item: T[]) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitOneFn = (item: T) => emitter.emitOne(item);\n\t\t\tthis._emitManyFn = (items: T[]) => emitter.emitMany(items);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t\tthis._emitOneFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._emitManyFn = (items: T[]) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = items.slice();\n\t\t\t} else {\n\t\t\t\titems.forEach(item => earlyItems!.push(item));\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitOneFn(item);\n\t}\n\n\temitMany(items: T[]) {\n\t\tthis._emitManyFn(items);\n\t}\n}\n\nexport function cancellableIterable<T>(iterableOrIterator: AsyncIterator<T> | AsyncIterable<T>, token: CancellationToken): AsyncIterableIterator<T> {\n\tconst iterator = Symbol.asyncIterator in iterableOrIterator ? iterableOrIterator[Symbol.asyncIterator]() : iterableOrIterator;\n\n\treturn {\n\t\tasync next(): Promise<IteratorResult<T>> {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t\tconst result = await raceCancellation(iterator.next(), token);\n\t\t\treturn result || { done: true, value: undefined };\n\t\t},\n\t\tthrow: iterator.throw?.bind(iterator),\n\t\treturn: iterator.return?.bind(iterator),\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\ntype ProducerConsumerValue<T> = {\n\tok: true;\n\tvalue: T;\n} | {\n\tok: false;\n\terror: Error;\n};\n\nclass ProducerConsumer<T> {\n\tprivate readonly _unsatisfiedConsumers: DeferredPromise<T>[] = [];\n\tprivate readonly _unconsumedValues: ProducerConsumerValue<T>[] = [];\n\tprivate _finalValue: ProducerConsumerValue<T> | undefined;\n\n\tpublic get hasFinalValue(): boolean {\n\t\treturn !!this._finalValue;\n\t}\n\n\tproduce(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tif (this._unsatisfiedConsumers.length > 0) {\n\t\t\tconst deferred = this._unsatisfiedConsumers.shift()!;\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t} else {\n\t\t\tthis._unconsumedValues.push(value);\n\t\t}\n\t}\n\n\tproduceFinal(value: ProducerConsumerValue<T>): void {\n\t\tthis._ensureNoFinalValue();\n\t\tthis._finalValue = value;\n\t\tfor (const deferred of this._unsatisfiedConsumers) {\n\t\t\tthis._resolveOrRejectDeferred(deferred, value);\n\t\t}\n\t\tthis._unsatisfiedConsumers.length = 0;\n\t}\n\n\tprivate _ensureNoFinalValue(): void {\n\t\tif (this._finalValue) {\n\t\t\tthrow new BugIndicatingError('ProducerConsumer: cannot produce after final value has been set');\n\t\t}\n\t}\n\n\tprivate _resolveOrRejectDeferred(deferred: DeferredPromise<T>, value: ProducerConsumerValue<T>): void {\n\t\tif (value.ok) {\n\t\t\tdeferred.complete(value.value);\n\t\t} else {\n\t\t\tdeferred.error(value.error);\n\t\t}\n\t}\n\n\tconsume(): Promise<T> {\n\t\tif (this._unconsumedValues.length > 0 || this._finalValue) {\n\t\t\tconst value = this._unconsumedValues.length > 0 ? this._unconsumedValues.shift()! : this._finalValue!;\n\t\t\tif (value.ok) {\n\t\t\t\treturn Promise.resolve(value.value);\n\t\t\t} else {\n\t\t\t\treturn Promise.reject(value.error);\n\t\t\t}\n\t\t} else {\n\t\t\tconst deferred = new DeferredPromise<T>();\n\t\t\tthis._unsatisfiedConsumers.push(deferred);\n\t\t\treturn deferred.p;\n\t\t}\n\t}\n}\n\n/**\n * Important difference to AsyncIterableObject:\n * If it is iterated two times, the second iterator will not see the values emitted by the first iterator.\n */\nexport class AsyncIterableProducer<T> implements AsyncIterable<T> {\n\tprivate readonly _producerConsumer = new ProducerConsumer<IteratorResult<T>>();\n\n\tconstructor(executor: AsyncIterableExecutor<T>, private readonly _onReturn?: () => void) {\n\t\tqueueMicrotask(async () => {\n\t\t\tconst p = executor({\n\t\t\t\temitOne: value => this._producerConsumer.produce({ ok: true, value: { done: false, value: value } }),\n\t\t\t\temitMany: values => {\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tthis._producerConsumer.produce({ ok: true, value: { done: false, value: value } });\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treject: error => this._finishError(error),\n\t\t\t});\n\n\t\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\t\ttry {\n\t\t\t\t\tawait p;\n\t\t\t\t\tthis._finishOk();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._finishError(error);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromisesResolveOrder<T>(promises: Promise<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableProducer.fromArray<any>([]);\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn new AsyncIterableProducer<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableProducer<R> {\n\t\treturn AsyncIterableProducer.map(this, mapFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableProducer<T> {\n\t\treturn <AsyncIterableProducer<T>>AsyncIterableProducer.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableProducer<NonNullable<T>> {\n\t\treturn AsyncIterableProducer.coalesce(this) as AsyncIterableProducer<NonNullable<T>>;\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn new AsyncIterableProducer<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter<T2 extends T>(filterFn: (item: T) => item is T2): AsyncIterableProducer<T2>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T>;\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableProducer<T> {\n\t\treturn AsyncIterableProducer.filter(this, filterFn);\n\t}\n\n\tprivate _finishOk(): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: true, value: { done: true, value: undefined } });\n\t\t}\n\t}\n\n\tprivate _finishError(error: Error): void {\n\t\tif (!this._producerConsumer.hasFinalValue) {\n\t\t\tthis._producerConsumer.produceFinal({ ok: false, error: error });\n\t\t}\n\t\t// Warning: this can cause to dropped errors.\n\t}\n\n\tprivate readonly _iterator: AsyncIterator<T, void, void> = {\n\t\tnext: () => this._producerConsumer.consume(),\n\t\treturn: () => {\n\t\t\tthis._onReturn?.();\n\t\t\treturn Promise.resolve({ done: true, value: undefined });\n\t\t},\n\t\tthrow: async (e) => {\n\t\t\tthis._finishError(e);\n\t\t\treturn { done: true, value: undefined };\n\t\t},\n\t};\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, void, void> {\n\t\treturn this._iterator;\n\t}\n}\n\nexport class CancelableAsyncIterableProducer<T> extends AsyncIterableProducer<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\n//#endregion\n\nexport const AsyncReaderEndOfStream = Symbol('AsyncReaderEndOfStream');\n\nexport class AsyncReader<T> {\n\tprivate _buffer: T[] = [];\n\tprivate _atEnd = false;\n\n\tpublic get endOfStream(): boolean { return this._buffer.length === 0 && this._atEnd; }\n\tprivate _extendBufferPromise: Promise<void> | undefined;\n\n\tconstructor(\n\t\tprivate readonly _source: AsyncIterator<T>\n\t) {\n\t}\n\n\tpublic async read(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer.shift()!;\n\t}\n\n\tpublic async readWhile(predicate: (value: T) => boolean, callback: (element: T) => unknown): Promise<void> {\n\t\tdo {\n\t\t\tconst piece = await this.peek();\n\t\t\tif (piece === AsyncReaderEndOfStream) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!predicate(piece)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait this.read(); // consume\n\t\t\tawait callback(piece);\n\t\t} while (true);\n\t}\n\n\tpublic readBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tconst value = this.peekBufferedOrThrow();\n\t\tthis._buffer.shift();\n\t\treturn value;\n\t}\n\n\tpublic async consumeToEnd(): Promise<void> {\n\t\twhile (!this.endOfStream) {\n\t\t\tawait this.read();\n\t\t}\n\t}\n\n\tpublic async peek(): Promise<T | typeof AsyncReaderEndOfStream> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait this._extendBuffer();\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic peekBufferedOrThrow(): T | typeof AsyncReaderEndOfStream {\n\t\tif (this._buffer.length === 0) {\n\t\t\tif (this._atEnd) {\n\t\t\t\treturn AsyncReaderEndOfStream;\n\t\t\t}\n\t\t\tthrow new BugIndicatingError('No buffered elements');\n\t\t}\n\n\t\treturn this._buffer[0];\n\t}\n\n\tpublic async peekTimeout(timeoutMs: number): Promise<T | typeof AsyncReaderEndOfStream | undefined> {\n\t\tif (this._buffer.length === 0 && !this._atEnd) {\n\t\t\tawait raceTimeout(this._extendBuffer(), timeoutMs);\n\t\t}\n\t\tif (this._atEnd) {\n\t\t\treturn AsyncReaderEndOfStream;\n\t\t}\n\t\tif (this._buffer.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._buffer[0];\n\t}\n\n\tprivate _extendBuffer(): Promise<void> {\n\t\tif (this._atEnd) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (!this._extendBufferPromise) {\n\t\t\tthis._extendBufferPromise = (async () => {\n\t\t\t\tconst { value, done } = await this._source.next();\n\t\t\t\tthis._extendBufferPromise = undefined;\n\t\t\t\tif (done) {\n\t\t\t\t\tthis._atEnd = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._buffer.push(value);\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\treturn this._extendBufferPromise;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values: Uint32Array;\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum: Uint32Array;\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate readonly prefixSumValidIndex: Int32Array;\n\n\tconstructor(values: Uint32Array) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = new Uint32Array(values.length);\n\t\tthis.prefixSumValidIndex = new Int32Array(1);\n\t\tthis.prefixSumValidIndex[0] = -1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this.values.length;\n\t}\n\n\tpublic insertValues(insertIndex: number, insertValues: Uint32Array): boolean {\n\t\tinsertIndex = toUint32(insertIndex);\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\t\tconst insertValuesLen = insertValues.length;\n\n\t\tif (insertValuesLen === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length + insertValuesLen);\n\t\tthis.values.set(oldValues.subarray(0, insertIndex), 0);\n\t\tthis.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n\t\tthis.values.set(insertValues, insertIndex);\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = insertIndex - 1;\n\t\t}\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic setValue(index: number, value: number): boolean {\n\t\tindex = toUint32(index);\n\t\tvalue = toUint32(value);\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = index - 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic removeValues(startIndex: number, count: number): boolean {\n\t\tstartIndex = toUint32(startIndex);\n\t\tcount = toUint32(count);\n\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\n\t\tif (startIndex >= oldValues.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst maxCount = oldValues.length - startIndex;\n\t\tif (count >= maxCount) {\n\t\t\tcount = maxCount;\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length - count);\n\t\tthis.values.set(oldValues.subarray(0, startIndex), 0);\n\t\tthis.values.set(oldValues.subarray(startIndex + count), startIndex);\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = startIndex - 1;\n\t\t}\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getTotalSum(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._getPrefixSum(this.values.length - 1);\n\t}\n\n\t/**\n\t * Returns the sum of the first `index + 1` many items.\n\t * @returns `SUM(0 <= j <= index, values[j])`.\n\t */\n\tpublic getPrefixSum(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex = toUint32(index);\n\t\treturn this._getPrefixSum(index);\n\t}\n\n\tprivate _getPrefixSum(index: number): number {\n\t\tif (index <= this.prefixSumValidIndex[0]) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex[0] + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tsum = Math.floor(sum);\n\n\t\t// Compute all sums (to get a fully valid prefixSum)\n\t\tthis.getTotalSum();\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStop = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tmidStop = this.prefixSum[mid];\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (sum < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (sum >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, sum - midStart);\n\t}\n}\n\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n\tprivate _values: number[];\n\tprivate _isValid: boolean;\n\tprivate _validEndIndex: number;\n\n\t/**\n\t * _prefixSum[i] = SUM(values[j]), 0 <= j <= i\n\t */\n\tprivate _prefixSum: number[];\n\n\t/**\n\t * _indexBySum[sum] = idx => _prefixSum[idx - 1] <= sum < _prefixSum[idx]\n\t*/\n\tprivate _indexBySum: number[];\n\n\tconstructor(values: number[]) {\n\t\tthis._values = values;\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = -1;\n\t\tthis._prefixSum = [];\n\t\tthis._indexBySum = [];\n\t}\n\n\t/**\n\t * @returns SUM(0 <= j < values.length, values[j])\n\t */\n\tpublic getTotalSum(): number {\n\t\tthis._ensureValid();\n\t\treturn this._indexBySum.length;\n\t}\n\n\t/**\n\t * Returns the sum of the first `count` many items.\n\t * @returns `SUM(0 <= j < count, values[j])`.\n\t */\n\tpublic getPrefixSum(count: number): number {\n\t\tthis._ensureValid();\n\t\tif (count === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._prefixSum[count - 1];\n\t}\n\n\t/**\n\t * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n\t */\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tthis._ensureValid();\n\t\tconst idx = this._indexBySum[sum];\n\t\tconst viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n\t\treturn new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n\t}\n\n\tpublic removeValues(start: number, deleteCount: number): void {\n\t\tthis._values.splice(start, deleteCount);\n\t\tthis._invalidate(start);\n\t}\n\n\tpublic insertValues(insertIndex: number, insertArr: number[]): void {\n\t\tthis._values = arrayInsert(this._values, insertIndex, insertArr);\n\t\tthis._invalidate(insertIndex);\n\t}\n\n\tprivate _invalidate(index: number): void {\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = Math.min(this._validEndIndex, index - 1);\n\t}\n\n\tprivate _ensureValid(): void {\n\t\tif (this._isValid) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n\t\t\tconst value = this._values[i];\n\t\t\tconst sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n\n\t\t\tthis._prefixSum[i] = sumAbove + value;\n\t\t\tfor (let j = 0; j < value; j++) {\n\t\t\t\tthis._indexBySum[sumAbove + j] = i;\n\t\t\t}\n\t\t}\n\n\t\t// trim things\n\t\tthis._prefixSum.length = this._values.length;\n\t\tthis._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n\n\t\t// mark as valid\n\t\tthis._isValid = true;\n\t\tthis._validEndIndex = this._values.length - 1;\n\t}\n\n\tpublic setValue(index: number, value: number): void {\n\t\tif (this._values[index] === value) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._values[index] = value;\n\t\tthis._invalidate(index);\n\t}\n}\n\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly index: number,\n\t\tpublic readonly remainder: number\n\t) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values: Uint32Array;\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum: Uint32Array;\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate readonly prefixSumValidIndex: Int32Array;\n\n\tconstructor(values: Uint32Array) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = new Uint32Array(values.length);\n\t\tthis.prefixSumValidIndex = new Int32Array(1);\n\t\tthis.prefixSumValidIndex[0] = -1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this.values.length;\n\t}\n\n\tpublic insertValues(insertIndex: number, insertValues: Uint32Array): boolean {\n\t\tinsertIndex = toUint32(insertIndex);\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\t\tconst insertValuesLen = insertValues.length;\n\n\t\tif (insertValuesLen === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length + insertValuesLen);\n\t\tthis.values.set(oldValues.subarray(0, insertIndex), 0);\n\t\tthis.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n\t\tthis.values.set(insertValues, insertIndex);\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = insertIndex - 1;\n\t\t}\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic setValue(index: number, value: number): boolean {\n\t\tindex = toUint32(index);\n\t\tvalue = toUint32(value);\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = index - 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic removeValues(startIndex: number, count: number): boolean {\n\t\tstartIndex = toUint32(startIndex);\n\t\tcount = toUint32(count);\n\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\n\t\tif (startIndex >= oldValues.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst maxCount = oldValues.length - startIndex;\n\t\tif (count >= maxCount) {\n\t\t\tcount = maxCount;\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length - count);\n\t\tthis.values.set(oldValues.subarray(0, startIndex), 0);\n\t\tthis.values.set(oldValues.subarray(startIndex + count), startIndex);\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = startIndex - 1;\n\t\t}\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getTotalSum(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._getPrefixSum(this.values.length - 1);\n\t}\n\n\t/**\n\t * Returns the sum of the first `index + 1` many items.\n\t * @returns `SUM(0 <= j <= index, values[j])`.\n\t */\n\tpublic getPrefixSum(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex = toUint32(index);\n\t\treturn this._getPrefixSum(index);\n\t}\n\n\tprivate _getPrefixSum(index: number): number {\n\t\tif (index <= this.prefixSumValidIndex[0]) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex[0] + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tsum = Math.floor(sum);\n\n\t\t// Compute all sums (to get a fully valid prefixSum)\n\t\tthis.getTotalSum();\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStop = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tmidStop = this.prefixSum[mid];\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (sum < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (sum >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, sum - midStart);\n\t}\n}\n\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n\tprivate _values: number[];\n\tprivate _isValid: boolean;\n\tprivate _validEndIndex: number;\n\n\t/**\n\t * _prefixSum[i] = SUM(values[j]), 0 <= j <= i\n\t */\n\tprivate _prefixSum: number[];\n\n\t/**\n\t * _indexBySum[sum] = idx => _prefixSum[idx - 1] <= sum < _prefixSum[idx]\n\t*/\n\tprivate _indexBySum: number[];\n\n\tconstructor(values: number[]) {\n\t\tthis._values = values;\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = -1;\n\t\tthis._prefixSum = [];\n\t\tthis._indexBySum = [];\n\t}\n\n\t/**\n\t * @returns SUM(0 <= j < values.length, values[j])\n\t */\n\tpublic getTotalSum(): number {\n\t\tthis._ensureValid();\n\t\treturn this._indexBySum.length;\n\t}\n\n\t/**\n\t * Returns the sum of the first `count` many items.\n\t * @returns `SUM(0 <= j < count, values[j])`.\n\t */\n\tpublic getPrefixSum(count: number): number {\n\t\tthis._ensureValid();\n\t\tif (count === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._prefixSum[count - 1];\n\t}\n\n\t/**\n\t * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n\t */\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tthis._ensureValid();\n\t\tconst idx = this._indexBySum[sum];\n\t\tconst viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n\t\treturn new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n\t}\n\n\tpublic removeValues(start: number, deleteCount: number): void {\n\t\tthis._values.splice(start, deleteCount);\n\t\tthis._invalidate(start);\n\t}\n\n\tpublic insertValues(insertIndex: number, insertArr: number[]): void {\n\t\tthis._values = arrayInsert(this._values, insertIndex, insertArr);\n\t\tthis._invalidate(insertIndex);\n\t}\n\n\tprivate _invalidate(index: number): void {\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = Math.min(this._validEndIndex, index - 1);\n\t}\n\n\tprivate _ensureValid(): void {\n\t\tif (this._isValid) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n\t\t\tconst value = this._values[i];\n\t\t\tconst sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n\n\t\t\tthis._prefixSum[i] = sumAbove + value;\n\t\t\tfor (let j = 0; j < value; j++) {\n\t\t\t\tthis._indexBySum[sumAbove + j] = i;\n\t\t\t}\n\t\t}\n\n\t\t// trim things\n\t\tthis._prefixSum.length = this._values.length;\n\t\tthis._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n\n\t\t// mark as valid\n\t\tthis._isValid = true;\n\t\tthis._validEndIndex = this._values.length - 1;\n\t}\n\n\tpublic setValue(index: number, value: number): void {\n\t\tif (this._values[index] === value) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._values[index] = value;\n\t\tthis._invalidate(index);\n\t}\n}\n\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly index: number,\n\t\tpublic readonly remainder: number\n\t) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\n\nexport interface IModelContentChange {\n\t/**\n\t * The old range that got replaced.\n\t */\n\treadonly range: IRange;\n\t/**\n\t * The offset of the range that got replaced.\n\t */\n\treadonly rangeOffset: number;\n\t/**\n\t * The length of the range that got replaced.\n\t */\n\treadonly rangeLength: number;\n\t/**\n\t * The new text for the range.\n\t */\n\treadonly text: string;\n}\n\nexport interface IModelChangedEvent {\n\t/**\n\t * The actual changes.\n\t */\n\treadonly changes: IModelContentChange[];\n\t/**\n\t * The (new) end-of-line character.\n\t */\n\treadonly eol: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\treadonly versionId: number;\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\treadonly isUndoing: boolean;\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\treadonly isRedoing: boolean;\n}\n\nexport interface IMirrorTextModel {\n\treadonly version: number;\n}\n\nexport class MirrorTextModel implements IMirrorTextModel {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer | null;\n\tprivate _cachedTextValue: string | null;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t\tthis._lineStarts = null;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\tif (this._cachedTextValue === null) {\n\t\t\tthis._cachedTextValue = this._lines.join(this._eol);\n\t\t}\n\t\treturn this._cachedTextValue;\n\t}\n\n\tonEvents(e: IModelChangedEvent): void {\n\t\tif (e.eol && e.eol !== this._eol) {\n\t\t\tthis._eol = e.eol;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tconst changes = e.changes;\n\t\tfor (const change of changes) {\n\t\t\tthis._acceptDeleteRange(change.range);\n\t\t\tthis._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n\t\t}\n\n\t\tthis._versionId = e.versionId;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tconst linesLength = this._lines.length;\n\t\t\tconst lineStartValues = new Uint32Array(linesLength);\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tlineStartValues[i] = this._lines[i].length + eolLength;\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex: number, newValue: string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, insertText: string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tconst insertLines = splitLines(insertText);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tconst newLengths = new Uint32Array(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\n\nexport interface IModelContentChange {\n\t/**\n\t * The old range that got replaced.\n\t */\n\treadonly range: IRange;\n\t/**\n\t * The offset of the range that got replaced.\n\t */\n\treadonly rangeOffset: number;\n\t/**\n\t * The length of the range that got replaced.\n\t */\n\treadonly rangeLength: number;\n\t/**\n\t * The new text for the range.\n\t */\n\treadonly text: string;\n}\n\nexport interface IModelChangedEvent {\n\t/**\n\t * The actual changes.\n\t */\n\treadonly changes: IModelContentChange[];\n\t/**\n\t * The (new) end-of-line character.\n\t */\n\treadonly eol: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\treadonly versionId: number;\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\treadonly isUndoing: boolean;\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\treadonly isRedoing: boolean;\n}\n\nexport interface IMirrorTextModel {\n\treadonly version: number;\n}\n\nexport class MirrorTextModel implements IMirrorTextModel {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer | null;\n\tprivate _cachedTextValue: string | null;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t\tthis._lineStarts = null;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\tif (this._cachedTextValue === null) {\n\t\t\tthis._cachedTextValue = this._lines.join(this._eol);\n\t\t}\n\t\treturn this._cachedTextValue;\n\t}\n\n\tonEvents(e: IModelChangedEvent): void {\n\t\tif (e.eol && e.eol !== this._eol) {\n\t\t\tthis._eol = e.eol;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tconst changes = e.changes;\n\t\tfor (const change of changes) {\n\t\t\tthis._acceptDeleteRange(change.range);\n\t\t\tthis._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n\t\t}\n\n\t\tthis._versionId = e.versionId;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tconst linesLength = this._lines.length;\n\t\t\tconst lineStartValues = new Uint32Array(linesLength);\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tlineStartValues[i] = this._lines[i].length + eolLength;\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex: number, newValue: string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, insertText: string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tconst insertLines = splitLines(insertText);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tconst newLengths = new Uint32Array(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IntervalTimer } from '../../../../base/common/async.js';\nimport { Disposable, DisposableStore, dispose, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IWebWorkerClient, IWebWorkerServer } from '../../../../base/common/worker/webWorker.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { IRange, Range } from '../../core/range.js';\nimport { ensureValidWordDefinition, getWordAtText, IWordAtPosition } from '../../core/wordHelper.js';\nimport { IDocumentColorComputerTarget } from '../../languages/defaultDocumentColorsComputer.js';\nimport { ILinkComputerTarget } from '../../languages/linkComputer.js';\nimport { MirrorTextModel as BaseMirrorModel, IModelChangedEvent } from '../../model/mirrorTextModel.js';\nimport { IMirrorModel, IWordRange } from '../editorWebWorker.js';\nimport { IModelService } from '../model.js';\nimport { IRawModelData, IWorkerTextModelSyncChannelServer } from './textModelSync.protocol.js';\n\n/**\n * Stop syncing a model to the worker if it was not needed for 1 min.\n */\nexport const STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;\n\nexport const WORKER_TEXT_MODEL_SYNC_CHANNEL = 'workerTextModelSync';\n\nexport class WorkerTextModelSyncClient extends Disposable {\n\n\tpublic static create(workerClient: IWebWorkerClient<any>, modelService: IModelService): WorkerTextModelSyncClient {\n\t\treturn new WorkerTextModelSyncClient(\n\t\t\tworkerClient.getChannel<IWorkerTextModelSyncChannelServer>(WORKER_TEXT_MODEL_SYNC_CHANNEL),\n\t\t\tmodelService\n\t\t);\n\t}\n\n\tprivate readonly _proxy: IWorkerTextModelSyncChannelServer;\n\tprivate readonly _modelService: IModelService;\n\tprivate _syncedModels: { [modelUrl: string]: IDisposable } = Object.create(null);\n\tprivate _syncedModelsLastUsedTime: { [modelUrl: string]: number } = Object.create(null);\n\n\tconstructor(proxy: IWorkerTextModelSyncChannelServer, modelService: IModelService, keepIdleModels: boolean = false) {\n\t\tsuper();\n\t\tthis._proxy = proxy;\n\t\tthis._modelService = modelService;\n\n\t\tif (!keepIdleModels) {\n\t\t\tconst timer = new IntervalTimer();\n\t\t\ttimer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));\n\t\t\tthis._register(timer);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tfor (const modelUrl in this._syncedModels) {\n\t\t\tdispose(this._syncedModels[modelUrl]);\n\t\t}\n\t\tthis._syncedModels = Object.create(null);\n\t\tthis._syncedModelsLastUsedTime = Object.create(null);\n\t\tsuper.dispose();\n\t}\n\n\tpublic ensureSyncedResources(resources: URI[], forceLargeModels: boolean = false): void {\n\t\tfor (const resource of resources) {\n\t\t\tconst resourceStr = resource.toString();\n\n\t\t\tif (!this._syncedModels[resourceStr]) {\n\t\t\t\tthis._beginModelSync(resource, forceLargeModels);\n\t\t\t}\n\t\t\tif (this._syncedModels[resourceStr]) {\n\t\t\t\tthis._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _checkStopModelSync(): void {\n\t\tconst currentTime = (new Date()).getTime();\n\n\t\tconst toRemove: string[] = [];\n\t\tfor (const modelUrl in this._syncedModelsLastUsedTime) {\n\t\t\tconst elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];\n\t\t\tif (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {\n\t\t\t\ttoRemove.push(modelUrl);\n\t\t\t}\n\t\t}\n\n\t\tfor (const e of toRemove) {\n\t\t\tthis._stopModelSync(e);\n\t\t}\n\t}\n\n\tprivate _beginModelSync(resource: URI, forceLargeModels: boolean): void {\n\t\tconst model = this._modelService.getModel(resource);\n\t\tif (!model) {\n\t\t\treturn;\n\t\t}\n\t\tif (!forceLargeModels && model.isTooLargeForSyncing()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelUrl = resource.toString();\n\n\t\tthis._proxy.$acceptNewModel({\n\t\t\turl: model.uri.toString(),\n\t\t\tlines: model.getLinesContent(),\n\t\t\tEOL: model.getEOL(),\n\t\t\tversionId: model.getVersionId()\n\t\t});\n\n\t\tconst toDispose = new DisposableStore();\n\t\ttoDispose.add(model.onDidChangeContent((e) => {\n\t\t\tthis._proxy.$acceptModelChanged(modelUrl.toString(), e);\n\t\t}));\n\t\ttoDispose.add(model.onWillDispose(() => {\n\t\t\tthis._stopModelSync(modelUrl);\n\t\t}));\n\t\ttoDispose.add(toDisposable(() => {\n\t\t\tthis._proxy.$acceptRemovedModel(modelUrl);\n\t\t}));\n\n\t\tthis._syncedModels[modelUrl] = toDispose;\n\t}\n\n\tprivate _stopModelSync(modelUrl: string): void {\n\t\tconst toDispose = this._syncedModels[modelUrl];\n\t\tdelete this._syncedModels[modelUrl];\n\t\tdelete this._syncedModelsLastUsedTime[modelUrl];\n\t\tdispose(toDispose);\n\t}\n}\n\nexport class WorkerTextModelSyncServer implements IWorkerTextModelSyncChannelServer {\n\n\tprivate readonly _models: { [uri: string]: MirrorModel };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\n\tpublic bindToServer(workerServer: IWebWorkerServer): void {\n\t\tworkerServer.setChannel(WORKER_TEXT_MODEL_SYNC_CHANNEL, this);\n\t}\n\n\tpublic getModel(uri: string): ICommonModel | undefined {\n\t\treturn this._models[uri];\n\t}\n\n\tpublic getModels(): ICommonModel[] {\n\t\tconst all: MirrorModel[] = [];\n\t\tObject.keys(this._models).forEach((key) => all.push(this._models[key]));\n\t\treturn all;\n\t}\n\n\t$acceptNewModel(data: IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n\t}\n\n\t$acceptModelChanged(uri: string, e: IModelChangedEvent): void {\n\t\tif (!this._models[uri]) {\n\t\t\treturn;\n\t\t}\n\t\tconst model = this._models[uri];\n\t\tmodel.onEvents(e);\n\t}\n\n\t$acceptRemovedModel(uri: string): void {\n\t\tif (!this._models[uri]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[uri];\n\t}\n}\n\nexport class MirrorModel extends BaseMirrorModel implements ICommonModel {\n\n\tpublic get uri(): URI {\n\t\treturn this._uri;\n\t}\n\n\tpublic get eol(): string {\n\t\treturn this._eol;\n\t}\n\n\tpublic getValue(): string {\n\t\treturn this.getText();\n\t}\n\n\tpublic findMatches(regex: RegExp): RegExpMatchArray[] {\n\t\tconst matches = [];\n\t\tfor (let i = 0; i < this._lines.length; i++) {\n\t\t\tconst line = this._lines[i];\n\t\t\tconst offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n\t\t\tconst iteratorOverMatches = line.matchAll(regex);\n\t\t\tfor (const match of iteratorOverMatches) {\n\t\t\t\tif (match.index || match.index === 0) {\n\t\t\t\t\tmatch.index = match.index + offsetToAdd;\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null {\n\n\t\tconst wordAtText = getWordAtText(\n\t\t\tposition.column,\n\t\t\tensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\n\tpublic words(wordDefinition: RegExp): Iterable<string> {\n\n\t\tconst lines = this._lines;\n\t\tconst wordenize = this._wordenize.bind(this);\n\n\t\tlet lineNumber = 0;\n\t\tlet lineText = '';\n\t\tlet wordRangesIdx = 0;\n\t\tlet wordRanges: IWordRange[] = [];\n\n\t\treturn {\n\t\t\t*[Symbol.iterator]() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (wordRangesIdx < wordRanges.length) {\n\t\t\t\t\t\tconst value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n\t\t\t\t\t\twordRangesIdx += 1;\n\t\t\t\t\t\tyield value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (lineNumber < lines.length) {\n\t\t\t\t\t\t\tlineText = lines[lineNumber];\n\t\t\t\t\t\t\twordRanges = wordenize(lineText, wordDefinition);\n\t\t\t\t\t\t\twordRangesIdx = 0;\n\t\t\t\t\t\t\tlineNumber += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic getLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[] {\n\t\tconst content = this._lines[lineNumber - 1];\n\t\tconst ranges = this._wordenize(content, wordDefinition);\n\t\tconst words: IWordAtPosition[] = [];\n\t\tfor (const range of ranges) {\n\t\t\twords.push({\n\t\t\t\tword: content.substring(range.start, range.end),\n\t\t\t\tstartColumn: range.start + 1,\n\t\t\t\tendColumn: range.end + 1\n\t\t\t});\n\t\t}\n\t\treturn words;\n\t}\n\n\tprivate _wordenize(content: string, wordDefinition: RegExp): IWordRange[] {\n\t\tconst result: IWordRange[] = [];\n\t\tlet match: RegExpExecArray | null;\n\n\t\twordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range: IRange): string {\n\t\trange = this._validateRange(range);\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tconst lineEnding = this._eol;\n\t\tconst startLineIndex = range.startLineNumber - 1;\n\t\tconst endLineIndex = range.endLineNumber - 1;\n\t\tconst resultLines: string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (let i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n\n\tpublic offsetAt(position: IPosition): number {\n\t\tposition = this._validatePosition(position);\n\t\tthis._ensureLineStarts();\n\t\treturn this._lineStarts!.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n\t}\n\n\tpublic positionAt(offset: number): IPosition {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tthis._ensureLineStarts();\n\t\tconst out = this._lineStarts!.getIndexOf(offset);\n\t\tconst lineLength = this._lines[out.index].length;\n\n\t\t// Ensure we return a valid position\n\t\treturn {\n\t\t\tlineNumber: 1 + out.index,\n\t\t\tcolumn: 1 + Math.min(out.remainder, lineLength)\n\t\t};\n\t}\n\n\tprivate _validateRange(range: IRange): IRange {\n\n\t\tconst start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n\t\tconst end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n\n\t\tif (start.lineNumber !== range.startLineNumber\n\t\t\t|| start.column !== range.startColumn\n\t\t\t|| end.lineNumber !== range.endLineNumber\n\t\t\t|| end.column !== range.endColumn) {\n\n\t\t\treturn {\n\t\t\t\tstartLineNumber: start.lineNumber,\n\t\t\t\tstartColumn: start.column,\n\t\t\t\tendLineNumber: end.lineNumber,\n\t\t\t\tendColumn: end.column\n\t\t\t};\n\t\t}\n\n\t\treturn range;\n\t}\n\n\tprivate _validatePosition(position: IPosition): IPosition {\n\t\tif (!Position.isIPosition(position)) {\n\t\t\tthrow new Error('bad position');\n\t\t}\n\t\tlet { lineNumber, column } = position;\n\t\tlet hasChanged = false;\n\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tcolumn = 1;\n\t\t\thasChanged = true;\n\n\t\t} else if (lineNumber > this._lines.length) {\n\t\t\tlineNumber = this._lines.length;\n\t\t\tcolumn = this._lines[lineNumber - 1].length + 1;\n\t\t\thasChanged = true;\n\n\t\t} else {\n\t\t\tconst maxCharacter = this._lines[lineNumber - 1].length + 1;\n\t\t\tif (column < 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t\telse if (column > maxCharacter) {\n\t\t\t\tcolumn = maxCharacter;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!hasChanged) {\n\t\t\treturn position;\n\t\t} else {\n\t\t\treturn { lineNumber, column };\n\t\t}\n\t}\n}\n\nexport interface ICommonModel extends ILinkComputerTarget, IDocumentColorComputerTarget, IMirrorModel {\n\turi: URI;\n\tversion: number;\n\teol: string;\n\tgetValue(): string;\n\n\tgetLinesContent(): string[];\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[];\n\twords(wordDefinition: RegExp): Iterable<string>;\n\tgetWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition;\n\tgetValueInRange(range: IRange): string;\n\tgetWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null;\n\toffsetAt(position: IPosition): number;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IntervalTimer } from '../../../../base/common/async.js';\nimport { Disposable, DisposableStore, dispose, IDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IWebWorkerClient, IWebWorkerServer } from '../../../../base/common/worker/webWorker.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { IRange, Range } from '../../core/range.js';\nimport { ensureValidWordDefinition, getWordAtText, IWordAtPosition } from '../../core/wordHelper.js';\nimport { IDocumentColorComputerTarget } from '../../languages/defaultDocumentColorsComputer.js';\nimport { ILinkComputerTarget } from '../../languages/linkComputer.js';\nimport { MirrorTextModel as BaseMirrorModel, IModelChangedEvent } from '../../model/mirrorTextModel.js';\nimport { IMirrorModel, IWordRange } from '../editorWebWorker.js';\nimport { IModelService } from '../model.js';\nimport { IRawModelData, IWorkerTextModelSyncChannelServer } from './textModelSync.protocol.js';\n\n/**\n * Stop syncing a model to the worker if it was not needed for 1 min.\n */\nexport const STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;\n\nexport const WORKER_TEXT_MODEL_SYNC_CHANNEL = 'workerTextModelSync';\n\nexport class WorkerTextModelSyncClient extends Disposable {\n\n\tpublic static create(workerClient: IWebWorkerClient<any>, modelService: IModelService): WorkerTextModelSyncClient {\n\t\treturn new WorkerTextModelSyncClient(\n\t\t\tworkerClient.getChannel<IWorkerTextModelSyncChannelServer>(WORKER_TEXT_MODEL_SYNC_CHANNEL),\n\t\t\tmodelService\n\t\t);\n\t}\n\n\tprivate readonly _proxy: IWorkerTextModelSyncChannelServer;\n\tprivate readonly _modelService: IModelService;\n\tprivate _syncedModels: { [modelUrl: string]: IDisposable } = Object.create(null);\n\tprivate _syncedModelsLastUsedTime: { [modelUrl: string]: number } = Object.create(null);\n\n\tconstructor(proxy: IWorkerTextModelSyncChannelServer, modelService: IModelService, keepIdleModels: boolean = false) {\n\t\tsuper();\n\t\tthis._proxy = proxy;\n\t\tthis._modelService = modelService;\n\n\t\tif (!keepIdleModels) {\n\t\t\tconst timer = new IntervalTimer();\n\t\t\ttimer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));\n\t\t\tthis._register(timer);\n\t\t}\n\t}\n\n\tpublic override dispose(): void {\n\t\tfor (const modelUrl in this._syncedModels) {\n\t\t\tdispose(this._syncedModels[modelUrl]);\n\t\t}\n\t\tthis._syncedModels = Object.create(null);\n\t\tthis._syncedModelsLastUsedTime = Object.create(null);\n\t\tsuper.dispose();\n\t}\n\n\tpublic ensureSyncedResources(resources: URI[], forceLargeModels: boolean = false): void {\n\t\tfor (const resource of resources) {\n\t\t\tconst resourceStr = resource.toString();\n\n\t\t\tif (!this._syncedModels[resourceStr]) {\n\t\t\t\tthis._beginModelSync(resource, forceLargeModels);\n\t\t\t}\n\t\t\tif (this._syncedModels[resourceStr]) {\n\t\t\t\tthis._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _checkStopModelSync(): void {\n\t\tconst currentTime = (new Date()).getTime();\n\n\t\tconst toRemove: string[] = [];\n\t\tfor (const modelUrl in this._syncedModelsLastUsedTime) {\n\t\t\tconst elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];\n\t\t\tif (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {\n\t\t\t\ttoRemove.push(modelUrl);\n\t\t\t}\n\t\t}\n\n\t\tfor (const e of toRemove) {\n\t\t\tthis._stopModelSync(e);\n\t\t}\n\t}\n\n\tprivate _beginModelSync(resource: URI, forceLargeModels: boolean): void {\n\t\tconst model = this._modelService.getModel(resource);\n\t\tif (!model) {\n\t\t\treturn;\n\t\t}\n\t\tif (!forceLargeModels && model.isTooLargeForSyncing()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelUrl = resource.toString();\n\n\t\tthis._proxy.$acceptNewModel({\n\t\t\turl: model.uri.toString(),\n\t\t\tlines: model.getLinesContent(),\n\t\t\tEOL: model.getEOL(),\n\t\t\tversionId: model.getVersionId()\n\t\t});\n\n\t\tconst toDispose = new DisposableStore();\n\t\ttoDispose.add(model.onDidChangeContent((e) => {\n\t\t\tthis._proxy.$acceptModelChanged(modelUrl.toString(), e);\n\t\t}));\n\t\ttoDispose.add(model.onWillDispose(() => {\n\t\t\tthis._stopModelSync(modelUrl);\n\t\t}));\n\t\ttoDispose.add(toDisposable(() => {\n\t\t\tthis._proxy.$acceptRemovedModel(modelUrl);\n\t\t}));\n\n\t\tthis._syncedModels[modelUrl] = toDispose;\n\t}\n\n\tprivate _stopModelSync(modelUrl: string): void {\n\t\tconst toDispose = this._syncedModels[modelUrl];\n\t\tdelete this._syncedModels[modelUrl];\n\t\tdelete this._syncedModelsLastUsedTime[modelUrl];\n\t\tdispose(toDispose);\n\t}\n}\n\nexport class WorkerTextModelSyncServer implements IWorkerTextModelSyncChannelServer {\n\n\tprivate readonly _models: { [uri: string]: MirrorModel };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\n\tpublic bindToServer(workerServer: IWebWorkerServer): void {\n\t\tworkerServer.setChannel(WORKER_TEXT_MODEL_SYNC_CHANNEL, this);\n\t}\n\n\tpublic getModel(uri: string): ICommonModel | undefined {\n\t\treturn this._models[uri];\n\t}\n\n\tpublic getModels(): ICommonModel[] {\n\t\tconst all: MirrorModel[] = [];\n\t\tObject.keys(this._models).forEach((key) => all.push(this._models[key]));\n\t\treturn all;\n\t}\n\n\t$acceptNewModel(data: IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n\t}\n\n\t$acceptModelChanged(uri: string, e: IModelChangedEvent): void {\n\t\tif (!this._models[uri]) {\n\t\t\treturn;\n\t\t}\n\t\tconst model = this._models[uri];\n\t\tmodel.onEvents(e);\n\t}\n\n\t$acceptRemovedModel(uri: string): void {\n\t\tif (!this._models[uri]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[uri];\n\t}\n}\n\nexport class MirrorModel extends BaseMirrorModel implements ICommonModel {\n\n\tpublic get uri(): URI {\n\t\treturn this._uri;\n\t}\n\n\tpublic get eol(): string {\n\t\treturn this._eol;\n\t}\n\n\tpublic getValue(): string {\n\t\treturn this.getText();\n\t}\n\n\tpublic findMatches(regex: RegExp): RegExpMatchArray[] {\n\t\tconst matches = [];\n\t\tfor (let i = 0; i < this._lines.length; i++) {\n\t\t\tconst line = this._lines[i];\n\t\t\tconst offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n\t\t\tconst iteratorOverMatches = line.matchAll(regex);\n\t\t\tfor (const match of iteratorOverMatches) {\n\t\t\t\tif (match.index || match.index === 0) {\n\t\t\t\t\tmatch.index = match.index + offsetToAdd;\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null {\n\n\t\tconst wordAtText = getWordAtText(\n\t\t\tposition.column,\n\t\t\tensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\n\tpublic words(wordDefinition: RegExp): Iterable<string> {\n\n\t\tconst lines = this._lines;\n\t\tconst wordenize = this._wordenize.bind(this);\n\n\t\tlet lineNumber = 0;\n\t\tlet lineText = '';\n\t\tlet wordRangesIdx = 0;\n\t\tlet wordRanges: IWordRange[] = [];\n\n\t\treturn {\n\t\t\t*[Symbol.iterator]() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (wordRangesIdx < wordRanges.length) {\n\t\t\t\t\t\tconst value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n\t\t\t\t\t\twordRangesIdx += 1;\n\t\t\t\t\t\tyield value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (lineNumber < lines.length) {\n\t\t\t\t\t\t\tlineText = lines[lineNumber];\n\t\t\t\t\t\t\twordRanges = wordenize(lineText, wordDefinition);\n\t\t\t\t\t\t\twordRangesIdx = 0;\n\t\t\t\t\t\t\tlineNumber += 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic getLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[] {\n\t\tconst content = this._lines[lineNumber - 1];\n\t\tconst ranges = this._wordenize(content, wordDefinition);\n\t\tconst words: IWordAtPosition[] = [];\n\t\tfor (const range of ranges) {\n\t\t\twords.push({\n\t\t\t\tword: content.substring(range.start, range.end),\n\t\t\t\tstartColumn: range.start + 1,\n\t\t\t\tendColumn: range.end + 1\n\t\t\t});\n\t\t}\n\t\treturn words;\n\t}\n\n\tprivate _wordenize(content: string, wordDefinition: RegExp): IWordRange[] {\n\t\tconst result: IWordRange[] = [];\n\t\tlet match: RegExpExecArray | null;\n\n\t\twordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range: IRange): string {\n\t\trange = this._validateRange(range);\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tconst lineEnding = this._eol;\n\t\tconst startLineIndex = range.startLineNumber - 1;\n\t\tconst endLineIndex = range.endLineNumber - 1;\n\t\tconst resultLines: string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (let i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n\n\tpublic offsetAt(position: IPosition): number {\n\t\tposition = this._validatePosition(position);\n\t\tthis._ensureLineStarts();\n\t\treturn this._lineStarts!.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n\t}\n\n\tpublic positionAt(offset: number): IPosition {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tthis._ensureLineStarts();\n\t\tconst out = this._lineStarts!.getIndexOf(offset);\n\t\tconst lineLength = this._lines[out.index].length;\n\n\t\t// Ensure we return a valid position\n\t\treturn {\n\t\t\tlineNumber: 1 + out.index,\n\t\t\tcolumn: 1 + Math.min(out.remainder, lineLength)\n\t\t};\n\t}\n\n\tprivate _validateRange(range: IRange): IRange {\n\n\t\tconst start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n\t\tconst end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n\n\t\tif (start.lineNumber !== range.startLineNumber\n\t\t\t|| start.column !== range.startColumn\n\t\t\t|| end.lineNumber !== range.endLineNumber\n\t\t\t|| end.column !== range.endColumn) {\n\n\t\t\treturn {\n\t\t\t\tstartLineNumber: start.lineNumber,\n\t\t\t\tstartColumn: start.column,\n\t\t\t\tendLineNumber: end.lineNumber,\n\t\t\t\tendColumn: end.column\n\t\t\t};\n\t\t}\n\n\t\treturn range;\n\t}\n\n\tprivate _validatePosition(position: IPosition): IPosition {\n\t\tif (!Position.isIPosition(position)) {\n\t\t\tthrow new Error('bad position');\n\t\t}\n\t\tlet { lineNumber, column } = position;\n\t\tlet hasChanged = false;\n\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tcolumn = 1;\n\t\t\thasChanged = true;\n\n\t\t} else if (lineNumber > this._lines.length) {\n\t\t\tlineNumber = this._lines.length;\n\t\t\tcolumn = this._lines[lineNumber - 1].length + 1;\n\t\t\thasChanged = true;\n\n\t\t} else {\n\t\t\tconst maxCharacter = this._lines[lineNumber - 1].length + 1;\n\t\t\tif (column < 1) {\n\t\t\t\tcolumn = 1;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t\telse if (column > maxCharacter) {\n\t\t\t\tcolumn = maxCharacter;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!hasChanged) {\n\t\t\treturn position;\n\t\t} else {\n\t\t\treturn { lineNumber, column };\n\t\t}\n\t}\n}\n\nexport interface ICommonModel extends ILinkComputerTarget, IDocumentColorComputerTarget, IMirrorModel {\n\turi: URI;\n\tversion: number;\n\teol: string;\n\tgetValue(): string;\n\n\tgetLinesContent(): string[];\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber: number): string;\n\tgetLineWords(lineNumber: number, wordDefinition: RegExp): IWordAtPosition[];\n\twords(wordDefinition: RegExp): Iterable<string>;\n\tgetWordUntilPosition(position: IPosition, wordDefinition: RegExp): IWordAtPosition;\n\tgetValueInRange(range: IRange): string;\n\tgetWordAtPosition(position: IPosition, wordDefinition: RegExp): Range | null;\n\toffsetAt(position: IPosition): number;\n\tpositionAt(offset: number): IPosition;\n\tfindMatches(regex: RegExp): RegExpMatchArray[];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sumBy } from '../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class BaseEdit<T extends BaseReplacement<T> = BaseReplacement<any>, TEdit extends BaseEdit<T, TEdit> = BaseEdit<T, any>> {\n\tconstructor(\n\t\tpublic readonly replacements: readonly T[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const replacement of replacements) {\n\t\t\tif (!(replacement.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = replacement.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tprotected abstract _createNew(replacements: readonly T[]): TEdit;\n\n\t/**\n\t * Returns true if and only if this edit and the given edit are structurally equal.\n\t * Note that this does not mean that the edits have the same effect on a given input!\n\t * See `.normalize()` or `.normalizeOnBase(base)` for that.\n\t*/\n\tpublic equals(other: TEdit): boolean {\n\t\tif (this.replacements.length !== other.replacements.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tif (!this.replacements[i].equals(other.replacements[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic toString() {\n\t\tconst edits = this.replacements.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\t/**\n\t * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).\n\t * Two edits have an equal normalized edit if and only if they have the same effect on any input.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())\n\t * ```\n\t * and\n\t * ```\n\t * forall base: TEdit.apply(base).equals(this.normalize().apply(base))\n\t * ```\n\t *\n\t */\n\tpublic normalize(): TEdit {\n\t\tconst newReplacements: T[] = [];\n\t\tlet lastReplacement: T | undefined;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.getNewLength() === 0 && r.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {\n\t\t\t\tconst joined = lastReplacement.tryJoinTouching(r);\n\t\t\t\tif (joined) {\n\t\t\t\t\tlastReplacement = joined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lastReplacement) {\n\t\t\t\tnewReplacements.push(lastReplacement);\n\t\t\t}\n\t\t\tlastReplacement = r;\n\t\t}\n\n\t\tif (lastReplacement) {\n\t\t\tnewReplacements.push(lastReplacement);\n\t\t}\n\t\treturn this._createNew(newReplacements);\n\t}\n\n\t/**\n\t * Combines two edits into one with the same effect.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * other.apply(this.apply(s0)) = this.compose(other).apply(s0)\n\t * ```\n\t */\n\tpublic compose(other: TEdit): TEdit {\n\t\tconst edits1 = this.normalize();\n\t\tconst edits2 = other.normalize();\n\n\t\tif (edits1.isEmpty()) { return edits2; }\n\t\tif (edits2.isEmpty()) { return edits1; }\n\n\t\tconst edit1Queue = [...edits1.replacements];\n\t\tconst result: T[] = [];\n\n\t\tlet edit1ToEdit2 = 0;\n\n\t\tfor (const r2 of edits2.replacements) {\n\t\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0]!;\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tresult.push(r1);\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\t\tlet firstIntersecting: T | undefined; // or touching\n\t\t\tlet lastIntersecting: T | undefined; // or touching\n\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0];\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\t\tif (!firstIntersecting) {\n\t\t\t\t\tfirstIntersecting = r1;\n\t\t\t\t}\n\t\t\t\tlastIntersecting = r1;\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tresult.push(r2.delta(-edit1ToEdit2));\n\t\t\t} else {\n\t\t\t\tconst newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);\n\n\t\t\t\tconst prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\t\tif (prefixLength > 0) {\n\t\t\t\t\tconst prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));\n\t\t\t\t\tresult.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (!lastIntersecting) {\n\t\t\t\t\tthrow new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);\n\t\t\t\t}\n\t\t\t\tconst suffixLength = (lastIntersecting.replaceRange.endExclusive + edit1ToEdit2) - r2.replaceRange.endExclusive;\n\t\t\t\tif (suffixLength > 0) {\n\t\t\t\t\tconst e = lastIntersecting.slice(\n\t\t\t\t\t\tOffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0),\n\t\t\t\t\t\tnew OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength())\n\t\t\t\t\t);\n\t\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\t\tedit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;\n\t\t\t\t}\n\n\t\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\t\tnewReplaceRangeStart,\n\t\t\t\t\tr2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t\t);\n\t\t\t\tconst middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));\n\t\t\t\tresult.push(middle);\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst item = edit1Queue.shift();\n\t\t\tif (!item) { break; }\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn this._createNew(result).normalize();\n\t}\n\n\tpublic decomposeSplit(shouldBeInE1: (repl: T) => boolean): { e1: TEdit; e2: TEdit } {\n\t\tconst e1: T[] = [];\n\t\tconst e2: T[] = [];\n\n\t\tlet e2delta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tif (shouldBeInE1(edit)) {\n\t\t\t\te1.push(edit);\n\t\t\t\te2delta += edit.getNewLength() - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\te2.push(edit.slice(edit.replaceRange.delta(e2delta), new OffsetRange(0, edit.getNewLength())));\n\t\t\t}\n\t\t}\n\t\treturn { e1: this._createNew(e1), e2: this._createNew(e2) };\n\t}\n\n\t/**\n\t * Returns the range of each replacement in the applied value.\n\t*/\n\tpublic getNewRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));\n\t\t\toffset += e.getLengthDelta();\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic getJoinedReplaceRange(): OffsetRange | undefined {\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.replacements[0].replaceRange.join(this.replacements.at(-1)!.replaceRange);\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn sumBy(this.replacements, (replacement) => replacement.getLengthDelta());\n\t}\n\n\tpublic getNewDataLength(dataLength: number): number {\n\t\treturn dataLength + this.getLengthDelta();\n\t}\n\n\tpublic applyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < r.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn r.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += r.getNewLength() - r.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tpublic applyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive)\n\t\t);\n\t}\n\n\tpublic applyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tconst editLength = edit.getNewLength();\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n\n\t/**\n\t * Return undefined if the originalOffset is within an edit\n\t */\n\tpublic applyToOffsetOrUndefined(originalOffset: number): number | undefined {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += edit.getNewLength() - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\t/**\n\t * Return undefined if the originalRange is within an edit\n\t */\n\tpublic applyToOffsetRangeOrUndefined(originalRange: OffsetRange): OffsetRange | undefined {\n\t\tconst start = this.applyToOffsetOrUndefined(originalRange.start);\n\t\tif (start === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst end = this.applyToOffsetOrUndefined(originalRange.endExclusive);\n\t\tif (end === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nexport abstract class BaseReplacement<TSelf extends BaseReplacement<TSelf>> {\n\tconstructor(\n\t\t/**\n\t\t * The range to be replaced.\n\t\t*/\n\t\tpublic readonly replaceRange: OffsetRange,\n\t) { }\n\n\tpublic abstract getNewLength(): number;\n\n\t/**\n\t * Precondition: TEdit.range.endExclusive === other.range.start\n\t*/\n\tpublic abstract tryJoinTouching(other: TSelf): TSelf | undefined;\n\n\tpublic abstract slice(newReplaceRange: OffsetRange, rangeInReplacement?: OffsetRange): TSelf;\n\n\tpublic delta(offset: number): TSelf {\n\t\treturn this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn this.getNewLength() - this.replaceRange.length;\n\t}\n\n\tabstract equals(other: TSelf): boolean;\n\n\ttoString(): string {\n\t\treturn `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.getNewLength() === 0 && this.replaceRange.length === 0;\n\t}\n\n\tgetRangeAfterReplace(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());\n\t}\n}\n\nexport type AnyEdit = BaseEdit<AnyReplacement, AnyEdit>;\nexport type AnyReplacement = BaseReplacement<AnyReplacement>;\n\nexport class Edit<T extends BaseReplacement<T>> extends BaseEdit<T, Edit<T>> {\n\t/**\n\t * Represents a set of edits to a string.\n\t * All these edits are applied at once.\n\t*/\n\tpublic static readonly empty = new Edit<never>([]);\n\n\tpublic static create<T extends BaseReplacement<T>>(replacements: readonly T[]): Edit<T> {\n\t\treturn new Edit(replacements);\n\t}\n\n\tpublic static single<T extends BaseReplacement<T>>(replacement: T): Edit<T> {\n\t\treturn new Edit([replacement]);\n\t}\n\n\tprotected override _createNew(replacements: readonly T[]): Edit<T> {\n\t\treturn new Edit(replacements);\n\t}\n}\n\nexport class AnnotationReplacement<TAnnotation> extends BaseReplacement<AnnotationReplacement<TAnnotation>> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newLength: number,\n\t\tpublic readonly annotation: TAnnotation,\n\t) {\n\t\tsuper(range);\n\t}\n\n\toverride equals(other: AnnotationReplacement<TAnnotation>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newLength === other.newLength && this.annotation === other.annotation;\n\t}\n\n\tgetNewLength(): number { return this.newLength; }\n\n\ttryJoinTouching(other: AnnotationReplacement<TAnnotation>): AnnotationReplacement<TAnnotation> | undefined {\n\t\tif (this.annotation !== other.annotation) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotationReplacement<TAnnotation>(this.replaceRange.joinRightTouching(other.replaceRange), this.newLength + other.newLength, this.annotation);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotationReplacement<TAnnotation> {\n\t\treturn new AnnotationReplacement<TAnnotation>(range, rangeInReplacement ? rangeInReplacement.length : this.newLength, this.annotation);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { sumBy } from '../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class BaseEdit<T extends BaseReplacement<T> = BaseReplacement<any>, TEdit extends BaseEdit<T, TEdit> = BaseEdit<T, any>> {\n\tconstructor(\n\t\tpublic readonly replacements: readonly T[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const replacement of replacements) {\n\t\t\tif (!(replacement.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = replacement.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tprotected abstract _createNew(replacements: readonly T[]): TEdit;\n\n\t/**\n\t * Returns true if and only if this edit and the given edit are structurally equal.\n\t * Note that this does not mean that the edits have the same effect on a given input!\n\t * See `.normalize()` or `.normalizeOnBase(base)` for that.\n\t*/\n\tpublic equals(other: TEdit): boolean {\n\t\tif (this.replacements.length !== other.replacements.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tif (!this.replacements[i].equals(other.replacements[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic toString() {\n\t\tconst edits = this.replacements.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\t/**\n\t * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).\n\t * Two edits have an equal normalized edit if and only if they have the same effect on any input.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())\n\t * ```\n\t * and\n\t * ```\n\t * forall base: TEdit.apply(base).equals(this.normalize().apply(base))\n\t * ```\n\t *\n\t */\n\tpublic normalize(): TEdit {\n\t\tconst newReplacements: T[] = [];\n\t\tlet lastReplacement: T | undefined;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.getNewLength() === 0 && r.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {\n\t\t\t\tconst joined = lastReplacement.tryJoinTouching(r);\n\t\t\t\tif (joined) {\n\t\t\t\t\tlastReplacement = joined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lastReplacement) {\n\t\t\t\tnewReplacements.push(lastReplacement);\n\t\t\t}\n\t\t\tlastReplacement = r;\n\t\t}\n\n\t\tif (lastReplacement) {\n\t\t\tnewReplacements.push(lastReplacement);\n\t\t}\n\t\treturn this._createNew(newReplacements);\n\t}\n\n\t/**\n\t * Combines two edits into one with the same effect.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * other.apply(this.apply(s0)) = this.compose(other).apply(s0)\n\t * ```\n\t */\n\tpublic compose(other: TEdit): TEdit {\n\t\tconst edits1 = this.normalize();\n\t\tconst edits2 = other.normalize();\n\n\t\tif (edits1.isEmpty()) { return edits2; }\n\t\tif (edits2.isEmpty()) { return edits1; }\n\n\t\tconst edit1Queue = [...edits1.replacements];\n\t\tconst result: T[] = [];\n\n\t\tlet edit1ToEdit2 = 0;\n\n\t\tfor (const r2 of edits2.replacements) {\n\t\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0]!;\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tresult.push(r1);\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\t\tlet firstIntersecting: T | undefined; // or touching\n\t\t\tlet lastIntersecting: T | undefined; // or touching\n\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0];\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\t\tif (!firstIntersecting) {\n\t\t\t\t\tfirstIntersecting = r1;\n\t\t\t\t}\n\t\t\t\tlastIntersecting = r1;\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tresult.push(r2.delta(-edit1ToEdit2));\n\t\t\t} else {\n\t\t\t\tconst newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);\n\n\t\t\t\tconst prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\t\tif (prefixLength > 0) {\n\t\t\t\t\tconst prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));\n\t\t\t\t\tresult.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (!lastIntersecting) {\n\t\t\t\t\tthrow new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);\n\t\t\t\t}\n\t\t\t\tconst suffixLength = (lastIntersecting.replaceRange.endExclusive + edit1ToEdit2) - r2.replaceRange.endExclusive;\n\t\t\t\tif (suffixLength > 0) {\n\t\t\t\t\tconst e = lastIntersecting.slice(\n\t\t\t\t\t\tOffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0),\n\t\t\t\t\t\tnew OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength())\n\t\t\t\t\t);\n\t\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\t\tedit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;\n\t\t\t\t}\n\n\t\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\t\tnewReplaceRangeStart,\n\t\t\t\t\tr2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t\t);\n\t\t\t\tconst middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));\n\t\t\t\tresult.push(middle);\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst item = edit1Queue.shift();\n\t\t\tif (!item) { break; }\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn this._createNew(result).normalize();\n\t}\n\n\tpublic decomposeSplit(shouldBeInE1: (repl: T) => boolean): { e1: TEdit; e2: TEdit } {\n\t\tconst e1: T[] = [];\n\t\tconst e2: T[] = [];\n\n\t\tlet e2delta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tif (shouldBeInE1(edit)) {\n\t\t\t\te1.push(edit);\n\t\t\t\te2delta += edit.getNewLength() - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\te2.push(edit.slice(edit.replaceRange.delta(e2delta), new OffsetRange(0, edit.getNewLength())));\n\t\t\t}\n\t\t}\n\t\treturn { e1: this._createNew(e1), e2: this._createNew(e2) };\n\t}\n\n\t/**\n\t * Returns the range of each replacement in the applied value.\n\t*/\n\tpublic getNewRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));\n\t\t\toffset += e.getLengthDelta();\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic getJoinedReplaceRange(): OffsetRange | undefined {\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.replacements[0].replaceRange.join(this.replacements.at(-1)!.replaceRange);\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn sumBy(this.replacements, (replacement) => replacement.getLengthDelta());\n\t}\n\n\tpublic getNewDataLength(dataLength: number): number {\n\t\treturn dataLength + this.getLengthDelta();\n\t}\n\n\tpublic applyToOffset(originalOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < r.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn r.replaceRange.start + accumulatedDelta;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += r.getNewLength() - r.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\tpublic applyToOffsetRange(originalRange: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.applyToOffset(originalRange.start),\n\t\t\tthis.applyToOffset(originalRange.endExclusive)\n\t\t);\n\t}\n\n\tpublic applyInverseToOffset(postEditsOffset: number): number {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tconst editLength = edit.getNewLength();\n\t\t\tif (edit.replaceRange.start <= postEditsOffset - accumulatedDelta) {\n\t\t\t\tif (postEditsOffset - accumulatedDelta < edit.replaceRange.start + editLength) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn edit.replaceRange.start;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += editLength - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn postEditsOffset - accumulatedDelta;\n\t}\n\n\t/**\n\t * Return undefined if the originalOffset is within an edit\n\t */\n\tpublic applyToOffsetOrUndefined(originalOffset: number): number | undefined {\n\t\tlet accumulatedDelta = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tif (edit.replaceRange.start <= originalOffset) {\n\t\t\t\tif (originalOffset < edit.replaceRange.endExclusive) {\n\t\t\t\t\t// the offset is in the replaced range\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\taccumulatedDelta += edit.getNewLength() - edit.replaceRange.length;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn originalOffset + accumulatedDelta;\n\t}\n\n\t/**\n\t * Return undefined if the originalRange is within an edit\n\t */\n\tpublic applyToOffsetRangeOrUndefined(originalRange: OffsetRange): OffsetRange | undefined {\n\t\tconst start = this.applyToOffsetOrUndefined(originalRange.start);\n\t\tif (start === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst end = this.applyToOffsetOrUndefined(originalRange.endExclusive);\n\t\tif (end === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nexport abstract class BaseReplacement<TSelf extends BaseReplacement<TSelf>> {\n\tconstructor(\n\t\t/**\n\t\t * The range to be replaced.\n\t\t*/\n\t\tpublic readonly replaceRange: OffsetRange,\n\t) { }\n\n\tpublic abstract getNewLength(): number;\n\n\t/**\n\t * Precondition: TEdit.range.endExclusive === other.range.start\n\t*/\n\tpublic abstract tryJoinTouching(other: TSelf): TSelf | undefined;\n\n\tpublic abstract slice(newReplaceRange: OffsetRange, rangeInReplacement?: OffsetRange): TSelf;\n\n\tpublic delta(offset: number): TSelf {\n\t\treturn this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn this.getNewLength() - this.replaceRange.length;\n\t}\n\n\tabstract equals(other: TSelf): boolean;\n\n\ttoString(): string {\n\t\treturn `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.getNewLength() === 0 && this.replaceRange.length === 0;\n\t}\n\n\tgetRangeAfterReplace(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());\n\t}\n}\n\nexport type AnyEdit = BaseEdit<AnyReplacement, AnyEdit>;\nexport type AnyReplacement = BaseReplacement<AnyReplacement>;\n\nexport class Edit<T extends BaseReplacement<T>> extends BaseEdit<T, Edit<T>> {\n\t/**\n\t * Represents a set of edits to a string.\n\t * All these edits are applied at once.\n\t*/\n\tpublic static readonly empty = new Edit<never>([]);\n\n\tpublic static create<T extends BaseReplacement<T>>(replacements: readonly T[]): Edit<T> {\n\t\treturn new Edit(replacements);\n\t}\n\n\tpublic static single<T extends BaseReplacement<T>>(replacement: T): Edit<T> {\n\t\treturn new Edit([replacement]);\n\t}\n\n\tprotected override _createNew(replacements: readonly T[]): Edit<T> {\n\t\treturn new Edit(replacements);\n\t}\n}\n\nexport class AnnotationReplacement<TAnnotation> extends BaseReplacement<AnnotationReplacement<TAnnotation>> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newLength: number,\n\t\tpublic readonly annotation: TAnnotation,\n\t) {\n\t\tsuper(range);\n\t}\n\n\toverride equals(other: AnnotationReplacement<TAnnotation>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newLength === other.newLength && this.annotation === other.annotation;\n\t}\n\n\tgetNewLength(): number { return this.newLength; }\n\n\ttryJoinTouching(other: AnnotationReplacement<TAnnotation>): AnnotationReplacement<TAnnotation> | undefined {\n\t\tif (this.annotation !== other.annotation) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotationReplacement<TAnnotation>(this.replaceRange.joinRightTouching(other.replaceRange), this.newLength + other.newLength, this.annotation);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotationReplacement<TAnnotation> {\n\t\treturn new AnnotationReplacement<TAnnotation>(range, rangeInReplacement ? rangeInReplacement.length : this.newLength, this.annotation);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { StringText } from '../text/abstractText.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\tget TReplacement(): T {\n\t\tthrow new Error('TReplacement is not defined for BaseStringEdit');\n\t}\n\n\tpublic static composeOrUndefined<T extends BaseStringEdit>(edits: readonly T[]): T | undefined {\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]) as any;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * r := trySwap(e1, e2);\n\t * e1.compose(e2) === r.e1.compose(r.e2)\n\t*/\n\tpublic static trySwap(e1: BaseStringEdit, e2: BaseStringEdit): { e1: StringEdit; e2: StringEdit } | undefined {\n\t\t// TODO make this more efficient\n\t\tconst e1Inv = e1.inverseOnSlice((start, endEx) => ' '.repeat(endEx - start));\n\n\t\tconst e1_ = e2.tryRebase(e1Inv);\n\t\tif (!e1_) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst e2_ = e1.tryRebase(e1_);\n\t\tif (!e2_) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { e1: e1_, e2: e2_ };\n\t}\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverseOnSlice(getOriginalSlice: (start: number, endEx: number) => string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tedits.push(StringReplacement.replace(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\tgetOriginalSlice(e.replaceRange.start, e.replaceRange.endExclusive)\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverse(original: string): StringEdit {\n\t\treturn this.inverseOnSlice((start, endEx) => original.substring(start, endEx));\n\t}\n\n\tpublic rebaseSkipConflicting(base: StringEdit): StringEdit {\n\t\treturn this._tryRebase(base, false)!;\n\t}\n\n\tpublic tryRebase(base: StringEdit): StringEdit | undefined {\n\t\treturn this._tryRebase(base, true);\n\t}\n\n\tprivate _tryRebase(base: StringEdit, noOverlap: boolean): StringEdit | undefined {\n\t\tconst newEdits: StringReplacement[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.replacements.length || baseIdx < base.replacements.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.replacements[baseIdx];\n\t\t\tconst ourEdit = this.replacements[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new StringEdit(newEdits);\n\t}\n\n\tpublic toJson(): ISerializedStringEdit {\n\t\treturn this.replacements.map(e => e.toJson());\n\t}\n\n\tpublic isNeutralOn(text: string): boolean {\n\t\treturn this.replacements.every(e => e.isNeutralOn(text));\n\t}\n\n\tpublic removeCommonSuffixPrefix(originalText: string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const e of this.replacements) {\n\t\t\tconst edit = e.removeCommonSuffixPrefix(originalText);\n\t\t\tif (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic normalizeEOL(eol: '\\r\\n' | '\\n'): StringEdit {\n\t\treturn new StringEdit(this.replacements.map(edit => edit.normalizeEOL(eol)));\n\t}\n\n\t/**\n\t * If `e1.apply(source) === e2.apply(source)`, then `e1.normalizeOnSource(source).equals(e2.normalizeOnSource(source))`.\n\t*/\n\tpublic normalizeOnSource(source: string): StringEdit {\n\t\tconst result = this.apply(source);\n\n\t\tconst edit = StringReplacement.replace(OffsetRange.ofLength(source.length), result);\n\t\tconst e = edit.removeCommonSuffixAndPrefix(source);\n\t\tif (e.isEmpty) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\treturn e.toEdit();\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): TEdit {\n\t\treturn this._createNew(this.replacements.map(e => e.removeCommonSuffixAndPrefix(source))).normalize();\n\t}\n\n\tpublic applyOnText(docContents: StringText): StringText {\n\t\treturn new StringText(this.apply(docContents.value));\n\t}\n\n\tpublic mapData<TData extends IEditData<TData>>(f: (replacement: T) => TData): AnnotatedStringEdit<TData> {\n\t\treturn new AnnotatedStringEdit(\n\t\t\tthis.replacements.map(e => new AnnotatedStringReplacement(\n\t\t\t\te.replaceRange,\n\t\t\t\te.newText,\n\t\t\t\tf(e)\n\t\t\t))\n\t\t);\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\t/**\n\t * Checks if the edit would produce no changes when applied to the given text.\n\t */\n\tisNeutralOn(text: string): boolean {\n\t\treturn this.newText === text.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n'): StringReplacement {\n\t\tconst newText = this.newText.replace(/\\r\\n|\\n/g, eol);\n\t\treturn new StringReplacement(this.replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toEdit(): StringEdit {\n\t\treturn new StringEdit([this]);\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static create(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n\n\tpublic static single(replacement: StringReplacement): StringEdit {\n\t\treturn new StringEdit([replacement]);\n\t}\n\n\tpublic static replace(range: OffsetRange, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, replacement)]);\n\t}\n\n\tpublic static insert(offset: number, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(OffsetRange.emptyAt(offset), replacement)]);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, '')]);\n\t}\n\n\tpublic static fromJson(data: ISerializedStringEdit): StringEdit {\n\t\treturn new StringEdit(data.map(StringReplacement.fromJson));\n\t}\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The replacements are applied in order!\n\t * Equals `StringEdit.compose(replacements.map(r => r.toEdit()))`, but is much more performant.\n\t*/\n\tpublic static composeSequentialReplacements(replacements: readonly StringReplacement[]): StringEdit {\n\t\tlet edit = StringEdit.empty;\n\t\tlet curEditReplacements: StringReplacement[] = []; // These are reverse sorted\n\n\t\tfor (const r of replacements) {\n\t\t\tconst last = curEditReplacements.at(-1);\n\t\t\tif (!last || r.replaceRange.isBefore(last.replaceRange)) {\n\t\t\t\t// Detect subsequences of reverse sorted replacements\n\t\t\t\tcurEditReplacements.push(r);\n\t\t\t} else {\n\t\t\t\t// Once the subsequence is broken, compose the current replacements and look for a new subsequence.\n\t\t\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\t\t\tcurEditReplacements = [r];\n\t\t\t}\n\t\t}\n\n\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\treturn edit;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport type ISerializedStringEdit = ISerializedStringReplacement[];\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, '');\n\t}\n\n\tpublic static fromJson(data: ISerializedStringReplacement): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n/**\n * Represents data associated to a single edit, which survives certain edit operations.\n*/\nexport interface IEditData<T> {\n\tjoin(other: T): T | undefined;\n}\n\nexport class VoidEditData implements IEditData<VoidEditData> {\n\tjoin(other: VoidEditData): VoidEditData | undefined {\n\t\treturn this;\n\t}\n}\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class AnnotatedStringEdit<T extends IEditData<T>> extends BaseStringEdit<AnnotatedStringReplacement<T>, AnnotatedStringEdit<T>> {\n\tpublic static readonly empty = new AnnotatedStringEdit<never>([]);\n\n\tpublic static create<T extends IEditData<T>>(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit(replacements);\n\t}\n\n\tpublic static single<T extends IEditData<T>>(replacement: AnnotatedStringReplacement<T>): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([replacement]);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, replacement, data)]);\n\t}\n\n\tpublic static insert<T extends IEditData<T>>(offset: number, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(OffsetRange.emptyAt(offset), replacement, data)]);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, '', data)]);\n\t}\n\n\tpublic static compose<T extends IEditData<T>>(edits: readonly AnnotatedStringEdit<T>[]): AnnotatedStringEdit<T> {\n\t\tif (edits.length === 0) {\n\t\t\treturn AnnotatedStringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly AnnotatedStringReplacement<T>[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit<T>(replacements);\n\t}\n\n\tpublic toStringEdit(filter?: (replacement: AnnotatedStringReplacement<T>) => boolean): StringEdit {\n\t\tconst newReplacements: StringReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (!filter || filter(r)) {\n\t\t\t\tnewReplacements.push(new StringReplacement(r.replaceRange, r.newText));\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(newReplacements);\n\t}\n}\n\nexport class AnnotatedStringReplacement<T extends IEditData<T>> extends BaseStringReplacement<AnnotatedStringReplacement<T>> {\n\tpublic static insert<T extends IEditData<T>>(offset: number, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(OffsetRange.emptyAt(offset), text, data);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, text, data);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, '', data);\n\t}\n\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t\tpublic readonly data: T\n\t) {\n\t\tsuper(range, newText);\n\t}\n\n\toverride equals(other: AnnotatedStringReplacement<T>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText && this.data === other.data;\n\t}\n\n\ttryJoinTouching(other: AnnotatedStringReplacement<T>): AnnotatedStringReplacement<T> | undefined {\n\t\tconst joined = this.data.join(other.data);\n\t\tif (joined === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotatedStringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText, joined);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText, this.data);\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { StringText } from '../text/abstractText.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\tget TReplacement(): T {\n\t\tthrow new Error('TReplacement is not defined for BaseStringEdit');\n\t}\n\n\tpublic static composeOrUndefined<T extends BaseStringEdit>(edits: readonly T[]): T | undefined {\n\t\tif (edits.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]) as any;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * r := trySwap(e1, e2);\n\t * e1.compose(e2) === r.e1.compose(r.e2)\n\t*/\n\tpublic static trySwap(e1: BaseStringEdit, e2: BaseStringEdit): { e1: StringEdit; e2: StringEdit } | undefined {\n\t\t// TODO make this more efficient\n\t\tconst e1Inv = e1.inverseOnSlice((start, endEx) => ' '.repeat(endEx - start));\n\n\t\tconst e1_ = e2.tryRebase(e1Inv);\n\t\tif (!e1_) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst e2_ = e1.tryRebase(e1_);\n\t\tif (!e2_) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn { e1: e1_, e2: e2_ };\n\t}\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverseOnSlice(getOriginalSlice: (start: number, endEx: number) => string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tedits.push(StringReplacement.replace(\n\t\t\t\tOffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.newText.length),\n\t\t\t\tgetOriginalSlice(e.replaceRange.start, e.replaceRange.endExclusive)\n\t\t\t));\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\t/**\n\t * Creates an edit that reverts this edit.\n\t */\n\tpublic inverse(original: string): StringEdit {\n\t\treturn this.inverseOnSlice((start, endEx) => original.substring(start, endEx));\n\t}\n\n\tpublic rebaseSkipConflicting(base: StringEdit): StringEdit {\n\t\treturn this._tryRebase(base, false)!;\n\t}\n\n\tpublic tryRebase(base: StringEdit): StringEdit | undefined {\n\t\treturn this._tryRebase(base, true);\n\t}\n\n\tprivate _tryRebase(base: StringEdit, noOverlap: boolean): StringEdit | undefined {\n\t\tconst newEdits: StringReplacement[] = [];\n\n\t\tlet baseIdx = 0;\n\t\tlet ourIdx = 0;\n\t\tlet offset = 0;\n\n\t\twhile (ourIdx < this.replacements.length || baseIdx < base.replacements.length) {\n\t\t\t// take the edit that starts first\n\t\t\tconst baseEdit = base.replacements[baseIdx];\n\t\t\tconst ourEdit = this.replacements[ourIdx];\n\n\t\t\tif (!ourEdit) {\n\t\t\t\t// We processed all our edits\n\t\t\t\tbreak;\n\t\t\t} else if (!baseEdit) {\n\t\t\t\t// no more edits from base\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else if (ourEdit.replaceRange.intersectsOrTouches(baseEdit.replaceRange)) {\n\t\t\t\tourIdx++; // Don't take our edit, as it is conflicting -> skip\n\t\t\t\tif (noOverlap) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t} else if (ourEdit.replaceRange.start < baseEdit.replaceRange.start) {\n\t\t\t\t// Our edit starts first\n\t\t\t\tnewEdits.push(new StringReplacement(\n\t\t\t\t\tourEdit.replaceRange.delta(offset),\n\t\t\t\t\tourEdit.newText\n\t\t\t\t));\n\t\t\t\tourIdx++;\n\t\t\t} else {\n\t\t\t\tbaseIdx++;\n\t\t\t\toffset += baseEdit.newText.length - baseEdit.replaceRange.length;\n\t\t\t}\n\t\t}\n\n\t\treturn new StringEdit(newEdits);\n\t}\n\n\tpublic toJson(): ISerializedStringEdit {\n\t\treturn this.replacements.map(e => e.toJson());\n\t}\n\n\tpublic isNeutralOn(text: string): boolean {\n\t\treturn this.replacements.every(e => e.isNeutralOn(text));\n\t}\n\n\tpublic removeCommonSuffixPrefix(originalText: string): StringEdit {\n\t\tconst edits: StringReplacement[] = [];\n\t\tfor (const e of this.replacements) {\n\t\t\tconst edit = e.removeCommonSuffixPrefix(originalText);\n\t\t\tif (!edit.isEmpty) {\n\t\t\t\tedits.push(edit);\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(edits);\n\t}\n\n\tpublic normalizeEOL(eol: '\\r\\n' | '\\n'): StringEdit {\n\t\treturn new StringEdit(this.replacements.map(edit => edit.normalizeEOL(eol)));\n\t}\n\n\t/**\n\t * If `e1.apply(source) === e2.apply(source)`, then `e1.normalizeOnSource(source).equals(e2.normalizeOnSource(source))`.\n\t*/\n\tpublic normalizeOnSource(source: string): StringEdit {\n\t\tconst result = this.apply(source);\n\n\t\tconst edit = StringReplacement.replace(OffsetRange.ofLength(source.length), result);\n\t\tconst e = edit.removeCommonSuffixAndPrefix(source);\n\t\tif (e.isEmpty) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\treturn e.toEdit();\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): TEdit {\n\t\treturn this._createNew(this.replacements.map(e => e.removeCommonSuffixAndPrefix(source))).normalize();\n\t}\n\n\tpublic applyOnText(docContents: StringText): StringText {\n\t\treturn new StringText(this.apply(docContents.value));\n\t}\n\n\tpublic mapData<TData extends IEditData<TData>>(f: (replacement: T) => TData): AnnotatedStringEdit<TData> {\n\t\treturn new AnnotatedStringEdit(\n\t\t\tthis.replacements.map(e => new AnnotatedStringReplacement(\n\t\t\t\te.replaceRange,\n\t\t\t\te.newText,\n\t\t\t\tf(e)\n\t\t\t))\n\t\t);\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\t/**\n\t * Checks if the edit would produce no changes when applied to the given text.\n\t */\n\tisNeutralOn(text: string): boolean {\n\t\treturn this.newText === text.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n'): StringReplacement {\n\t\tconst newText = this.newText.replace(/\\r\\n|\\n/g, eol);\n\t\treturn new StringReplacement(this.replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toEdit(): StringEdit {\n\t\treturn new StringEdit([this]);\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static create(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n\n\tpublic static single(replacement: StringReplacement): StringEdit {\n\t\treturn new StringEdit([replacement]);\n\t}\n\n\tpublic static replace(range: OffsetRange, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, replacement)]);\n\t}\n\n\tpublic static insert(offset: number, replacement: string): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(OffsetRange.emptyAt(offset), replacement)]);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringEdit {\n\t\treturn new StringEdit([new StringReplacement(range, '')]);\n\t}\n\n\tpublic static fromJson(data: ISerializedStringEdit): StringEdit {\n\t\treturn new StringEdit(data.map(StringReplacement.fromJson));\n\t}\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The replacements are applied in order!\n\t * Equals `StringEdit.compose(replacements.map(r => r.toEdit()))`, but is much more performant.\n\t*/\n\tpublic static composeSequentialReplacements(replacements: readonly StringReplacement[]): StringEdit {\n\t\tlet edit = StringEdit.empty;\n\t\tlet curEditReplacements: StringReplacement[] = []; // These are reverse sorted\n\n\t\tfor (const r of replacements) {\n\t\t\tconst last = curEditReplacements.at(-1);\n\t\t\tif (!last || r.replaceRange.isBefore(last.replaceRange)) {\n\t\t\t\t// Detect subsequences of reverse sorted replacements\n\t\t\t\tcurEditReplacements.push(r);\n\t\t\t} else {\n\t\t\t\t// Once the subsequence is broken, compose the current replacements and look for a new subsequence.\n\t\t\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\t\t\tcurEditReplacements = [r];\n\t\t\t}\n\t\t}\n\n\t\tedit = edit.compose(StringEdit.create(curEditReplacements.reverse()));\n\t\treturn edit;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport type ISerializedStringEdit = ISerializedStringReplacement[];\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\tpublic static delete(range: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, '');\n\t}\n\n\tpublic static fromJson(data: ISerializedStringReplacement): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.ofStartAndLength(data.pos, data.len), data.txt);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n/**\n * Represents data associated to a single edit, which survives certain edit operations.\n*/\nexport interface IEditData<T> {\n\tjoin(other: T): T | undefined;\n}\n\nexport class VoidEditData implements IEditData<VoidEditData> {\n\tjoin(other: VoidEditData): VoidEditData | undefined {\n\t\treturn this;\n\t}\n}\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class AnnotatedStringEdit<T extends IEditData<T>> extends BaseStringEdit<AnnotatedStringReplacement<T>, AnnotatedStringEdit<T>> {\n\tpublic static readonly empty = new AnnotatedStringEdit<never>([]);\n\n\tpublic static create<T extends IEditData<T>>(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit(replacements);\n\t}\n\n\tpublic static single<T extends IEditData<T>>(replacement: AnnotatedStringReplacement<T>): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([replacement]);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, replacement, data)]);\n\t}\n\n\tpublic static insert<T extends IEditData<T>>(offset: number, replacement: string, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(OffsetRange.emptyAt(offset), replacement, data)]);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit([new AnnotatedStringReplacement(range, '', data)]);\n\t}\n\n\tpublic static compose<T extends IEditData<T>>(edits: readonly AnnotatedStringEdit<T>[]): AnnotatedStringEdit<T> {\n\t\tif (edits.length === 0) {\n\t\t\treturn AnnotatedStringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly AnnotatedStringReplacement<T>[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly AnnotatedStringReplacement<T>[]): AnnotatedStringEdit<T> {\n\t\treturn new AnnotatedStringEdit<T>(replacements);\n\t}\n\n\tpublic toStringEdit(filter?: (replacement: AnnotatedStringReplacement<T>) => boolean): StringEdit {\n\t\tconst newReplacements: StringReplacement[] = [];\n\t\tfor (const r of this.replacements) {\n\t\t\tif (!filter || filter(r)) {\n\t\t\t\tnewReplacements.push(new StringReplacement(r.replaceRange, r.newText));\n\t\t\t}\n\t\t}\n\t\treturn new StringEdit(newReplacements);\n\t}\n}\n\nexport class AnnotatedStringReplacement<T extends IEditData<T>> extends BaseStringReplacement<AnnotatedStringReplacement<T>> {\n\tpublic static insert<T extends IEditData<T>>(offset: number, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(OffsetRange.emptyAt(offset), text, data);\n\t}\n\n\tpublic static replace<T extends IEditData<T>>(range: OffsetRange, text: string, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, text, data);\n\t}\n\n\tpublic static delete<T extends IEditData<T>>(range: OffsetRange, data: T): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement<T>(range, '', data);\n\t}\n\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tnewText: string,\n\t\tpublic readonly data: T\n\t) {\n\t\tsuper(range, newText);\n\t}\n\n\toverride equals(other: AnnotatedStringReplacement<T>): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText && this.data === other.data;\n\t}\n\n\ttryJoinTouching(other: AnnotatedStringReplacement<T>): AnnotatedStringReplacement<T> | undefined {\n\t\tconst joined = this.data.join(other.data);\n\t\tif (joined === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new AnnotatedStringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText, joined);\n\t}\n\n\tslice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotatedStringReplacement<T> {\n\t\treturn new AnnotatedStringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText, this.data);\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../edits/textEdit.js';\nimport { _setPositionOffsetTransformerDependencies } from './positionToOffsetImpl.js';\nimport { TextLength } from './textLength.js';\n\nexport { PositionOffsetTransformerBase, PositionOffsetTransformer } from './positionToOffsetImpl.js';\n\n_setPositionOffsetTransformerDependencies({\n\tStringEdit: StringEdit,\n\tStringReplacement: StringReplacement,\n\tTextReplacement: TextReplacement,\n\tTextEdit: TextEdit,\n\tTextLength: TextLength,\n});\n\n// TODO@hediet this is dept and needs to go. See https://github.com/microsoft/vscode/issues/251126.\nexport function ensureDependenciesAreSet(): void {\n\t// Noop\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../edits/textEdit.js';\nimport { _setPositionOffsetTransformerDependencies } from './positionToOffsetImpl.js';\nimport { TextLength } from './textLength.js';\n\nexport { PositionOffsetTransformerBase, PositionOffsetTransformer } from './positionToOffsetImpl.js';\n\n_setPositionOffsetTransformerDependencies({\n\tStringEdit: StringEdit,\n\tStringReplacement: StringReplacement,\n\tTextReplacement: TextReplacement,\n\tTextEdit: TextEdit,\n\tTextLength: TextLength,\n});\n\n// TODO@hediet this is dept and needs to go. See https://github.com/microsoft/vscode/issues/251126.\nexport function ensureDependenciesAreSet(): void {\n\t// Noop\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler } from '../../../base/common/worker/webWorker.js';\nimport { Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { EndOfLineSequence, ITextModel } from '../model.js';\nimport { IMirrorTextModel, IModelChangedEvent } from '../model/mirrorTextModel.js';\nimport { IColorInformation, IInplaceReplaceSupportResult, ILink, TextEdit } from '../languages.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { DiffAlgorithmName, IDiffComputationResult, ILineChange, IUnicodeHighlightsResult } from './editorWorker.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter, UnicodeHighlighterOptions } from './unicodeTextModelHighlighter.js';\nimport { DiffComputer, IChange } from '../diff/legacyLinesDiffComputer.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions } from '../diff/linesDiffComputer.js';\nimport { DetailedLineRangeMapping } from '../diff/rangeMapping.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { IDocumentDiffProviderOptions } from '../diff/documentDiffProvider.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\nimport { FindSectionHeaderOptions, SectionHeader, findSectionHeaders } from './findSectionHeaders.js';\nimport { IRawModelData, IWorkerTextModelSyncChannelServer } from './textModelSync/textModelSync.protocol.js';\nimport { ICommonModel, WorkerTextModelSyncServer } from './textModelSync/textModelSync.impl.js';\nimport { ISerializedStringEdit, StringEdit } from '../core/edits/stringEdit.js';\nimport { StringText } from '../core/text/abstractText.js';\nimport { ensureDependenciesAreSet } from '../core/text/positionToOffset.js';\n\nexport interface IMirrorModel extends IMirrorTextModel {\n\treadonly uri: URI;\n\treadonly version: number;\n\tgetValue(): string;\n}\n\nexport interface IWorkerContext<H = {}> {\n\t/**\n\t * A proxy to the main thread host object.\n\t */\n\thost: H;\n\t/**\n\t * Get all available mirror models in this worker.\n\t */\n\tgetMirrorModels(): IMirrorModel[];\n}\n\n/**\n * Range of a word inside a model.\n * @internal\n */\nexport interface IWordRange {\n\t/**\n\t * The index where the word starts.\n\t */\n\treadonly start: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\treadonly end: number;\n}\n\n/**\n * @internal\n */\nexport class EditorWorker implements IDisposable, IWorkerTextModelSyncChannelServer, IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tprivate readonly _workerTextModelSyncServer = new WorkerTextModelSyncServer();\n\n\tconstructor(\n\t\tprivate readonly _foreignModule: any | null = null\n\t) { }\n\n\tdispose(): void {\n\t}\n\n\tpublic async $ping() {\n\t\treturn 'pong';\n\t}\n\n\tprotected _getModel(uri: string): ICommonModel | undefined {\n\t\treturn this._workerTextModelSyncServer.getModel(uri);\n\t}\n\n\tpublic getModels(): ICommonModel[] {\n\t\treturn this._workerTextModelSyncServer.getModels();\n\t}\n\n\tpublic $acceptNewModel(data: IRawModelData): void {\n\t\tthis._workerTextModelSyncServer.$acceptNewModel(data);\n\t}\n\n\tpublic $acceptModelChanged(uri: string, e: IModelChangedEvent): void {\n\t\tthis._workerTextModelSyncServer.$acceptModelChanged(uri, e);\n\t}\n\n\tpublic $acceptRemovedModel(uri: string): void {\n\t\tthis._workerTextModelSyncServer.$acceptRemovedModel(uri);\n\t}\n\n\tpublic async $computeUnicodeHighlights(url: string, options: UnicodeHighlighterOptions, range?: IRange): Promise<IUnicodeHighlightsResult> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n\t\t}\n\t\treturn UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n\t}\n\n\tpublic async $findSectionHeaders(url: string, options: FindSectionHeaderOptions): Promise<SectionHeader[]> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\t\treturn findSectionHeaders(model, options);\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic async $computeDiff(originalUrl: string, modifiedUrl: string, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): Promise<IDiffComputationResult | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result = EditorWorker.computeDiff(original, modified, options, algorithm);\n\t\treturn result;\n\t}\n\n\tprivate static computeDiff(originalTextModel: ICommonModel | ITextModel, modifiedTextModel: ICommonModel | ITextModel, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): IDiffComputationResult {\n\t\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\t\tconst originalLines = originalTextModel.getLinesContent();\n\t\tconst modifiedLines = modifiedTextModel.getLinesContent();\n\n\t\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n\n\t\tconst identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n\n\t\tfunction getLineChanges(changes: readonly DetailedLineRangeMapping[]): ILineChange[] {\n\t\t\treturn changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n\t\t\t\tm.originalRange.startLineNumber,\n\t\t\t\tm.originalRange.startColumn,\n\t\t\t\tm.originalRange.endLineNumber,\n\t\t\t\tm.originalRange.endColumn,\n\t\t\t\tm.modifiedRange.startLineNumber,\n\t\t\t\tm.modifiedRange.startColumn,\n\t\t\t\tm.modifiedRange.endLineNumber,\n\t\t\t\tm.modifiedRange.endColumn,\n\t\t\t])]));\n\t\t}\n\n\t\treturn {\n\t\t\tidentical,\n\t\t\tquitEarly: result.hitTimeout,\n\t\t\tchanges: getLineChanges(result.changes),\n\t\t\tmoves: result.moves.map(m => ([\n\t\t\t\tm.lineRangeMapping.original.startLineNumber,\n\t\t\t\tm.lineRangeMapping.original.endLineNumberExclusive,\n\t\t\t\tm.lineRangeMapping.modified.startLineNumber,\n\t\t\t\tm.lineRangeMapping.modified.endLineNumberExclusive,\n\t\t\t\tgetLineChanges(m.changes)\n\t\t\t])),\n\t\t};\n\t}\n\n\tprivate static _modelsAreIdentical(original: ICommonModel | ITextModel, modified: ICommonModel | ITextModel): boolean {\n\t\tconst originalLineCount = original.getLineCount();\n\t\tconst modifiedLineCount = modified.getLineCount();\n\t\tif (originalLineCount !== modifiedLineCount) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let line = 1; line <= originalLineCount; line++) {\n\t\t\tconst originalLine = original.getLineContent(line);\n\t\t\tconst modifiedLine = modified.getLineContent(line);\n\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic async $computeDirtyDiff(originalUrl: string, modifiedUrl: string, ignoreTrimWhitespace: boolean): Promise<IChange[] | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst originalLines = original.getLinesContent();\n\t\tconst modifiedLines = modified.getLinesContent();\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldComputeCharChanges: false,\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tmaxComputationTime: 1000\n\t\t});\n\t\treturn diffComputer.computeDiff().changes;\n\t}\n\n\tpublic $computeStringDiff(original: string, modified: string, options: { maxComputationTimeMs: number }, algorithm: DiffAlgorithmName): ISerializedStringEdit {\n\t\treturn computeStringDiff(original, modified, options, algorithm).toJson();\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\n\t// ---- BEGIN minimal edits ---------------------------------------------------------------\n\n\tprivate static readonly _diffLimit = 100000;\n\n\tpublic async $computeMoreMinimalEdits(modelUrl: string, edits: TextEdit[], pretty: boolean): Promise<TextEdit[]> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\t// merge adjacent edits\n\t\tlet writeIndex = 0;\n\t\tfor (let readIndex = 1; readIndex < edits.length; readIndex++) {\n\t\t\tif (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n\t\t\t\tedits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n\t\t\t\tedits[writeIndex].text += edits[readIndex].text;\n\t\t\t} else {\n\t\t\t\twriteIndex++;\n\t\t\t\tedits[writeIndex] = edits[readIndex];\n\t\t\t}\n\t\t}\n\t\tedits.length = writeIndex + 1;\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\t\t\tconst changes = stringDiff(original, text, pretty);\n\t\t\tconst editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n\n\t\t\tfor (const change of changes) {\n\t\t\t\tconst start = model.positionAt(editOffset + change.originalStart);\n\t\t\t\tconst end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n\t\t\t\tconst newEdit: TextEdit = {\n\t\t\t\t\ttext: text.substr(change.modifiedStart, change.modifiedLength),\n\t\t\t\t\trange: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n\t\t\t\t};\n\n\t\t\t\tif (model.getValueInRange(newEdit.range) !== newEdit.text) {\n\t\t\t\t\tresult.push(newEdit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic $computeHumanReadableDiff(modelUrl: string, edits: TextEdit[], options: ILinesDiffComputerOptions): TextEdit[] {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\n\t\t\tconst originalLines = original.split(/\\r\\n|\\n|\\r/);\n\t\t\tconst modifiedLines = text.split(/\\r\\n|\\n|\\r/);\n\n\t\t\tconst diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);\n\n\t\t\tconst start = Range.lift(range).getStartPosition();\n\n\t\t\tfunction addPositions(pos1: Position, pos2: Position): Position {\n\t\t\t\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n\t\t\t}\n\n\t\t\tfunction getText(lines: string[], range: Range): string[] {\n\t\t\t\tconst result: string[] = [];\n\t\t\t\tfor (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n\t\t\t\t\tconst line = lines[i - 1];\n\t\t\t\t\tif (i === range.startLineNumber && i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1, range.endColumn - 1));\n\t\t\t\t\t} else if (i === range.startLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1));\n\t\t\t\t\t} else if (i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(0, range.endColumn - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (const c of diff.changes) {\n\t\t\t\tif (c.innerChanges) {\n\t\t\t\t\tfor (const x of c.innerChanges) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\trange: Range.fromPositions(\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getStartPosition()),\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getEndPosition())\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttext: getText(modifiedLines, x.modifiedRange).join(model.eol)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BugIndicatingError('The experimental diff algorithm always produces inner changes');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// ---- END minimal edits ---------------------------------------------------------------\n\n\tpublic async $computeLinks(modelUrl: string): Promise<ILink[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn computeLinks(model);\n\t}\n\n\t// --- BEGIN default document colors -----------------------------------------------------------\n\n\tpublic async $computeDefaultDocumentColors(modelUrl: string): Promise<IColorInformation[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn computeDefaultDocumentColors(model);\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tprivate static readonly _suggestionsLimit = 10000;\n\n\tpublic async $textualSuggest(modelUrls: string[], leadingWord: string | undefined, wordDef: string, wordDefFlags: string): Promise<{ words: string[]; duration: number } | null> {\n\n\t\tconst sw = new StopWatch();\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst seen = new Set<string>();\n\n\t\touter: for (const url of modelUrls) {\n\t\t\tconst model = this._getModel(url);\n\t\t\tif (!model) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const word of model.words(wordDefRegExp)) {\n\t\t\t\tif (word === leadingWord || !isNaN(Number(word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tseen.add(word);\n\t\t\t\tif (seen.size > EditorWorker._suggestionsLimit) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { words: Array.from(seen), duration: sw.elapsed() };\n\t}\n\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\t//#region -- word ranges --\n\n\tpublic async $computeWordRanges(modelUrl: string, range: IRange, wordDef: string, wordDefFlags: string): Promise<{ [word: string]: IRange[] }> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn Object.create(null);\n\t\t}\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst result: { [word: string]: IRange[] } = Object.create(null);\n\t\tfor (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n\t\t\tconst words = model.getLineWords(line, wordDefRegExp);\n\t\t\tfor (const word of words) {\n\t\t\t\tif (!isNaN(Number(word.word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet array = result[word.word];\n\t\t\t\tif (!array) {\n\t\t\t\t\tarray = [];\n\t\t\t\t\tresult[word.word] = array;\n\t\t\t\t}\n\t\t\t\tarray.push({\n\t\t\t\t\tstartLineNumber: line,\n\t\t\t\t\tstartColumn: word.startColumn,\n\t\t\t\t\tendLineNumber: line,\n\t\t\t\t\tendColumn: word.endColumn\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t//#endregion\n\n\tpublic async $navigateValueSet(modelUrl: string, range: IRange, up: boolean, wordDef: string, wordDefFlags: string): Promise<IInplaceReplaceSupportResult | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange = {\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tstartColumn: range.startColumn,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tendColumn: range.endColumn + 1\n\t\t\t};\n\t\t}\n\n\t\tconst selectionText = model.getValueInRange(range);\n\n\t\tconst wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tif (!wordRange) {\n\t\t\treturn null;\n\t\t}\n\t\tconst word = model.getValueInRange(wordRange);\n\t\tconst result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn result;\n\t}\n\n\t// ---- BEGIN foreign module support --------------------------------------------------------------------------\n\n\t// foreign method request\n\tpublic $fmr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing requestHandler or method: ' + method));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t// ---- END foreign module support --------------------------------------------------------------------------\n}\n\n// This is only available in a Web Worker\ndeclare function importScripts(...urls: string[]): void;\n\nif (typeof importScripts === 'function') {\n\t// Running in a web worker\n\tglobalThis.monaco = createMonacoBaseAPI();\n}\n\n/**\n * @internal\n*/\nexport function computeStringDiff(original: string, modified: string, options: { maxComputationTimeMs: number }, algorithm: DiffAlgorithmName): StringEdit {\n\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\tensureDependenciesAreSet();\n\n\tconst originalText = new StringText(original);\n\tconst originalLines = originalText.getLines();\n\tconst modifiedText = new StringText(modified);\n\tconst modifiedLines = modifiedText.getLines();\n\n\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, { ignoreTrimWhitespace: false, maxComputationTimeMs: options.maxComputationTimeMs, computeMoves: false, extendToSubwords: false });\n\n\tconst textEdit = DetailedLineRangeMapping.toTextEdit(result.changes, modifiedText);\n\tconst strEdit = originalText.getTransformer().getStringEdit(textEdit);\n\n\treturn strEdit;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { IWebWorkerServerRequestHandler } from '../../../base/common/worker/webWorker.js';\nimport { Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { EndOfLineSequence, ITextModel } from '../model.js';\nimport { IMirrorTextModel, IModelChangedEvent } from '../model/mirrorTextModel.js';\nimport { IColorInformation, IInplaceReplaceSupportResult, ILink, TextEdit } from '../languages.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { DiffAlgorithmName, IDiffComputationResult, ILineChange, IUnicodeHighlightsResult } from './editorWorker.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter, UnicodeHighlighterOptions } from './unicodeTextModelHighlighter.js';\nimport { DiffComputer, IChange } from '../diff/legacyLinesDiffComputer.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions } from '../diff/linesDiffComputer.js';\nimport { DetailedLineRangeMapping } from '../diff/rangeMapping.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { IDocumentDiffProviderOptions } from '../diff/documentDiffProvider.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\nimport { FindSectionHeaderOptions, SectionHeader, findSectionHeaders } from './findSectionHeaders.js';\nimport { IRawModelData, IWorkerTextModelSyncChannelServer } from './textModelSync/textModelSync.protocol.js';\nimport { ICommonModel, WorkerTextModelSyncServer } from './textModelSync/textModelSync.impl.js';\nimport { ISerializedStringEdit, StringEdit } from '../core/edits/stringEdit.js';\nimport { StringText } from '../core/text/abstractText.js';\nimport { ensureDependenciesAreSet } from '../core/text/positionToOffset.js';\n\nexport interface IMirrorModel extends IMirrorTextModel {\n\treadonly uri: URI;\n\treadonly version: number;\n\tgetValue(): string;\n}\n\nexport interface IWorkerContext<H = {}> {\n\t/**\n\t * A proxy to the main thread host object.\n\t */\n\thost: H;\n\t/**\n\t * Get all available mirror models in this worker.\n\t */\n\tgetMirrorModels(): IMirrorModel[];\n}\n\n/**\n * Range of a word inside a model.\n * @internal\n */\nexport interface IWordRange {\n\t/**\n\t * The index where the word starts.\n\t */\n\treadonly start: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\treadonly end: number;\n}\n\n/**\n * @internal\n */\nexport class EditorWorker implements IDisposable, IWorkerTextModelSyncChannelServer, IWebWorkerServerRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tprivate readonly _workerTextModelSyncServer = new WorkerTextModelSyncServer();\n\n\tconstructor(\n\t\tprivate readonly _foreignModule: any | null = null\n\t) { }\n\n\tdispose(): void {\n\t}\n\n\tpublic async $ping() {\n\t\treturn 'pong';\n\t}\n\n\tprotected _getModel(uri: string): ICommonModel | undefined {\n\t\treturn this._workerTextModelSyncServer.getModel(uri);\n\t}\n\n\tpublic getModels(): ICommonModel[] {\n\t\treturn this._workerTextModelSyncServer.getModels();\n\t}\n\n\tpublic $acceptNewModel(data: IRawModelData): void {\n\t\tthis._workerTextModelSyncServer.$acceptNewModel(data);\n\t}\n\n\tpublic $acceptModelChanged(uri: string, e: IModelChangedEvent): void {\n\t\tthis._workerTextModelSyncServer.$acceptModelChanged(uri, e);\n\t}\n\n\tpublic $acceptRemovedModel(uri: string): void {\n\t\tthis._workerTextModelSyncServer.$acceptRemovedModel(uri);\n\t}\n\n\tpublic async $computeUnicodeHighlights(url: string, options: UnicodeHighlighterOptions, range?: IRange): Promise<IUnicodeHighlightsResult> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n\t\t}\n\t\treturn UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n\t}\n\n\tpublic async $findSectionHeaders(url: string, options: FindSectionHeaderOptions): Promise<SectionHeader[]> {\n\t\tconst model = this._getModel(url);\n\t\tif (!model) {\n\t\t\treturn [];\n\t\t}\n\t\treturn findSectionHeaders(model, options);\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic async $computeDiff(originalUrl: string, modifiedUrl: string, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): Promise<IDiffComputationResult | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result = EditorWorker.computeDiff(original, modified, options, algorithm);\n\t\treturn result;\n\t}\n\n\tprivate static computeDiff(originalTextModel: ICommonModel | ITextModel, modifiedTextModel: ICommonModel | ITextModel, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): IDiffComputationResult {\n\t\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\t\tconst originalLines = originalTextModel.getLinesContent();\n\t\tconst modifiedLines = modifiedTextModel.getLinesContent();\n\n\t\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n\n\t\tconst identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n\n\t\tfunction getLineChanges(changes: readonly DetailedLineRangeMapping[]): ILineChange[] {\n\t\t\treturn changes.map(m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n\t\t\t\tm.originalRange.startLineNumber,\n\t\t\t\tm.originalRange.startColumn,\n\t\t\t\tm.originalRange.endLineNumber,\n\t\t\t\tm.originalRange.endColumn,\n\t\t\t\tm.modifiedRange.startLineNumber,\n\t\t\t\tm.modifiedRange.startColumn,\n\t\t\t\tm.modifiedRange.endLineNumber,\n\t\t\t\tm.modifiedRange.endColumn,\n\t\t\t])]));\n\t\t}\n\n\t\treturn {\n\t\t\tidentical,\n\t\t\tquitEarly: result.hitTimeout,\n\t\t\tchanges: getLineChanges(result.changes),\n\t\t\tmoves: result.moves.map(m => ([\n\t\t\t\tm.lineRangeMapping.original.startLineNumber,\n\t\t\t\tm.lineRangeMapping.original.endLineNumberExclusive,\n\t\t\t\tm.lineRangeMapping.modified.startLineNumber,\n\t\t\t\tm.lineRangeMapping.modified.endLineNumberExclusive,\n\t\t\t\tgetLineChanges(m.changes)\n\t\t\t])),\n\t\t};\n\t}\n\n\tprivate static _modelsAreIdentical(original: ICommonModel | ITextModel, modified: ICommonModel | ITextModel): boolean {\n\t\tconst originalLineCount = original.getLineCount();\n\t\tconst modifiedLineCount = modified.getLineCount();\n\t\tif (originalLineCount !== modifiedLineCount) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let line = 1; line <= originalLineCount; line++) {\n\t\t\tconst originalLine = original.getLineContent(line);\n\t\t\tconst modifiedLine = modified.getLineContent(line);\n\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic async $computeDirtyDiff(originalUrl: string, modifiedUrl: string, ignoreTrimWhitespace: boolean): Promise<IChange[] | null> {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst originalLines = original.getLinesContent();\n\t\tconst modifiedLines = modified.getLinesContent();\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldComputeCharChanges: false,\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tmaxComputationTime: 1000\n\t\t});\n\t\treturn diffComputer.computeDiff().changes;\n\t}\n\n\tpublic $computeStringDiff(original: string, modified: string, options: { maxComputationTimeMs: number }, algorithm: DiffAlgorithmName): ISerializedStringEdit {\n\t\treturn computeStringDiff(original, modified, options, algorithm).toJson();\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\n\t// ---- BEGIN minimal edits ---------------------------------------------------------------\n\n\tprivate static readonly _diffLimit = 100000;\n\n\tpublic async $computeMoreMinimalEdits(modelUrl: string, edits: TextEdit[], pretty: boolean): Promise<TextEdit[]> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\t// merge adjacent edits\n\t\tlet writeIndex = 0;\n\t\tfor (let readIndex = 1; readIndex < edits.length; readIndex++) {\n\t\t\tif (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n\t\t\t\tedits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n\t\t\t\tedits[writeIndex].text += edits[readIndex].text;\n\t\t\t} else {\n\t\t\t\twriteIndex++;\n\t\t\t\tedits[writeIndex] = edits[readIndex];\n\t\t\t}\n\t\t}\n\t\tedits.length = writeIndex + 1;\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\t\t\tconst changes = stringDiff(original, text, pretty);\n\t\t\tconst editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n\n\t\t\tfor (const change of changes) {\n\t\t\t\tconst start = model.positionAt(editOffset + change.originalStart);\n\t\t\t\tconst end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n\t\t\t\tconst newEdit: TextEdit = {\n\t\t\t\t\ttext: text.substr(change.modifiedStart, change.modifiedLength),\n\t\t\t\t\trange: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n\t\t\t\t};\n\n\t\t\t\tif (model.getValueInRange(newEdit.range) !== newEdit.text) {\n\t\t\t\t\tresult.push(newEdit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic $computeHumanReadableDiff(modelUrl: string, edits: TextEdit[], options: ILinesDiffComputerOptions): TextEdit[] {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextEdit[] = [];\n\t\tlet lastEol: EndOfLineSequence | undefined = undefined;\n\n\t\tedits = edits.slice(0).sort((a, b) => {\n\t\t\tif (a.range && b.range) {\n\t\t\t\treturn Range.compareRangesUsingStarts(a.range, b.range);\n\t\t\t}\n\t\t\t// eol only changes should go to the end\n\t\t\tconst aRng = a.range ? 0 : 1;\n\t\t\tconst bRng = b.range ? 0 : 1;\n\t\t\treturn aRng - bRng;\n\t\t});\n\n\t\tfor (let { range, text, eol } of edits) {\n\n\t\t\tif (typeof eol === 'number') {\n\t\t\t\tlastEol = eol;\n\t\t\t}\n\n\t\t\tif (Range.isEmpty(range) && !text) {\n\t\t\t\t// empty change\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst original = model.getValueInRange(range);\n\t\t\ttext = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n\n\t\t\tif (original === text) {\n\t\t\t\t// noop\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// make sure diff won't take too long\n\t\t\tif (Math.max(text.length, original.length) > EditorWorker._diffLimit) {\n\t\t\t\tresult.push({ range, text });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// compute diff between original and edit.text\n\n\t\t\tconst originalLines = original.split(/\\r\\n|\\n|\\r/);\n\t\t\tconst modifiedLines = text.split(/\\r\\n|\\n|\\r/);\n\n\t\t\tconst diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);\n\n\t\t\tconst start = Range.lift(range).getStartPosition();\n\n\t\t\tfunction addPositions(pos1: Position, pos2: Position): Position {\n\t\t\t\treturn new Position(pos1.lineNumber + pos2.lineNumber - 1, pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column);\n\t\t\t}\n\n\t\t\tfunction getText(lines: string[], range: Range): string[] {\n\t\t\t\tconst result: string[] = [];\n\t\t\t\tfor (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n\t\t\t\t\tconst line = lines[i - 1];\n\t\t\t\t\tif (i === range.startLineNumber && i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1, range.endColumn - 1));\n\t\t\t\t\t} else if (i === range.startLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(range.startColumn - 1));\n\t\t\t\t\t} else if (i === range.endLineNumber) {\n\t\t\t\t\t\tresult.push(line.substring(0, range.endColumn - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (const c of diff.changes) {\n\t\t\t\tif (c.innerChanges) {\n\t\t\t\t\tfor (const x of c.innerChanges) {\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\trange: Range.fromPositions(\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getStartPosition()),\n\t\t\t\t\t\t\t\taddPositions(start, x.originalRange.getEndPosition())\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\ttext: getText(modifiedLines, x.modifiedRange).join(model.eol)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BugIndicatingError('The experimental diff algorithm always produces inner changes');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof lastEol === 'number') {\n\t\t\tresult.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// ---- END minimal edits ---------------------------------------------------------------\n\n\tpublic async $computeLinks(modelUrl: string): Promise<ILink[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn computeLinks(model);\n\t}\n\n\t// --- BEGIN default document colors -----------------------------------------------------------\n\n\tpublic async $computeDefaultDocumentColors(modelUrl: string): Promise<IColorInformation[] | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn computeDefaultDocumentColors(model);\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tprivate static readonly _suggestionsLimit = 10000;\n\n\tpublic async $textualSuggest(modelUrls: string[], leadingWord: string | undefined, wordDef: string, wordDefFlags: string): Promise<{ words: string[]; duration: number } | null> {\n\n\t\tconst sw = new StopWatch();\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst seen = new Set<string>();\n\n\t\touter: for (const url of modelUrls) {\n\t\t\tconst model = this._getModel(url);\n\t\t\tif (!model) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const word of model.words(wordDefRegExp)) {\n\t\t\t\tif (word === leadingWord || !isNaN(Number(word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tseen.add(word);\n\t\t\t\tif (seen.size > EditorWorker._suggestionsLimit) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { words: Array.from(seen), duration: sw.elapsed() };\n\t}\n\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\t//#region -- word ranges --\n\n\tpublic async $computeWordRanges(modelUrl: string, range: IRange, wordDef: string, wordDefFlags: string): Promise<{ [word: string]: IRange[] }> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn Object.create(null);\n\t\t}\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\t\tconst result: { [word: string]: IRange[] } = Object.create(null);\n\t\tfor (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n\t\t\tconst words = model.getLineWords(line, wordDefRegExp);\n\t\t\tfor (const word of words) {\n\t\t\t\tif (!isNaN(Number(word.word))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet array = result[word.word];\n\t\t\t\tif (!array) {\n\t\t\t\t\tarray = [];\n\t\t\t\t\tresult[word.word] = array;\n\t\t\t\t}\n\t\t\t\tarray.push({\n\t\t\t\t\tstartLineNumber: line,\n\t\t\t\t\tstartColumn: word.startColumn,\n\t\t\t\t\tendLineNumber: line,\n\t\t\t\t\tendColumn: word.endColumn\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t//#endregion\n\n\tpublic async $navigateValueSet(modelUrl: string, range: IRange, up: boolean, wordDef: string, wordDefFlags: string): Promise<IInplaceReplaceSupportResult | null> {\n\t\tconst model = this._getModel(modelUrl);\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange = {\n\t\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\t\tstartColumn: range.startColumn,\n\t\t\t\tendLineNumber: range.endLineNumber,\n\t\t\t\tendColumn: range.endColumn + 1\n\t\t\t};\n\t\t}\n\n\t\tconst selectionText = model.getValueInRange(range);\n\n\t\tconst wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tif (!wordRange) {\n\t\t\treturn null;\n\t\t}\n\t\tconst word = model.getValueInRange(wordRange);\n\t\tconst result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn result;\n\t}\n\n\t// ---- BEGIN foreign module support --------------------------------------------------------------------------\n\n\t// foreign method request\n\tpublic $fmr(method: string, args: any[]): Promise<any> {\n\t\tif (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n\t\t\treturn Promise.reject(new Error('Missing requestHandler or method: ' + method));\n\t\t}\n\n\t\ttry {\n\t\t\treturn Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n\n\t// ---- END foreign module support --------------------------------------------------------------------------\n}\n\n// This is only available in a Web Worker\ndeclare function importScripts(...urls: string[]): void;\n\nif (typeof importScripts === 'function') {\n\t// Running in a web worker\n\tglobalThis.monaco = createMonacoBaseAPI();\n}\n\n/**\n * @internal\n*/\nexport function computeStringDiff(original: string, modified: string, options: { maxComputationTimeMs: number }, algorithm: DiffAlgorithmName): StringEdit {\n\tconst diffAlgorithm: ILinesDiffComputer = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n\n\tensureDependenciesAreSet();\n\n\tconst originalText = new StringText(original);\n\tconst originalLines = originalText.getLines();\n\tconst modifiedText = new StringText(modified);\n\tconst modifiedLines = modifiedText.getLines();\n\n\tconst result = diffAlgorithm.computeDiff(originalLines, modifiedLines, { ignoreTrimWhitespace: false, maxComputationTimeMs: options.maxComputationTimeMs, computeMoves: false, extendToSubwords: false });\n\n\tconst textEdit = DetailedLineRangeMapping.toTextEdit(result.changes, modifiedText);\n\tconst strEdit = originalText.getTransformer().getStringEdit(textEdit);\n\n\treturn strEdit;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { bootstrapWebWorker } from '../../../base/common/worker/webWorkerBootstrap.js';\nimport { EditorWorker } from './editorWebWorker.js';\n\nbootstrapWebWorker(() => new EditorWorker(null));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { bootstrapWebWorker } from '../../../base/common/worker/webWorkerBootstrap.js';\nimport { EditorWorker } from './editorWebWorker.js';\n\nbootstrapWebWorker(() => new EditorWorker(null));\n"],"mappings":"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IAAA,EAAA,IAAA;AAEA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,QAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAA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A,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,MAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,aAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,IAAA,IAAA,EAAA,IAAA;AACA,EAAAA,SAAAA,SAAA,KAAA,IAAA,EAAA,IA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","names":["CompareResult","_a","Touch","Iterable","_empty","from","i","Event","map","filter","equals","buffer","id","resolve","count","errorHandler","result","Platform","Language","OperatingSystem","CancellationToken","LazyValueState","GraphemeBreakType","CodePoint","map","MessageType","resolve","i","SHA1Constant","LocalConstants","score","Constants","Boolean","State","CharacterClass","KeyCode","ScanCode","KeyCodeUtils","KeyMod","isPathSeparator","_format","sep","isAbsolute","fromLen","toLen","length","i","cwd","start","SelectionDirection","id","language","HoverVerbosityAction","CompletionItemKind","CompletionItemKinds","CompletionItemTag","CompletionItemInsertTextRule","PartialAcceptTriggerKind","CompletionTriggerKind","InlineCompletionTriggerKind","InlineCompletionDisplayLocationKind","InlineCompletionEndOfLifeReasonKind","CodeActionTriggerType","DocumentPasteTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKind","SymbolTag","SymbolKinds","NewSymbolNameTag","NewSymbolNameTriggerKind","Command","CommentThreadCollapsibleState","CommentThreadState","CommentThreadApplicability","CommentMode","CommentState","InlayHintKind","TokenizationRegistry","ExternalUriOpenerPriority","AccessibilitySupport","CodeActionTriggerType","CompletionItemInsertTextRule","CompletionItemKind","CompletionItemTag","CompletionTriggerKind","ContentWidgetPositionPreference","CursorChangeReason","DefaultEndOfLine","DocumentHighlightKind","EditorAutoIndentStrategy","EditorOption","EndOfLinePreference","EndOfLineSequence","GlyphMarginLane","HoverVerbosityAction","IndentAction","InjectedTextCursorStops","InlayHintKind","InlineCompletionDisplayLocationKind","InlineCompletionEndOfLifeReasonKind","InlineCompletionTriggerKind","KeyCode","MarkerSeverity","MarkerTag","MinimapPosition","MinimapSectionHeaderStyle","MouseTargetType","NewSymbolNameTag","NewSymbolNameTriggerKind","OverlayWidgetPositionPreference","OverviewRulerLane","PartialAcceptTriggerKind","PositionAffinity","RenderLineNumbersType","RenderMinimap","ScrollType","ScrollbarVisibility","SelectionDirection","ShowLightbulbIconMode","SignatureHelpTriggerKind","SymbolKind","SymbolTag","TextDirection","TextEditorCursorBlinkingStyle","TextEditorCursorStyle","TrackedRangeStickiness","WrappingIndent","KeyMod","KeyCode","SelectionDirection","WordCharacterClass","OverviewRulerLane","GlyphMarginLane","MinimapPosition","MinimapSectionHeaderStyle","TextDirection","InjectedTextCursorStops","EndOfLinePreference","DefaultEndOfLine","EndOfLineSequence","TrackedRangeStickiness","PositionAffinity","ModelConstants","sep","UnicodeHighlighterReasonKind","codePoint","isBasicASCII","SimpleHighlightReason","lineLength","r","r","c","key","s1","s2","score","CharBoundaryCategory","score","equalPart","shouldJoinDiffs","LineSequence","LineSequence","resultA","resultARatio","normalize","relative","Color","Format","CSS","format","parse","isPathSeparator","sep","pos","Schemas","COI","basename","dirname","relativePath","sep","isEqualOrParent","extname","DataUri","DeferredOutcome","resolve","Promises","AsyncIterableSourceState","m","addPositions","getText","range","result"],"file":"editorWebWorkerMain.js"}