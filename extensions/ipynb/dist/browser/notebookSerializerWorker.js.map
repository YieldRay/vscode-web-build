{"version":3,"file":"notebookSerializerWorker.js","mappings":"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","sources":["webpack://serverExportVar/./src/serializers.ts","webpack://serverExportVar/./src/constants.ts","webpack://serverExportVar/webpack/bootstrap","webpack://serverExportVar/./src/notebookSerializerWorker.web.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type * as nbformat from '@jupyterlab/nbformat';\nimport type { NotebookCell, NotebookCellData, NotebookCellOutput, NotebookData, NotebookDocument } from 'vscode';\nimport { CellOutputMetadata, type CellMetadata } from './common';\nimport { textMimeTypes, NotebookCellKindMarkup, CellOutputMimeTypes, defaultNotebookFormat } from './constants';\n\nconst textDecoder = new TextDecoder();\n\nexport function createJupyterCellFromNotebookCell(\n\tvscCell: NotebookCellData,\n\tpreferredLanguage: string | undefined,\n): nbformat.IRawCell | nbformat.IMarkdownCell | nbformat.ICodeCell {\n\tlet cell: nbformat.IRawCell | nbformat.IMarkdownCell | nbformat.ICodeCell;\n\tif (vscCell.kind === NotebookCellKindMarkup) {\n\t\tcell = createMarkdownCellFromNotebookCell(vscCell);\n\t} else if (vscCell.languageId === 'raw') {\n\t\tcell = createRawCellFromNotebookCell(vscCell);\n\t} else {\n\t\tcell = createCodeCellFromNotebookCell(vscCell, preferredLanguage);\n\t}\n\treturn cell;\n}\n\n\n/**\n * Sort the JSON to minimize unnecessary SCM changes.\n * Jupyter notbeooks/labs sorts the JSON keys in alphabetical order.\n * https://github.com/microsoft/vscode-python/issues/13155\n */\nexport function sortObjectPropertiesRecursively(obj: any): any {\n\tif (Array.isArray(obj)) {\n\t\treturn obj.map(sortObjectPropertiesRecursively);\n\t}\n\tif (obj !== undefined && obj !== null && typeof obj === 'object' && Object.keys(obj).length > 0) {\n\t\treturn (\n\t\t\tObject.keys(obj)\n\t\t\t\t.sort()\n\t\t\t\t.reduce<Record<string, any>>((sortedObj, prop) => {\n\t\t\t\t\tsortedObj[prop] = sortObjectPropertiesRecursively(obj[prop]);\n\t\t\t\t\treturn sortedObj;\n\t\t\t\t}, {}) as any\n\t\t);\n\t}\n\treturn obj;\n}\n\nexport function getCellMetadata(options: { cell: NotebookCell | NotebookCellData } | { metadata?: { [key: string]: any } }): CellMetadata {\n\tif ('cell' in options) {\n\t\tconst cell = options.cell;\n\t\tconst metadata = {\n\t\t\texecution_count: null,\n\t\t\t// it contains the cell id, and the cell metadata, along with other nb cell metadata\n\t\t\t...(cell.metadata ?? {})\n\t\t} satisfies CellMetadata;\n\t\tif (cell.kind === NotebookCellKindMarkup) {\n\t\t\tdelete (metadata as any).execution_count;\n\t\t}\n\t\treturn metadata;\n\t} else {\n\t\tconst cell = options;\n\t\tconst metadata = {\n\t\t\t// it contains the cell id, and the cell metadata, along with other nb cell metadata\n\t\t\t...(cell.metadata ?? {})\n\t\t};\n\n\t\treturn metadata as CellMetadata;\n\t}\n}\n\nexport function getVSCodeCellLanguageId(metadata: CellMetadata): string | undefined {\n\treturn metadata.metadata?.vscode?.languageId;\n}\nexport function setVSCodeCellLanguageId(metadata: CellMetadata, languageId: string) {\n\tmetadata.metadata = metadata.metadata || {};\n\tmetadata.metadata.vscode = { languageId };\n}\nexport function removeVSCodeCellLanguageId(metadata: CellMetadata) {\n\tif (metadata.metadata?.vscode) {\n\t\tdelete metadata.metadata.vscode;\n\t}\n}\n\nfunction createCodeCellFromNotebookCell(cell: NotebookCellData, preferredLanguage: string | undefined): nbformat.ICodeCell {\n\tconst cellMetadata: CellMetadata = JSON.parse(JSON.stringify(getCellMetadata({ cell })));\n\tcellMetadata.metadata = cellMetadata.metadata || {}; // This cannot be empty.\n\tif (cell.languageId !== preferredLanguage) {\n\t\tsetVSCodeCellLanguageId(cellMetadata, cell.languageId);\n\t} else {\n\t\t// cell current language is the same as the preferred cell language in the document, flush the vscode custom language id metadata\n\t\tremoveVSCodeCellLanguageId(cellMetadata);\n\t}\n\n\tconst codeCell: nbformat.ICodeCell = {\n\t\tcell_type: 'code',\n\t\t// Metadata should always contain the execution_count.\n\t\t// When ever execution summary data changes we will update the metadata to contain the execution count.\n\t\t// Failing to do so means we have a problem.\n\t\t// Also do not read the value of executionSummary here, as its possible user reverted changes to metadata\n\t\t// & in that case execution summary could contain the data, but metadata will not.\n\t\t// In such cases we do not want to re-set the metadata with the value from execution summary (remember, user reverted that).\n\t\texecution_count: cellMetadata.execution_count ?? null,\n\t\tsource: splitCellSourceIntoMultilineString(cell.value),\n\t\toutputs: (cell.outputs || []).map(translateCellDisplayOutput),\n\t\tmetadata: cellMetadata.metadata\n\t};\n\tif (cellMetadata?.id) {\n\t\tcodeCell.id = cellMetadata.id;\n\t}\n\treturn codeCell;\n}\n\nfunction createRawCellFromNotebookCell(cell: NotebookCellData): nbformat.IRawCell {\n\tconst cellMetadata = getCellMetadata({ cell });\n\tconst rawCell: any = {\n\t\tcell_type: 'raw',\n\t\tsource: splitCellSourceIntoMultilineString(cell.value),\n\t\tmetadata: cellMetadata?.metadata || {} // This cannot be empty.\n\t};\n\tif (cellMetadata?.attachments) {\n\t\trawCell.attachments = cellMetadata.attachments;\n\t}\n\tif (cellMetadata?.id) {\n\t\trawCell.id = cellMetadata.id;\n\t}\n\treturn rawCell;\n}\n\n/**\n * Splits the source of a cell into an array of strings, each representing a line.\n * Also normalizes line endings to use LF (`\\n`) instead of CRLF (`\\r\\n`).\n * Same is done in deserializer as well.\n */\nfunction splitCellSourceIntoMultilineString(source: string): string[] {\n\treturn splitMultilineString(source.replace(/\\r\\n/g, '\\n'));\n}\n\nfunction splitMultilineString(source: nbformat.MultilineString): string[] {\n\tif (Array.isArray(source)) {\n\t\treturn source as string[];\n\t}\n\tconst str = source.toString();\n\tif (str.length > 0) {\n\t\t// Each line should be a separate entry, but end with a \\n if not last entry\n\t\tconst arr = str.split('\\n');\n\t\treturn arr\n\t\t\t.map((s, i) => {\n\t\t\t\tif (i < arr.length - 1) {\n\t\t\t\t\treturn `${s}\\n`;\n\t\t\t\t}\n\t\t\t\treturn s;\n\t\t\t})\n\t\t\t.filter(s => s.length > 0); // Skip last one if empty (it's the only one that could be length 0)\n\t}\n\treturn [];\n}\n\nfunction translateCellDisplayOutput(output: NotebookCellOutput): JupyterOutput {\n\tconst customMetadata = output.metadata as CellOutputMetadata | undefined;\n\tlet result: JupyterOutput;\n\t// Possible some other extension added some output (do best effort to translate & save in ipynb).\n\t// In which case metadata might not contain `outputType`.\n\tconst outputType = customMetadata?.outputType as nbformat.OutputType;\n\tswitch (outputType) {\n\t\tcase 'error': {\n\t\t\tresult = translateCellErrorOutput(output);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'stream': {\n\t\t\tresult = convertStreamOutput(output);\n\t\t\tbreak;\n\t\t}\n\t\tcase 'display_data': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'display_data',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {} // This can never be undefined.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase 'execute_result': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'execute_result',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {}, // This can never be undefined.\n\t\t\t\texecution_count:\n\t\t\t\t\ttypeof customMetadata?.executionCount === 'number' ? customMetadata?.executionCount : null // This can never be undefined, only a number or `null`.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase 'update_display_data': {\n\t\t\tresult = {\n\t\t\t\toutput_type: 'update_display_data',\n\t\t\t\tdata: output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {}),\n\t\t\t\tmetadata: customMetadata?.metadata || {} // This can never be undefined.\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tconst isError =\n\t\t\t\toutput.items.length === 1 && output.items.every((item) => item.mime === CellOutputMimeTypes.error);\n\t\t\tconst isStream = output.items.every(\n\t\t\t\t(item) => item.mime === CellOutputMimeTypes.stderr || item.mime === CellOutputMimeTypes.stdout\n\t\t\t);\n\n\t\t\tif (isError) {\n\t\t\t\treturn translateCellErrorOutput(output);\n\t\t\t}\n\n\t\t\t// In the case of .NET & other kernels, we need to ensure we save ipynb correctly.\n\t\t\t// Hence if we have stream output, save the output as Jupyter `stream` else `display_data`\n\t\t\t// Unless we already know its an unknown output type.\n\t\t\tconst outputType: nbformat.OutputType =\n\t\t\t\t<nbformat.OutputType>customMetadata?.outputType || (isStream ? 'stream' : 'display_data');\n\t\t\tlet unknownOutput: nbformat.IUnrecognizedOutput | nbformat.IDisplayData | nbformat.IStream;\n\t\t\tif (outputType === 'stream') {\n\t\t\t\t// If saving as `stream` ensure the mandatory properties are set.\n\t\t\t\tunknownOutput = convertStreamOutput(output);\n\t\t\t} else if (outputType === 'display_data') {\n\t\t\t\t// If saving as `display_data` ensure the mandatory properties are set.\n\t\t\t\tconst displayData: nbformat.IDisplayData = {\n\t\t\t\t\tdata: {},\n\t\t\t\t\tmetadata: {},\n\t\t\t\t\toutput_type: 'display_data'\n\t\t\t\t};\n\t\t\t\tunknownOutput = displayData;\n\t\t\t} else {\n\t\t\t\tunknownOutput = {\n\t\t\t\t\toutput_type: outputType\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (customMetadata?.metadata) {\n\t\t\t\tunknownOutput.metadata = customMetadata.metadata;\n\t\t\t}\n\t\t\tif (output.items.length > 0) {\n\t\t\t\tunknownOutput.data = output.items.reduce((prev: any, curr) => {\n\t\t\t\t\tprev[curr.mime] = convertOutputMimeToJupyterOutput(curr.mime, curr.data as Uint8Array);\n\t\t\t\t\treturn prev;\n\t\t\t\t}, {});\n\t\t\t}\n\t\t\tresult = unknownOutput;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Account for transient data as well\n\t// `transient.display_id` is used to update cell output in other cells, at least thats one use case we know of.\n\tif (result && customMetadata && customMetadata.transient) {\n\t\tresult.transient = customMetadata.transient;\n\t}\n\treturn result;\n}\n\nfunction translateCellErrorOutput(output: NotebookCellOutput): nbformat.IError {\n\t// it should have at least one output item\n\tconst firstItem = output.items[0];\n\t// Bug in VS Code.\n\tif (!firstItem.data) {\n\t\treturn {\n\t\t\toutput_type: 'error',\n\t\t\tename: '',\n\t\t\tevalue: '',\n\t\t\ttraceback: []\n\t\t};\n\t}\n\tconst originalError: undefined | nbformat.IError = output.metadata?.originalError;\n\tconst value: Error = JSON.parse(textDecoder.decode(firstItem.data));\n\treturn {\n\t\toutput_type: 'error',\n\t\tename: value.name,\n\t\tevalue: value.message,\n\t\t// VS Code needs an `Error` object which requires a `stack` property as a string.\n\t\t// Its possible the format could change when converting from `traceback` to `string` and back again to `string`\n\t\t// When .NET stores errors in output (with their .NET kernel),\n\t\t// stack is empty, hence store the message instead of stack (so that somethign gets displayed in ipynb).\n\t\ttraceback: originalError?.traceback || splitMultilineString(value.stack || value.message || '')\n\t};\n}\n\n\nfunction getOutputStreamType(output: NotebookCellOutput): string | undefined {\n\tif (output.items.length > 0) {\n\t\treturn output.items[0].mime === CellOutputMimeTypes.stderr ? 'stderr' : 'stdout';\n\t}\n\n\treturn;\n}\n\ntype JupyterOutput =\n\t| nbformat.IUnrecognizedOutput\n\t| nbformat.IExecuteResult\n\t| nbformat.IDisplayData\n\t| nbformat.IStream\n\t| nbformat.IError;\n\nfunction convertStreamOutput(output: NotebookCellOutput): JupyterOutput {\n\tconst outputs: string[] = [];\n\toutput.items\n\t\t.filter((opit) => opit.mime === CellOutputMimeTypes.stderr || opit.mime === CellOutputMimeTypes.stdout)\n\t\t.map((opit) => textDecoder.decode(opit.data))\n\t\t.forEach(value => {\n\t\t\t// Ensure each line is a separate entry in an array (ending with \\n).\n\t\t\tconst lines = value.split('\\n');\n\t\t\t// If the last item in `outputs` is not empty and the first item in `lines` is not empty, then concate them.\n\t\t\t// As they are part of the same line.\n\t\t\tif (outputs.length && lines.length && lines[0].length > 0) {\n\t\t\t\toutputs[outputs.length - 1] = `${outputs[outputs.length - 1]}${lines.shift()!}`;\n\t\t\t}\n\t\t\tfor (const line of lines) {\n\t\t\t\toutputs.push(line);\n\t\t\t}\n\t\t});\n\n\tfor (let index = 0; index < (outputs.length - 1); index++) {\n\t\toutputs[index] = `${outputs[index]}\\n`;\n\t}\n\n\t// Skip last one if empty (it's the only one that could be length 0)\n\tif (outputs.length && outputs[outputs.length - 1].length === 0) {\n\t\toutputs.pop();\n\t}\n\n\tconst streamType = getOutputStreamType(output) || 'stdout';\n\n\treturn {\n\t\toutput_type: 'stream',\n\t\tname: streamType,\n\t\ttext: outputs\n\t};\n}\n\nfunction convertOutputMimeToJupyterOutput(mime: string, value: Uint8Array) {\n\tif (!value) {\n\t\treturn '';\n\t}\n\ttry {\n\t\tif (mime === CellOutputMimeTypes.error) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn JSON.parse(stringValue);\n\t\t} else if (mime.startsWith('text/') || textMimeTypes.includes(mime)) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn splitMultilineString(stringValue);\n\t\t} else if (mime.startsWith('image/') && mime !== 'image/svg+xml') {\n\t\t\t// Images in Jupyter are stored in base64 encoded format.\n\t\t\t// VS Code expects bytes when rendering images.\n\t\t\tif (typeof Buffer !== 'undefined' && typeof Buffer.from === 'function') {\n\t\t\t\treturn Buffer.from(value).toString('base64');\n\t\t\t} else {\n\t\t\t\treturn btoa(value.reduce((s: string, b: number) => s + String.fromCharCode(b), ''));\n\t\t\t}\n\t\t} else if (mime.toLowerCase().includes('json')) {\n\t\t\tconst stringValue = textDecoder.decode(value);\n\t\t\treturn stringValue.length > 0 ? JSON.parse(stringValue) : stringValue;\n\t\t} else if (mime === 'image/svg+xml') {\n\t\t\treturn splitMultilineString(textDecoder.decode(value));\n\t\t} else {\n\t\t\treturn textDecoder.decode(value);\n\t\t}\n\t} catch (ex) {\n\t\treturn '';\n\t}\n}\n\nexport function createMarkdownCellFromNotebookCell(cell: NotebookCellData): nbformat.IMarkdownCell {\n\tconst cellMetadata = getCellMetadata({ cell });\n\tconst markdownCell: any = {\n\t\tcell_type: 'markdown',\n\t\tsource: splitCellSourceIntoMultilineString(cell.value),\n\t\tmetadata: cellMetadata?.metadata || {} // This cannot be empty.\n\t};\n\tif (cellMetadata?.attachments) {\n\t\tmarkdownCell.attachments = cellMetadata.attachments;\n\t}\n\tif (cellMetadata?.id) {\n\t\tmarkdownCell.id = cellMetadata.id;\n\t}\n\treturn markdownCell;\n}\n\nexport function pruneCell(cell: nbformat.ICell): nbformat.ICell {\n\t// Source is usually a single string on input. Convert back to an array\n\tconst result: nbformat.ICell = {\n\t\t...cell,\n\t\tsource: splitMultilineString(cell.source)\n\t};\n\n\t// Remove outputs and execution_count from non code cells\n\tif (result.cell_type !== 'code') {\n\t\tdelete (<any>result).outputs;\n\t\tdelete (<any>result).execution_count;\n\t} else {\n\t\t// Clean outputs from code cells\n\t\tresult.outputs = result.outputs ? (result.outputs as nbformat.IOutput[]).map(fixupOutput) : [];\n\t}\n\n\treturn result;\n}\nconst dummyStreamObj: nbformat.IStream = {\n\toutput_type: 'stream',\n\tname: 'stdout',\n\ttext: ''\n};\nconst dummyErrorObj: nbformat.IError = {\n\toutput_type: 'error',\n\tename: '',\n\tevalue: '',\n\ttraceback: ['']\n};\nconst dummyDisplayObj: nbformat.IDisplayData = {\n\toutput_type: 'display_data',\n\tdata: {},\n\tmetadata: {}\n};\nconst dummyExecuteResultObj: nbformat.IExecuteResult = {\n\toutput_type: 'execute_result',\n\tname: '',\n\texecution_count: 0,\n\tdata: {},\n\tmetadata: {}\n};\nconst AllowedCellOutputKeys = {\n\t['stream']: new Set(Object.keys(dummyStreamObj)),\n\t['error']: new Set(Object.keys(dummyErrorObj)),\n\t['display_data']: new Set(Object.keys(dummyDisplayObj)),\n\t['execute_result']: new Set(Object.keys(dummyExecuteResultObj))\n};\n\nfunction fixupOutput(output: nbformat.IOutput): nbformat.IOutput {\n\tlet allowedKeys: Set<string>;\n\tswitch (output.output_type) {\n\t\tcase 'stream':\n\t\tcase 'error':\n\t\tcase 'execute_result':\n\t\tcase 'display_data':\n\t\t\tallowedKeys = AllowedCellOutputKeys[output.output_type];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn output;\n\t}\n\tconst result = { ...output };\n\tfor (const k of Object.keys(output)) {\n\t\tif (!allowedKeys.has(k)) {\n\t\t\tdelete result[k];\n\t\t}\n\t}\n\treturn result;\n}\n\n\nexport function serializeNotebookToString(data: NotebookData): string {\n\tconst notebookContent = getNotebookMetadata(data);\n\t// use the preferred language from document metadata or the first cell language as the notebook preferred cell language\n\tconst preferredCellLanguage = notebookContent.metadata?.language_info?.name ?? data.cells.find(cell => cell.kind === 2)?.languageId;\n\n\tnotebookContent.cells = data.cells\n\t\t.map(cell => createJupyterCellFromNotebookCell(cell, preferredCellLanguage))\n\t\t.map(pruneCell);\n\n\tconst indentAmount = data.metadata && 'indentAmount' in data.metadata && typeof data.metadata.indentAmount === 'string' ?\n\t\tdata.metadata.indentAmount :\n\t\t' ';\n\n\treturn serializeNotebookToJSON(notebookContent, indentAmount);\n}\nfunction serializeNotebookToJSON(notebookContent: Partial<nbformat.INotebookContent>, indentAmount: string): string {\n\t// ipynb always ends with a trailing new line (we add this so that SCMs do not show unnecessary changes, resulting from a missing trailing new line).\n\tconst sorted = sortObjectPropertiesRecursively(notebookContent);\n\n\treturn JSON.stringify(sorted, undefined, indentAmount) + '\\n';\n}\n\nexport function getNotebookMetadata(document: NotebookDocument | NotebookData) {\n\tconst existingContent: Partial<nbformat.INotebookContent> = document.metadata || {};\n\tconst notebookContent: Partial<nbformat.INotebookContent> = {};\n\tnotebookContent.cells = existingContent.cells || [];\n\tnotebookContent.nbformat = existingContent.nbformat || defaultNotebookFormat.major;\n\tnotebookContent.nbformat_minor = existingContent.nbformat_minor ?? defaultNotebookFormat.minor;\n\tnotebookContent.metadata = existingContent.metadata || {};\n\treturn notebookContent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { DocumentSelector } from 'vscode';\n\nexport const defaultNotebookFormat = { major: 4, minor: 5 };\nexport const ATTACHMENT_CLEANUP_COMMANDID = 'ipynb.cleanInvalidImageAttachment';\n\nexport const JUPYTER_NOTEBOOK_MARKDOWN_SELECTOR: DocumentSelector = { notebookType: 'jupyter-notebook', language: 'markdown' };\n\n// Copied from NotebookCellKind.Markup as we cannot import it from vscode directly in worker threads.\nexport const NotebookCellKindMarkup = 1;\n// Copied from NotebookCellKind.Code as we cannot import it from vscode directly in worker threads.\nexport const NotebookCellKindCode = 2;\n\nexport enum CellOutputMimeTypes {\n\terror = 'application/vnd.code.notebook.error',\n\tstderr = 'application/vnd.code.notebook.stderr',\n\tstdout = 'application/vnd.code.notebook.stdout'\n}\n\nexport const textMimeTypes = ['text/plain', 'text/markdown', 'text/latex', CellOutputMimeTypes.stderr, CellOutputMimeTypes.stdout];\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { serializeNotebookToString } from './serializers';\nimport type { NotebookData } from 'vscode';\n\nonmessage = (e) => {\n\tconst data = e.data as { id: string; data: NotebookData };\n\tconst json = serializeNotebookToString(data.data);\n\tconst bytes = new TextEncoder().encode(json);\n\tpostMessage({ id: data.id, data: bytes });\n};\n"],"names":["metadata","vscode","languageId","data","notebookContent","getNotebookMetadata","preferredCellLanguage","language_info","name","cells","find","cell","kind","map","createJupyterCellFromNotebookCell","pruneCell","indentAmount","sorted","sortObjectPropertiesRecursively","JSON","stringify","undefined","serializeNotebookToJSON","textDecoder","TextDecoder","vscCell","preferredLanguage","NotebookCellKindMarkup","createMarkdownCellFromNotebookCell","cellMetadata","getCellMetadata","rawCell","cell_type","source","splitCellSourceIntoMultilineString","value","attachments","id","createRawCellFromNotebookCell","parse","setVSCodeCellLanguageId","removeVSCodeCellLanguageId","codeCell","execution_count","outputs","translateCellDisplayOutput","createCodeCellFromNotebookCell","obj","Array","isArray","Object","keys","length","sort","reduce","sortedObj","prop","options","splitMultilineString","replace","str","toString","arr","split","s","i","filter","output","customMetadata","result","outputType","translateCellErrorOutput","convertStreamOutput","output_type","items","prev","curr","mime","convertOutputMimeToJupyterOutput","executionCount","isError","every","item","CellOutputMimeTypes","error","isStream","stderr","stdout","unknownOutput","transient","firstItem","ename","evalue","traceback","originalError","decode","message","stack","opit","forEach","lines","shift","line","push","index","pop","streamType","getOutputStreamType","text","stringValue","startsWith","textMimeTypes","includes","Buffer","from","btoa","b","String","fromCharCode","toLowerCase","ex","markdownCell","fixupOutput","AllowedCellOutputKeys","Set","allowedKeys","k","has","document","existingContent","nbformat","defaultNotebookFormat","major","nbformat_minor","minor","ATTACHMENT_CLEANUP_COMMANDID","JUPYTER_NOTEBOOK_MARKDOWN_SELECTOR","notebookType","language","NotebookCellKindCode","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","onmessage","e","json","serializeNotebookToString","bytes","TextEncoder","encode","postMessage"],"sourceRoot":""}